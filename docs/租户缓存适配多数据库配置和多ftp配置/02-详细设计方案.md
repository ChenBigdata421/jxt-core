# 租户缓存适配多数据库配置和多FTP配置 - 详细设计方案

## 1. 设计目标

1. 支持 tenant-service 新的多数据库配置结构（服务级配置）
2. 支持新的多FTP配置结构
3. 保持现有公共 API 的向后兼容性
4. 提供数据库密码的安全获取机制
5. 保持现有的性能特性（Copy-on-Write、原子读取）

## 2. 架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────────────┐
│                         消费服务                                  │
│  (evidence-command, evidence-query, file-storage, etc.)         │
└───────────────────────────┬─────────────────────────────────────┘
                            │
┌───────────────────────────▼─────────────────────────────────────┐
│                    Cache Layer (v2 API)                         │
│  database.Cache / ftp.Cache (新增方法支持 serviceCode)          │
└───────────────────────────┬─────────────────────────────────────┘
                            │
┌───────────────────────────▼─────────────────────────────────────┐
│                    Provider Layer                               │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │  tenantData v2                                            │  │
│  │  - Metas: map[int]*TenantMeta                             │  │
│  │  - Databases: map[int]map[string]*ServiceDatabaseConfig   │  │  新结构
│  │  - Ftps: map[int][]*FtpConfigDetail                       │  │  新结构
│  │  - Storages: map[int]*StorageConfig                       │  │
│  └───────────────────────────────────────────────────────────┘  │
│                            │                                     │
│  ┌─────────────────────────▼─────────────────────────────────┐  │
│  │  Watch Layer                                              │  │
│  │  - Watch keys: /jxt/config/tenants/*/services/*/database  │  │
│  │  - Watch keys: /tenants/*/ftp                             │  │
│  └──────────────────────────────────────────────────────────┘  │
└───────────────────────────┬─────────────────────────────────────┘
                            │
┌───────────────────────────▼─────────────────────────────────────┐
│                          ETCD                                    │
└─────────────────────────────────────────────────────────────────┘
                            │
┌───────────────────────────▼─────────────────────────────────────┐
│                    tenant-service                               │
│  发布配置到 ETCD + 提供密码查询 API                              │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 数据流设计

#### 数据库配置获取流程

```
┌────────────┐     ┌────────────┐     ┌────────────┐     ┌──────────┐
│ 消费服务    │ ──▶ │ database   │ ──▶ │ Provider   │ ──▶ │ ETCD     │
│            │     │ Cache      │     │            │     │          │
└────────────┘     └────────────┘     └────────────┘     └──────────┘
                                               │
                                               ▼
                                       ┌────────────┐
                                       │ 密码为空?   │
                                       └────────────┘
                                              │ Yes
                                              ▼
                                       ┌────────────┐     ┌────────────┐
                                       │ Password   │ ──▶ │ tenant-    │
                                       │ Provider  │     │ service    │
                                       │ (缓存)    │     │ API        │
                                       └────────────┘     └────────────┘
```

## 3. 数据结构设计

### 3.1 Provider 层数据结构

#### 修改 tenantData 结构 (provider/models.go)

```go
// tenantData v2 - 支持多数据库和多FTP配置
type tenantData struct {
    Metas    map[int]*TenantMeta                    `json:"metas"`
    Databases map[int]map[string]*ServiceDatabaseConfig `json:"databases"` // v2: tenantID -> serviceCode -> config
    Ftps      map[int][]*FtpConfigDetail             `json:"ftps"`          // v2: tenantID -> configs[]
    Storages  map[int]*StorageConfig                `json:"storages"`
}

// ServiceDatabaseConfig v2 - 服务级数据库配置
type ServiceDatabaseConfig struct {
    TenantID    int    `json:"tenantId"`
    ServiceCode string `json:"serviceCode"`  // evidence-command, evidence-query, etc.
    Driver      string `json:"driver"`
    Host        string `json:"host"`
    Port        int    `json:"port"`
    Database    string `json:"database"`
    Username    string `json:"username"`
    SSLMode     string `json:"sslMode"`
    MaxOpenConns    int `json:"maxOpenConns"`
    MaxIdleConns    int `json:"maxIdleConns"`
    ConnMaxIdleTime int `json:"connMaxIdleTime"`
    ConnMaxLifeTime int `json:"connMaxLifeTime"`
    ConnectTimeout  int `json:"connectTimeout"`
    ReadTimeout     int `json:"readTimeout"`
    WriteTimeout    int `json:"writeTimeout"`
    Enabled         bool  `json:"enabled"`
}

// FtpConfigDetail v2 - FTP配置详情
type FtpConfigDetail struct {
    TenantID     int    `json:"tenantId"`
    Username     string `json:"username"`
    PasswordHash string `json:"passwordHash"`
    Description  string `json:"description"`
    Status       string `json:"status"` // active, inactive
}

// FtpConfigs v2 - FTP配置容器
type FtpConfigs struct {
    TenantID    int               `json:"tenantId"`
    FtpConfigs []*FtpConfigDetail `json:"ftpConfigs"`
}
```

### 3.2 Cache 层数据结构

#### database/config.go 保持不变
```go
// TenantDatabaseConfig - 保持现有结构
// 添加 ServiceCode 字段用于服务标识
type TenantDatabaseConfig struct {
    TenantID    int    `json:"tenant_id"`
    Code        string `json:"code"`
    Name        string `json:"name"`
    ServiceCode string `json:"service_code"` // 新增

    // ... 现有字段
}
```

#### ftp/config.go 新增结构
```go
// TenantFtpConfigList v2 - FTP配置列表
type TenantFtpConfigList struct {
    TenantID int              `json:"tenant_id"`
    Code     string           `json:"code"`
    Name     string           `json:"name"`
    Configs  []TenantFtpConfig `json:"configs"`
}

// TenantFtpConfigDetail v2 - 单个FTP配置详情
type TenantFtpConfigDetail struct {
    Username     string `json:"username"`
    PasswordHash string `json:"password_hash"`
    Description  string `json:"description"`
    Status       string `json:"status"`
}
```

## 4. API 设计

### 4.1 Provider API

#### 新增方法

```go
// provider/provider.go

// ========== 数据库配置 API (v2) ==========

// GetServiceDatabaseConfig 获取指定服务的数据库配置
func (p *Provider) GetServiceDatabaseConfig(tenantID int, serviceCode string) (*ServiceDatabaseConfig, bool)

// GetAllServiceDatabaseConfigs 获取租户所有服务的数据库配置
func (p *Provider) GetAllServiceDatabaseConfigs(tenantID int) (map[string]*ServiceDatabaseConfig, bool)

// ========== FTP 配置 API (v2) ==========

// GetFtpConfigs 获取租户所有FTP配置
func (p *Provider) GetFtpConfigs(tenantID int) ([]*FtpConfigDetail, bool)

// GetFtpConfigByUsername 通过用户名查找FTP配置
func (p *Provider) GetFtpConfigByUsername(username string) (*FtpConfigDetail, bool)

// GetActiveFtpConfigs 获取租户所有活跃的FTP配置
func (p *Provider) GetActiveFtpConfigs(tenantID int) ([]*FtpConfigDetail, bool)

// ========== 密码获取 API ==========

// GetDatabasePassword 获取数据库密码（从缓存或API）
func (p *Provider) GetDatabasePassword(ctx context.Context, tenantID int, serviceCode string) (string, error)
```

### 4.2 Cache Layer API

#### database/cache.go

```go
// ========== v1 API (保持兼容) ==========

// GetByID 获取租户默认数据库配置
// 注意：v2 中此方法获取 evidence-command 的配置
func (c *Cache) GetByID(ctx context.Context, tenantID int) (*TenantDatabaseConfig, error)

// ========== v2 API (新增) ==========

// GetByService 获取指定服务的数据库配置
func (c *Cache) GetByService(ctx context.Context, tenantID int, serviceCode string) (*TenantDatabaseConfig, error)

// GetAllServices 获取租户所有服务的数据库配置
func (c *Cache) GetAllServices(ctx context.Context, tenantID int) (map[string]*TenantDatabaseConfig, error)

// GetConnection � 获取带有密码的数据库连接配置
func (c *Cache) GetConnection(ctx context.Context, tenantID int, serviceCode string) (*TenantDatabaseConfig, error)
```

#### ftp/cache.go

```go
// ========== v1 API (保持兼容) ==========

// GetByID 获取租户FTP配置
// v2 中返回第一个活跃配置
func (c *Cache) GetByID(ctx context.Context, tenantID int) (*TenantFtpConfig, error)

// ========== v2 API (新增) ==========

// GetAll 获取租户所有FTP配置
func (c *Cache) GetAll(ctx context.Context, tenantID int) ([]*TenantFtpConfigDetail, error)

// GetByUsername 通过用户名获取FTP配置
func (c *Cache) GetByUsername(ctx context.Context, username string) (*TenantFtpConfig, error)

// GetActive 获取租户所有活跃FTP配置
func (c *Cache) GetActive(ctx context.Context, tenantID int) ([]*TenantFtpConfigDetail, error)
```

## 5. 密码获取机制设计

### 5.1 PasswordCache 组件

```go
// provider/password_cache.go

// PasswordCache 数据库密码缓存
type PasswordCache struct {
    cache      *cache.Cache // key: "tenantID:serviceCode", value: password
    ttl        time.Duration
    httpClient *http.Client
}

// NewPasswordCache 创建密码缓存
func NewPasswordCache(ttl time.Duration) *PasswordCache

// Get 获取密码（优先从缓存）
func (pc *PasswordCache) Get(ctx context.Context, tenantID int, serviceCode string, apiURL string) (string, error)

// invalidate 作废指定缓存
func (pc *PasswordCache) Invalidate(tenantID int, serviceCode string)

// invalidateAll 作废所有缓存
func (pc *PasswordCache) InvalidateAll()
```

### 5.2 API 调用设计

```go
// tenant-service API 端点
GET /api/v1/internal/tenants/{tenantId}/services/{serviceCode}/database/password
Authorization: Bearer <internal-service-token>

Response:
{
  "code": 0,
  "data": {
    "password": "encrypted_password_here"
  }
}
```

## 6. Watch 逻辑设计

### 6.1 Key 监听范围

```go
// provider/provider.go

const (
    // v2 keys
    prefixDatabaseConfig = "/jxt/config/tenants/"
    prefixFtpConfig      = "/tenants/"
)

// getWatchKeys 返回需要监听的 key 前缀
func (p *Provider) getWatchKeys() []string {
    return []string{
        // 数据库配置: /jxt/config/tenants/{tenantId}/services/{serviceCode}/database
        prefixDatabaseConfig,
        // FTP 配置: /tenants/{tenantId}/ftp
        prefixFtpConfig,
    }
}
```

### 6.2 事件处理逻辑

```go
// handleEtcdEvent 处理 ETCD 事件
func (p *Provider) handleEtcdEvent(event *clientv3.Event) {
    key := string(event.Kv.Key)

    switch {
    case isServiceDatabaseKey(key):
        p.handleDatabaseConfigChange(event, key)
    case isFtpConfigKey(key):
        p.handleFtpConfigChange(event, key)
    // ... 其他配置类型
    }
}

// handleDatabaseConfigChange 处理数据库配置变更
func (p *Provider) handleDatabaseConfigChange(event *clientv3.Event, key string) {
    // 解析 key: /jxt/config/tenants/{tenantId}/services/{serviceCode}/database
    parts := strings.Split(key, "/")
    tenantID := parseTenantID(parts[4])
    serviceCode := parseServiceCode(parts[6])

    newData := p.data.Load().(*tenantData)
    updatedData := p.copyData(newData)

    if event.Type == clientv3.EventTypeDelete {
        delete(updatedData.Databases[tenantID], serviceCode)
    } else {
        config := parseServiceDatabaseConfig(event.Kv.Value)
        if updatedData.Databases[tenantID] == nil {
            updatedData.Databases[tenantID] = make(map[string]*ServiceDatabaseConfig)
        }
        updatedData.Databases[tenantID][serviceCode] = config
    }

    p.data.Store(updatedData)
}

// handleFtpConfigChange 处理FTP配置变更
func (p *Provider) handleFtpConfigChange(event *clientv3.Event, key string) {
    // 解析 key: /tenants/{tenantId}/ftp
    tenantID := parseTenantID(key)

    newData := p.data.Load().(*tenantData)
    updatedData := p.copyData(newData)

    if event.Type == clientv3.EventTypeDelete {
        delete(updatedData.Ftps, tenantID)
    } else {
        configs := parseFtpConfigs(event.Kv.Value)
        updatedData.Ftps[tenantID] = configs
    }

    p.data.Store(updatedData)
}
```

## 7. 兼容性设计

### 7.1 渐进式迁移支持

```go
// provider/provider.go

// Provider 配置选项
type Options struct {
    Mode CompatibilityMode
}

type CompatibilityMode string

const (
    ModeV2Only       CompatibilityMode = "v2-only"       // 仅支持新格式
    ModeV1Fallback   CompatibilityMode = "v1-fallback"   // 新格式优先，回退旧格式
    ModeDualSupport  CompatibilityMode = "dual-support"  // 同时支持新旧格式
)

// GetDatabaseConfig 兼容方法
func (p *Provider) GetDatabaseConfig(tenantID int) (*DatabaseConfig, bool) {
    // v2 优先
    if config, ok := p.GetServiceDatabaseConfig(tenantID, "evidence-command"); ok {
        return p.convertToV1(config), true
    }

    // v1 回退
    if p.options.Mode == ModeV1Fallback || p.options.Mode == ModeDualSupport {
        // 从旧结构获取
    }

    return nil, false
}
```

### 7.2 数据转换方法

```go
// convertToV1 将 ServiceDatabaseConfig 转换为 DatabaseConfig
func (p *Provider) convertToV1(v2 *ServiceDatabaseConfig) *DatabaseConfig {
    return &DatabaseConfig{
        TenantID: v2.TenantID,
        // ... 字段映射
    }
}
```

## 8. 测试设计

### 8.1 单元测试

```go
// provider/provider_test.go

// TestServiceDatabaseConfig 测试多数据库配置
func TestServiceDatabaseConfig(t *testing.T) {
    tests := []struct {
        name        string
        tenantID    int
        serviceCode string
        expectFound bool
    }{
        {"evidence-command", 1, "evidence-command", true},
        {"evidence-query", 1, "evidence-query", true},
        {"unknown service", 1, "unknown", false},
        {"unknown tenant", 999, "evidence-command", false},
    }
    // ...
}

// TestMultipleFtpConfigs 测试多FTP配置
func TestMultipleFtpConfigs(t *testing.T) {
    // ...
}

// TestPasswordCache 测试密码缓存
func TestPasswordCache(t *testing.T) {
    // ...
}
```

### 8.2 集成测试

```go
// provider/integration_test.go

// TestEtcdWatchServiceDatabase 测试数据库配置监听
func TestEtcdWatchServiceDatabase(t *testing.T) {
    // 模拟 tenant-service 发布配置
    // 验证 Provider 正确接收
}

// TestEtcdWatchFtpConfigs 测试FTP配置监听
func TestEtcdWatchFtpConfigs(t *testing.T) {
    // ...
}
```

## 9. 部署计划

### 9.1 阶段一：代码更新（不破坏现有功能）

1. 新增 v2 数据结构（保留 v1）
2. 新增 v2 API 方法
3. 添加兼容层
4. 更新单元测试

### 9.2 阶段二：消费服务迁移

1. evidence-management/command 迁移到 v2 API
2. evidence-management/query 迁移到 v2 API
3. file-storage-service 迁移到 v2 API
4. 逐个验证和部署

### 9.3 阶段三：清理

1. 确认所有服务迁移完成
2. 移除 v1 兼容代码
3. 清理旧测试用例

## 10. 监控和运维

### 10.1 监控指标

```go
// 添加监控指标
var (
    metricDatabaseConfigCacheHit = prometheus.NewCounter(...)
    metricDatabaseConfigCacheMiss = prometheus.NewCounter(...)
    metricPasswordAPICall = prometheus.NewCounter(...)
    metricPasswordCacheHit = prometheus.NewCounter(...)
)
```

### 10.2 日志记录

```go
// 添加结构化日志
logger.Info("loading database config",
    "tenant_id", tenantID,
    "service_code", serviceCode,
    "cache_hit", cached,
)
```

## 11. 风险缓解

| 风险 | 缓解措施 |
|-----|---------|
| API 性能问题 | 密码本地缓存 (TTL 1小时) |
| 内存占用增加 | 评估和监控内存使用 |
| 迁移期间混乱 | 明确的阶段划分和回滚计划 |
| ETCD watch 断连 | 保持现有的重连机制 |

## 12. 实施清单

- [ ] 1. 更新 provider/models.go 数据结构
- [ ] 2. 修改 provider/provider.go watch 逻辑
- [ ] 3. 实现 database/cache.go v2 API
- [ ] 4. 实现 ftp/cache.go v2 API
- [ ] 5. 实现 PasswordCache 组件
- [ ] 6. 更新单元测试
- [ ] 7. 更新文档
- [ ] 8. Code Review
- [ ] 9. 合并到主分支
