# jxt-core 数据库密码加密支持设计

**文档版本**: v1.0
**创建日期**: 2026-02-03
**状态**: 设计完成

---

## 1. 概述

本文档描述 jxt-core 如何支持 tenant-service 发布到 etcd 的加密数据库密码。

### 1.1 目标

- jxt-core 的 Provider 能够从 etcd 读取包含加密密码的服务数据库配置
- 微服务可以通过 Provider 的 API 解密密码并建立数据库连接
- tenant-service 也可以使用 jxt-core 的加密服务

### 1.2 核心设计决策

| 决策项 | 选择 |
|--------|------|
| 解密API | `ServiceDatabaseConfig.DecryptPassword(encryptionKey string)` |
| 向后兼容 | 不考虑，只支持新格式 |
| 密钥管理 | 微服务自己管理，jxt-core 不存储 |
| 加密模块 | `jxt-core/sdk/pkg/crypto/` 独立模块 |
| 错误处理 | 简单错误返回 |
| Base64处理 | crypto 服务内部处理 |

---

## 2. 架构设计

### 2.1 系统流程

```
┌─────────────────────────────────────────────────────────────────┐
│                      密码加密存储流程                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────┐     ┌──────────────┐     ┌──────────────┐    │
│  │  创建/更新    │ --> │  AES-GCM     │ --> │  存储到DB     │    │
│  │  配置        │     │  加密        │     │  (加密)       │    │
│  └──────────────┘     └──────────────┘     └──────────────┘    │
│                                                         │        │
│                                                         v        │
│  ┌──────────────┐     ┌──────────────┐     ┌──────────────┐    │
│  │  发布到etcd   │ <-- │  获取加密    │ <-- │  从DB读取     │    │
│  │  (含加密密码) │     │  密码        │     │  配置         │    │
│  └──────────────┘     └──────────────┘     └──────────────┘    │
│                                                         │        │
│                                                         v        │
│  ┌──────────────┐     ┌──────────────┐     ┌──────────────┐    │
│  │  jxt-core    │ --> │  AES-GCM     │ --> │  建立DB连接   │    │
│  │  读取etcd配置 │     │  解密        │     │              │    │
│  └──────────────┘     └──────────────┘     └──────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 模块结构

```
jxt-core/sdk/pkg/
├── crypto/                 # 新建：加密服务模块
│   ├── aes_gcm.go          # AES-256-GCM 加密服务实现
│   ├── errors.go           # 错误定义
│   └── crypto_test.go      # 单元测试
└── tenant/provider/
    ├── models.go           # 更新：ServiceDatabaseConfig 新增字段和方法
    └── provider_crypto_test.go  # 新建：集成测试
```

---

## 3. crypto 模块设计

### 3.1 AES-256-GCM 加密服务

**文件**: `sdk/pkg/crypto/aes_gcm.go`

```go
package crypto

import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/rand"
    "encoding/base64"
    "errors"
    "fmt"
    "io"
)

// CryptoService AES-256-GCM 加密服务
type CryptoService struct {
    key []byte // 32字节密钥
}

// NewCryptoService 创建加密服务（密钥必须是32字节）
func NewCryptoService(key string) (*CryptoService, error) {
    if len(key) != 32 {
        return nil, ErrInvalidKeyLength
    }
    return &CryptoService{key: []byte(key)}, nil
}

// Encrypt 加密明文，返回 Base64 编码的密文
func (s *CryptoService) Encrypt(plaintext string) (string, error) {
    block, err := aes.NewCipher(s.key)
    if err != nil {
        return "", fmt.Errorf("failed to create cipher: %w", err)
    }

    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return "", fmt.Errorf("failed to create GCM: %w", err)
    }

    // 生成随机 nonce
    nonce := make([]byte, gcm.NonceSize())
    if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
        return "", fmt.Errorf("failed to generate nonce: %w", err)
    }

    // 加密并附加认证标签
    ciphertext := gcm.Seal(nonce, nonce, []byte(plaintext), nil)

    // Base64 编码
    return base64.StdEncoding.EncodeToString(ciphertext), nil
}

// Decrypt 解密 Base64 编码的密文，返回明文
func (s *CryptoService) Decrypt(ciphertextBase64 string) (string, error) {
    // Base64 解码
    ciphertext, err := base64.StdEncoding.DecodeString(ciphertextBase64)
    if err != nil {
        return "", fmt.Errorf("%w: %v", ErrInvalidCiphertext, err)
    }

    block, err := aes.NewCipher(s.key)
    if err != nil {
        return "", fmt.Errorf("failed to create cipher: %w", err)
    }

    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return "", fmt.Errorf("failed to create GCM: %w", err)
    }

    nonceSize := gcm.NonceSize()
    if len(ciphertext) < nonceSize {
        return "", ErrInvalidCiphertext
    }

    // 提取 nonce 和密文
    nonce, cipher := ciphertext[:nonceSize], ciphertext[nonceSize:]

    // 解密并验证
    plaintext, err := gcm.Open(nil, nonce, cipher, nil)
    if err != nil {
        return "", ErrDecryptionFailed
    }

    return string(plaintext), nil
}
```

### 3.2 错误定义

**文件**: `sdk/pkg/crypto/errors.go`

```go
package crypto

import "errors"

var (
    // ErrInvalidKeyLength 密钥长度无效
    ErrInvalidKeyLength = errors.New("encryption key must be 32 bytes")

    // ErrInvalidCiphertext 密文格式无效
    ErrInvalidCiphertext = errors.New("invalid ciphertext format")

    // ErrDecryptionFailed 解密失败（认证失败）
    ErrDecryptionFailed = errors.New("decryption failed: authentication failed")
)
```

### 3.3 单元测试

**文件**: `sdk/pkg/crypto/crypto_test.go`

```go
package crypto

import (
    "testing"
)

func TestNewCryptoService_ValidKey(t *testing.T) {
    key := "12345678901234567890123456789012" // 32 bytes
    _, err := NewCryptoService(key)
    if err != nil {
        t.Fatalf("expected no error, got %v", err)
    }
}

func TestNewCryptoService_InvalidKeyLength(t *testing.T) {
    key := "short"
    _, err := NewCryptoService(key)
    if err != ErrInvalidKeyLength {
        t.Fatalf("expected ErrInvalidKeyLength, got %v", err)
    }
}

func TestEncryptDecrypt_Success(t *testing.T) {
    key := "12345678901234567890123456789012"
    service, err := NewCryptoService(key)
    if err != nil {
        t.Fatal(err)
    }

    plaintext := "my-secret-password"

    // 加密
    ciphertext, err := service.Encrypt(plaintext)
    if err != nil {
        t.Fatalf("encrypt failed: %v", err)
    }

    // 密文应该与原文不同
    if ciphertext == plaintext {
        t.Fatal("ciphertext should differ from plaintext")
    }

    // 解密
    decrypted, err := service.Decrypt(ciphertext)
    if err != nil {
        t.Fatalf("decrypt failed: %v", err)
    }

    // 解密结果应该与原文相同
    if decrypted != plaintext {
        t.Fatalf("decrypted = %q, want %q", decrypted, plaintext)
    }
}

func TestDecrypt_InvalidCiphertext(t *testing.T) {
    key := "12345678901234567890123456789012"
    service, _ := NewCryptoService(key)

    _, err := service.Decrypt("not-valid-base64!!!")
    if err == nil {
        t.Fatal("expected error for invalid base64")
    }
}

func TestDecrypt_WrongKey(t *testing.T) {
    key1 := "12345678901234567890123456789012"
    key2 := "00000000000000000000000000000000"

    service1, _ := NewCryptoService(key1)
    service2, _ := NewCryptoService(key2)

    plaintext := "my-secret-password"
    ciphertext, _ := service1.Encrypt(plaintext)

    // 用错误的密钥解密应该失败
    _, err := service2.Decrypt(ciphertext)
    if err != ErrDecryptionFailed {
        t.Fatalf("expected ErrDecryptionFailed, got %v", err)
    }
}
```

---

## 4. ServiceDatabaseConfig 模型更新

### 4.1 结构体变更

**文件**: `sdk/pkg/tenant/provider/models.go`

```go
// ServiceDatabaseConfig 服务级数据库配置
type ServiceDatabaseConfig struct {
    TenantID          int    `json:"tenantId"`
    ServiceCode       string `json:"serviceCode"`
    Driver            string `json:"driver"`
    Host              string `json:"host"`
    Port              int    `json:"port"`
    Database          string `json:"database"`
    Username          string `json:"username"`
    Password          string `json:"password"`           // 新增：加密后的密码（Base64编码）
    SSLMode           string `json:"sslMode"`
    MaxOpenConns      int    `json:"maxOpenConns"`
    MaxIdleConns      int    `json:"maxIdleConns"`
    PasswordEncrypted bool   `json:"passwordEncrypted"`  // 新增：密码加密标识
}
```

### 4.2 解密方法

```go
import "jxt-evidence-system/jxt-core/sdk/pkg/crypto"

// DecryptPassword 解密数据库密码
// encryptionKey: 32字节的 AES-256 密钥（由调用者传入）
// 返回: 解密后的明文密码
func (c *ServiceDatabaseConfig) DecryptPassword(encryptionKey string) (string, error) {
    if c.Password == "" {
        return "", fmt.Errorf("password is empty")
    }
    if !c.PasswordEncrypted {
        return "", fmt.Errorf("password is not encrypted")
    }

    cryptoService, err := crypto.NewCryptoService(encryptionKey)
    if err != nil {
        return "", fmt.Errorf("failed to create crypto service: %w", err)
    }

    password, err := cryptoService.Decrypt(c.Password)
    if err != nil {
        return "", fmt.Errorf("failed to decrypt password: %w", err)
    }

    return password, nil
}

// HasEncryptedPassword 检查是否有加密的密码
func (c *ServiceDatabaseConfig) HasEncryptedPassword() bool {
    return c.PasswordEncrypted && c.Password != ""
}
```

---

## 5. 微服务使用示例

```go
package main

import (
    "fmt"
    "jxt-evidence-system/jxt-core/sdk/pkg/tenant/provider"
    "os"
)

func getDatabaseConnection(tenantID int, serviceCode string) error {
    // 1. 从环境变量获取加密密钥
    encryptionKey := os.Getenv("ENCRYPTION_KEY")

    // 2. 从 Provider 获取配置
    config, ok := provider.GetServiceDatabaseConfig(tenantID, serviceCode)
    if !ok {
        return fmt.Errorf("database config not found")
    }

    // 3. 解密密码
    password, err := config.DecryptPassword(encryptionKey)
    if err != nil {
        return fmt.Errorf("failed to decrypt password: %w", err)
    }

    // 4. 构建数据库连接
    dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?parseTime=true",
        config.Username, password, config.Host, config.Port, config.Database)

    // 使用 dsn 建立连接...
    return nil
}
```

---

## 6. 实施步骤

### 6.1 任务列表

1. **创建 crypto 模块**
   - 创建 `sdk/pkg/crypto/` 目录
   - 实现 `aes_gcm.go`（加密服务）
   - 实现 `errors.go`（错误定义）
   - 实现 `crypto_test.go`（单元测试）

2. **更新 ServiceDatabaseConfig 模型**
   - 在 `models.go` 中添加 `Password` 和 `PasswordEncrypted` 字段
   - 实现 `DecryptPassword()` 方法
   - 实现 `HasEncryptedPassword()` 方法

3. **添加集成测试**
   - 创建 `provider_crypto_test.go`
   - 测试 ETCD → Provider → 解密完整流程

4. **更新文档**
   - 创建 `sdk/pkg/crypto/README.md`
   - 更新 `sdk/pkg/tenant/README.md`

### 6.2 验收标准

- [ ] 所有单元测试通过（6+ 个测试用例）
- [ ] 集成测试通过
- [ ] 微服务可以成功解密密码并连接数据库
- [ ] 文档完整

---

## 7. 安全考虑

### 7.1 加密算法

- **算法**: AES-256-GCM
- **密钥长度**: 32 bytes (256 bits)
- **Nonce**: 12 bytes（随机生成每次加密）
- **认证**: GCM 提供内置认证，检测密文篡改

### 7.2 密钥管理

- 密钥通过环境变量 `ENCRYPTION_KEY` 配置
- 所有服务必须使用相同的密钥
- 密钥长度必须是 32 字节
- 生产环境建议使用密钥管理服务（如 HashiCorp Vault）

### 7.3 密钥轮换

建议每 90-180 天轮换一次密钥：
1. 生成新密钥
2. 使用新密钥加密新密码
3. 重新发布所有租户配置到 etcd
4. 更新所有微服务的密钥
5. 删除旧密钥

---

## 8. 相关文档

- [06-数据库密码加密方案.md](./06-数据库密码加密方案.md) - tenant-service 加密方案
- [05-jxt-core适配指南.md](./05-jxt-core适配指南.md) - jxt-core 适配指南
