# tenant-service ETCD Key 格式重构 - 新格式设计

**文档版本**: v1.0
**创建日期**: 2026-02-03
**作者**: 开发团队
**状态**: 设计完成

## 1. 设计原则

### 1.1 统一性
- 所有 Key 使用统一的 `jxt/` 前缀
- 索引类配置统一组织结构
- 命名风格一致（kebab-case）

### 1.2 简洁性
- 消除双斜杠
- 消除重复前缀
- 嵌套层级不超过 3 层

### 1.3 语义化
- Key 结构清晰反映数据层次
- 使用有意义的命名
- 符合 RESTful 风格

## 2. 新格式定义

### 2.1 整体结构

```
jxt/
├── tenants/                                    # 租户配置
│   ├── {id}/
│   │   ├── meta                               # 租户元数据
│   │   ├── domain/
│   │   │   ├── primary
│   │   │   ├── aliases                         # JSON array
│   │   │   └── internal
│   │   ├── database/                           # 服务数据库配置
│   │   │   ├── evidence-command
│   │   │   ├── evidence-query
│   │   │   ├── file-storage
│   │   │   └── security-management
│   │   ├── ftp/                                # FTP配置（每个用户一个Key）
│   │   │   ├── {username}
│   │   │   └── {username}
│   │   └── storage
│   │
│   └── _index/                                 # 租户索引
│       ├── by-code/{code}
│       ├── by-name/{name}
│       ├── ftp-user/{username}
│       └── host/{host}
│
├── common/                                     # 公共配置
│   ├── resolver
│   └── storage-directory
│
├── platform/
│   └── configs/{key}
│
└── _health/
    └── sentinel
```

### 2.2 详细格式定义

#### 2.2.1 租户元数据

**Key**: `jxt/tenants/{id}/meta`

**值**:
```json
{
  "id": 1,
  "code": "default",
  "name": "默认租户",
  "status": "active",
  "billingPlan": "enterprise"
}
```

#### 2.2.2 服务数据库配置

**Key**: `jxt/tenants/{id}/database/{serviceCode}`

**serviceCode 取值**:
- `evidence-command` - 证据管理命令服务
- `evidence-query` - 证据管理查询服务
- `file-storage` - 文件存储服务
- `security-management` - 安全管理服务

**值**:
```json
{
  "tenantId": 1,
  "serviceCode": "evidence-command",
  "driver": "mysql",
  "host": "mysql-command",
  "port": 3306,
  "database": "tenant_default_evidence_command",
  "username": "tenant_default_cmd",
  "sslMode": "disable",
  "maxOpenConns": 100,
  "maxIdleConns": 20,
  "enabled": true
}
```

#### 2.2.3 FTP 配置

**Key**: `jxt/tenants/{id}/ftp/{username}`

**值**:
```json
{
  "tenantId": 1,
  "username": "default_ftp",
  "passwordHash": "$2a$10$...",
  "description": "默认FTP配置",
  "status": "active",
  "homeDirectory": "/tenants/1",
  "writePermission": true
}
```

**变更说明**:
- 从单 Key 数组改为每个 FTP 用户一个 Key
- 支持直接查询、删除单个 FTP 配置
- 符合 etcd 最佳实践

#### 2.2.4 域名配置

**主域名**: `jxt/tenants/{id}/domain/primary`
**别名列表**: `jxt/tenants/{id}/domain/aliases` (JSON array)
**内部域名**: `jxt/tenants/{id}/domain/internal`

#### 2.2.5 存储配置

**Key**: `jxt/tenants/{id}/storage`

**值**:
```json
{
  "tenantId": 1,
  "uploadQuotaGb": 1000,
  "maxFileSizeMb": 2048,
  "maxConcurrentUploads": 20
}
```

#### 2.2.6 索引配置

**Code索引**: `jxt/tenants/_index/by-code/{code}`
```json
{
  "id": 1,
  "code": "default",
  "name": "默认租户"
}
```

**Name索引**: `jxt/tenants/_index/by-name/{name}`
```json
{
  "id": 1,
  "code": "default",
  "primaryDomain": "example.com"
}
```

**FTP用户索引**: `jxt/tenants/_index/ftp-user/{username}`
```json
{
  "tenantId": 1,
  "code": "default",
  "name": "默认租户"
}
```

**Host索引**: `jxt/tenants/_index/host/{host}`
```json
{
  "tenantId": 1,
  "code": "default",
  "hostType": "frontend"
}
```

#### 2.2.7 公共配置

**识别器配置**: `jxt/common/resolver`
**存储目录配置**: `jxt/common/storage-directory`

## 3. 格式对照表

| 配置类型 | 旧格式 | 新格式 | 主要变更 |
|---------|-------|-------|---------|
| 服务数据库 | `jxt//jxt/config/tenants/{id}/services/{code}/database` | `jxt/tenants/{id}/database/{code}` | 消除双斜杠，简化层级 |
| 租户元数据 | `jxt//tenants/{id}/meta` | `jxt/tenants/{id}/meta` | 消除双斜杠 |
| 主域名 | `jxt//tenants/{id}/domain/primary` | `jxt/tenants/{id}/domain/primary` | 消除双斜杠 |
| 别名列表 | `jxt//tenants/{id}/domain/aliases` | `jxt/tenants/{id}/domain/aliases` | 消除双斜杠 |
| 内部域名 | `jxt//tenants/{id}/domain/internal` | `jxt/tenants/{id}/domain/internal` | 消除双斜杠 |
| FTP配置 | `jxt//tenants/{id}/ftp` (数组) | `jxt/tenants/{id}/ftp/{username}` | 改为多Key结构 |
| 存储配置 | `jxt//tenants/{id}/storage` | `jxt/tenants/{id}/storage` | 消除双斜杠 |
| Code索引 | `jxt//tenants/by-code/{code}` | `jxt/tenants/_index/by-code/{code}` | 统一索引前缀 |
| Name索引 | `jxt//tenants/by-name/{name}` | `jxt/tenants/_index/by-name/{name}` | 统一索引前缀 |
| FTP用户索引 | `jxt//ftp-users/{username}` | `jxt/tenants/_index/ftp-user/{username}` | 统一索引位置 |
| Host索引 | `jxt//hosts/{host}` | `jxt/tenants/_index/host/{host}` | 统一索引位置 |
| 识别器配置 | `jxt//common/resolver` | `jxt/common/resolver` | 消除双斜杠 |
| 存储目录配置 | `jxt//common/storage-directory` | `jxt/common/storage-directory` | 消除双斜杠 |
| 健康检查 | `jxt//_health/sentinel` | `jxt/_health/sentinel` | 消除双斜杠 |
| 平台配置 | `jxt//platform/configs/{key}` | `jxt/platform/configs/{key}` | 消除双斜杠 |

## 4. 核心变更说明

### 4.1 双斜杠消除

**修改点**: `etcd/client.go` 的 `buildKey` 方法

```go
// 修改前（会产生双斜杠）
func (c *Client) buildKey(key string) string {
    return fmt.Sprintf("%s%s", c.namespace, key)  // "jxt/" + "/jxt/..." = "jxt//jxt/..."
}

// 修改后
func (c *Client) buildKey(key string) string {
    // 确保 namespace 不以 / 结尾，key 以 / 开头
    ns := strings.TrimSuffix(c.namespace, "/")
    if !strings.HasPrefix(key, "/") {
        key = "/" + key
    }
    return fmt.Sprintf("%s%s", ns, key)
}
```

### 4.2 服务数据库配置简化

**修改点**: `etcd_publisher.go` 的 `PublishTenantServiceDatabaseConfig` 方法

```go
// 修改前
key := fmt.Sprintf("/jxt/config/tenants/%d/services/%s/database", tenantId, serviceCode)

// 修改后
key := fmt.Sprintf("/tenants/%d/database/%s", tenantId, serviceCode)
```

### 4.3 FTP配置改为多Key

**修改点**: `etcd_publisher_ext.go` 的 `PublishTenantFtpConfigs` 方法

```go
// 修改前：单个Key包含数组
key := fmt.Sprintf("/tenants/%d/ftp", tenantId)
data := map[string]interface{}{
    "ftpConfigs": [...]  // 数组
}

// 修改后：每个FTP用户一个Key
for _, cfg := range configs {
    key := fmt.Sprintf("/tenants/%d/ftp/%s", tenantId, cfg.Username)
    data := map[string]interface{}{
        "username": cfg.Username,
        // ...
    }
    p.client.Put(ctx, key, value)
}
```

### 4.4 索引统一组织

**修改点**: 索引发布方法

```go
// 修改前
key := fmt.Sprintf("/ftp-users/%s", username)

// 修改后
key := fmt.Sprintf("/tenants/_index/ftp-user/%s", username)
```

## 5. 命名规范

### 5.1 Key 命名规范

| 规则 | 说明 | 示例 |
|-----|------|------|
| 小写字母 | 所有 Key 使用小写 | `tenants` |
| kebab-case | 多词用连字符连接 | `by-code`, `ftp-user` |
| 复数形式 | 集合类型使用复数 | `tenants`, `configs` |
| 下划线前缀 | 特殊用途 | `_index`, `_health` |
| 花括号占位符 | 变量部分 | `{id}`, `{username}` |

### 5.2 JSON 字段命名规范

使用 camelCase（驼峰命名），与现有代码风格保持一致。

## 6. 数据结构示例

### 6.1 完整的租户配置示例

```
jxt/tenants/1/meta
jxt/tenants/1/domain/primary
jxt/tenants/1/domain/aliases
jxt/tenants/1/domain/internal
jxt/tenants/1/database/evidence-command
jxt/tenants/1/database/evidence-query
jxt/tenants/1/database/file-storage
jxt/tenants/1/ftp/default_ftp
jxt/tenants/1/ftp/sales_ftp
jxt/tenants/1/storage

jxt/tenants/_index/by-code/default
jxt/tenants/_index/by-name/默认租户
jxt/tenants/_index/ftp-user/default_ftp
jxt/tenants/_index/ftp-user/sales_ftp
jxt/tenants/_index/host/api.example.com
```

### 6.2 查询模式

```bash
# 查询租户所有配置
etcdctl get jxt/tenants/1/ --prefix

# 查询租户所有FTP配置
etcdctl get jxt/tenants/1/ftp/ --prefix

# 查询所有服务数据库配置
etcdctl get jxt/tenants/1/database/ --prefix

# 查询所有索引
etcdctl get jxt/tenants/_index/ --prefix
```

---

## 7. 边界情况处理

### 7.1 FTP 配置删除

#### 场景：删除租户的最后一个 FTP 配置

**问题**：当删除租户的最后一个 FTP 配置时，是否保留空的 `/tenants/{id}/ftp/` 前缀？

**解决方案**：
- **选项 A（推荐）**：不保留空前缀
  - etcd 没有"目录"概念，空前缀不会占用空间
  - `get /tenants/{id}/ftp/ --prefix` 返回空列表是正常行为
  - 保持逻辑简单

- **选项 B**：保留占位 Key
  - 创建 `/tenants/{id}/ftp/_empty` 作为占位符
  - 增加复杂度，不推荐

**实施建议**：采用选项 A，直接删除最后一个 FTP Key，不保留占位符。

```go
// 删除 FTP 配置时，直接删除对应的 Key
func DeleteFtpConfig(ctx context.Context, tenantId int, username string) error {
    key := fmt.Sprintf("/tenants/%d/ftp/%s", tenantId, username)
    return p.client.Delete(ctx, key)
    // 不需要检查是否是最后一个配置
}
```

---

### 7.2 索引删除顺序

#### 场景：删除租户时，索引的删除顺序

**问题**：删除租户时，如果先删除租户元数据，索引就找不到租户信息了。

**解决方案**：按以下顺序删除索引

```
1. 删除 FTP 用户索引
   └─ 依赖：需要知道 username
2. 删除 Host 索引
   └─ 依赖：需要从域名配置中获取 host 列表
3. 删除 Code 索引
   └─ 依赖：需要 tenant.code
4. 删除 Name 索引
   └─ 依赖：需要 tenant.code
5. 删除租户数据（最后）
   ├─ meta
   ├─ domain/*
   ├─ database/*
   ├─ ftp/*
   └─ storage
```

**代码示例**：
```go
func (p *EtcdPublisher) DeleteTenant(ctx context.Context, tenantId int) error {
    // 1. 先获取租户信息（用于删除索引）
    tenant, err := p.getTenantForDelete(ctx, tenantId)
    if err != nil {
        return err
    }

    // 2. 按顺序删除索引
    p.deleteFtpUserIndexes(ctx, tenant)   // 先删除 FTP 索引
    p.deleteHostIndexes(ctx, tenant)      // 再删除 Host 索引
    p.deleteTenantIndexes(ctx, tenant)    // 最后删除 Code/Name 索引

    // 3. 删除租户所有数据
    prefix := fmt.Sprintf("/tenants/%d", tenantId)
    return p.client.DeleteWithPrefix(ctx, prefix)
}
```

---

### 7.3 特殊字符处理

#### 场景：租户名称或 FTP 用户名包含特殊字符

**问题**：etcd Key 不支持某些特殊字符。

**解决方案**：
- **租户 Code**：只允许字母、数字、下划线（在创建时验证）
- **FTP 用户名**：只允许字母、数字、下划线、点号、连字符（在创建时验证）
- **索引 Key 中的特殊值**：使用 URL 编码或 Base64 编码

```go
// FTP 用户名验证
func isValidFtpUsername(username string) bool {
    matched, _ := regexp.MatchString(`^[a-zA-Z0-9._-]+$`, username)
    return matched
}

// 索引 Key 中的特殊字符处理
func encodeIndexKey(value string) string {
    // 使用 URL 编码处理特殊字符
    return url.PathEscape(value)
}
```

---

### 7.4 数据库配置不存在

#### 场景：查询服务的数据库配置，但该服务未配置

**问题**：某服务未配置数据库时，`GetByService` 应返回什么？

**解决方案**：
- **返回 `(nil, false)`**，表示配置不存在
- 调用方需要判断 `false` 情况

```go
// Provider 层
func (p *Provider) GetServiceDatabaseConfig(tenantID int, serviceCode string) (*ServiceDatabaseConfig, bool) {
    data := p.data.Load().(*tenantData)
    if data.Databases[tenantID] == nil {
        return nil, false  // 租户没有任何数据库配置
    }
    config, ok := data.Databases[tenantID][serviceCode]
    return config, ok  // 服务未配置时返回 false
}

// Cache 层
func (c *Cache) GetByService(ctx context.Context, tenantID int, serviceCode string) (*TenantDatabaseConfig, error) {
    cfg, ok := c.provider.GetServiceDatabaseConfig(tenantID, serviceCode)
    if !ok {
        return nil, fmt.Errorf("database config not found for tenant %d, service %s", tenantID, serviceCode)
    }
    return cfg, nil
}
```

---

### 7.5 FTP 用户名冲突

#### 场景：不同租户使用相同的 FTP 用户名

**问题**：FTP 用户名必须全局唯一，但创建时可能冲突。

**解决方案**：
1. **在 tenant-service 层面**：通过数据库唯一约束保证
2. **在 jxt-core Provider 层面**：通过索引覆盖检测

```go
// 检查 FTP 用户名是否已存在
func (p *Provider) IsFtpUsernameTaken(username string) bool {
    data := p.data.Load().(*tenantData)
    _, exists := data.FtpUsers[username]
    return exists
}

// 创建 FTP 配置前检查
func (s *service) CreateFtpConfig(ctx context.Context, req *CreateFtpConfigReq) error {
    // 检查用户名是否已存在
    if s.provider.IsFtpUsernameTaken(req.Username) {
        return errors.New("FTP username already exists globally")
    }
    // ... 创建逻辑
}
```

---

### 7.6 域名配置为空

#### 场景：租户未配置域名

**问题**：未配置域名时，Name 索引的 `primaryDomain` 字段如何处理？

**解决方案**：
- 使用空字符串 `""` 或租户 code 作为回退值

```go
func (p *EtcdPublisher) PublishTenantNameIndex(ctx context.Context, tenantId int, tenantCode string, primaryDomain string) error {
    key := fmt.Sprintf("/tenants/_index/by-name/%s", tenantCode)

    // 如果未配置主域名，使用空字符串
    if primaryDomain == "" {
        primaryDomain = ""
    }

    data := map[string]interface{}{
        "id":            tenantId,
        "code":          tenantCode,
        "primaryDomain": primaryDomain,
    }
    // ...
}
```

---

### 7.7 Watch 事件丢失

#### 场景：etcd Watch 因为网络问题丢失事件

**问题**：Watch 断开重连后，可能错过某些变更事件。

**解决方案**：
- **租户数据**：使用 `revision` 机制，从断点继续
- **索引数据**：定期全量刷新（兜底）

```go
// 使用 WithRev() 从指定版本开始 Watch
watchChan := client.Watch(ctx, prefix, clientv3.WithPrefix(), clientv3.WithRev(revision))

// 定期全量刷新兜底（如每小时）
go func() {
    ticker := time.NewTicker(1 * time.Hour)
    defer ticker.Stop()
    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            p.LoadAll(ctx)  // 全量刷新
        }
    }
}()
```

---

### 7.8 并发修改冲突

#### 场景：同时修改同一个租户的配置

**问题**：多个 goroutine 同时修改可能导致数据不一致。

**解决方案**：
- **Provider 层**：使用 `atomic.Value` 保证读操作的原子性
- **Publisher 层**：使用 `sync.Mutex` 保护写操作

```go
type Provider struct {
    data atomic.Value // *tenantData - 读操作无锁
    mu   sync.RWMutex // 写操作保护
}

// 更新数据时
func (p *Provider) handleEtcdEvent(event *clientv3.Event) {
    newData := p.data.Load().(*tenantData).copyData()  // 复制
    // 修改 newData
    p.data.Store(newData)  // 原子存储
}
```
