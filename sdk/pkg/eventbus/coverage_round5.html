
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>eventbus: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ChenBigdata421/jxt-core/sdk/pkg/eventbus/backlog_detector.go (31.5%)</option>
				
				<option value="file1">github.com/ChenBigdata421/jxt-core/sdk/pkg/eventbus/envelope.go (100.0%)</option>
				
				<option value="file2">github.com/ChenBigdata421/jxt-core/sdk/pkg/eventbus/eventbus.go (75.6%)</option>
				
				<option value="file3">github.com/ChenBigdata421/jxt-core/sdk/pkg/eventbus/factory.go (73.5%)</option>
				
				<option value="file4">github.com/ChenBigdata421/jxt-core/sdk/pkg/eventbus/health_check_message.go (87.7%)</option>
				
				<option value="file5">github.com/ChenBigdata421/jxt-core/sdk/pkg/eventbus/health_check_subscriber.go (91.1%)</option>
				
				<option value="file6">github.com/ChenBigdata421/jxt-core/sdk/pkg/eventbus/health_checker.go (92.2%)</option>
				
				<option value="file7">github.com/ChenBigdata421/jxt-core/sdk/pkg/eventbus/init.go (97.5%)</option>
				
				<option value="file8">github.com/ChenBigdata421/jxt-core/sdk/pkg/eventbus/json_config.go (100.0%)</option>
				
				<option value="file9">github.com/ChenBigdata421/jxt-core/sdk/pkg/eventbus/kafka.go (16.2%)</option>
				
				<option value="file10">github.com/ChenBigdata421/jxt-core/sdk/pkg/eventbus/keyed_worker_pool.go (100.0%)</option>
				
				<option value="file11">github.com/ChenBigdata421/jxt-core/sdk/pkg/eventbus/memory.go (86.2%)</option>
				
				<option value="file12">github.com/ChenBigdata421/jxt-core/sdk/pkg/eventbus/message_formatter.go (93.0%)</option>
				
				<option value="file13">github.com/ChenBigdata421/jxt-core/sdk/pkg/eventbus/nats.go (20.6%)</option>
				
				<option value="file14">github.com/ChenBigdata421/jxt-core/sdk/pkg/eventbus/nats_backlog_detector.go (5.4%)</option>
				
				<option value="file15">github.com/ChenBigdata421/jxt-core/sdk/pkg/eventbus/nats_metrics.go (0.0%)</option>
				
				<option value="file16">github.com/ChenBigdata421/jxt-core/sdk/pkg/eventbus/publisher_backlog_detector.go (98.1%)</option>
				
				<option value="file17">github.com/ChenBigdata421/jxt-core/sdk/pkg/eventbus/rate_limiter.go (73.4%)</option>
				
				<option value="file18">github.com/ChenBigdata421/jxt-core/sdk/pkg/eventbus/topic_config_manager.go (79.5%)</option>
				
				<option value="file19">github.com/ChenBigdata421/jxt-core/sdk/pkg/eventbus/type.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package eventbus

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/ChenBigdata421/jxt-core/sdk/pkg/logger"
        "github.com/IBM/sarama"
        "go.uber.org/zap"
)

// partitionLag 分区积压信息
type partitionLag struct {
        topic     string
        partition int32
        lag       int64
        timestamp time.Time
}

// BacklogDetector 消息积压检测器
// 比evidence-management更优雅的实现，复用EventBus的连接
type BacklogDetector struct {
        client           sarama.Client
        admin            sarama.ClusterAdmin
        consumerGroup    string
        maxLagThreshold  int64
        maxTimeThreshold time.Duration
        checkInterval    time.Duration
        lastCheckTime    time.Time
        lastCheckResult  bool
        mu               sync.RWMutex
        logger           *zap.Logger

        // 新增字段支持回调和生命周期管理
        callbacks  []BacklogStateCallback
        callbackMu sync.RWMutex
        ctx        context.Context
        cancel     context.CancelFunc
        wg         sync.WaitGroup
        isRunning  bool
        ticker     *time.Ticker
}

// NewBacklogDetector 创建积压检测器
func NewBacklogDetector(client sarama.Client, admin sarama.ClusterAdmin, consumerGroup string, config BacklogDetectionConfig) *BacklogDetector <span class="cov7" title="7">{
        return &amp;BacklogDetector{
                client:           client,
                admin:            admin,
                consumerGroup:    consumerGroup,
                maxLagThreshold:  config.MaxLagThreshold,
                maxTimeThreshold: config.MaxTimeThreshold,
                checkInterval:    config.CheckInterval,
                logger:           logger.Logger,
        }
}</span>

// BacklogDetectionConfig 积压检测配置
type BacklogDetectionConfig struct {
        MaxLagThreshold  int64         // 最大消息积压数量
        MaxTimeThreshold time.Duration // 最大积压时间
        CheckInterval    time.Duration // 检测间隔
}

// IsNoBacklog 检测是否无积压
// 实现比evidence-management更高效的检测逻辑
func (bd *BacklogDetector) IsNoBacklog(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        bd.mu.Lock()
        defer bd.mu.Unlock()

        // 检查是否需要重新检测
        if time.Since(bd.lastCheckTime) &lt; bd.checkInterval </span><span class="cov0" title="0">{
                return bd.lastCheckResult, nil
        }</span>

        // 获取消费者组的偏移量信息
        <span class="cov0" title="0">groupOffsets, err := bd.admin.ListConsumerGroupOffsets(bd.consumerGroup, nil)
        if err != nil </span><span class="cov0" title="0">{
                bd.logger.Error("Failed to get consumer group offsets", zap.Error(err), zap.String("group", bd.consumerGroup))
                return false, fmt.Errorf("failed to get consumer group offsets: %w", err)
        }</span>

        // 获取所有topic的最新偏移量
        <span class="cov0" title="0">topics := make(map[string][]int32)
        for topic, partitions := range groupOffsets.Blocks </span><span class="cov0" title="0">{
                var partitionList []int32
                for partition := range partitions </span><span class="cov0" title="0">{
                        partitionList = append(partitionList, partition)
                }</span>
                <span class="cov0" title="0">topics[topic] = partitionList</span>
        }

        // 并发检测所有topic的积压情况

        <span class="cov0" title="0">lagChan := make(chan partitionLag, len(topics)*10) // 预估容量
        errChan := make(chan error, len(topics))
        var wg sync.WaitGroup

        // 并发检测每个topic
        for topic, partitions := range topics </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(topic string, partitions []int32) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        if err := bd.checkTopicBacklog(ctx, topic, partitions, groupOffsets.Blocks[topic], lagChan); err != nil </span><span class="cov0" title="0">{
                                errChan &lt;- err
                        }</span>
                }(topic, partitions)
        }

        // 等待所有检测完成
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(lagChan)
                close(errChan)
        }</span>()

        // 收集结果
        <span class="cov0" title="0">var totalLag int64
        var maxLagTime time.Time
        hasBacklog := false

        for lag := range lagChan </span><span class="cov0" title="0">{
                totalLag += lag.lag
                if lag.lag &gt; bd.maxLagThreshold </span><span class="cov0" title="0">{
                        hasBacklog = true
                }</span>
                <span class="cov0" title="0">if lag.timestamp.After(maxLagTime) </span><span class="cov0" title="0">{
                        maxLagTime = lag.timestamp
                }</span>
        }

        // 检查是否有错误
        <span class="cov0" title="0">select </span>{
        case err := &lt;-errChan:<span class="cov0" title="0">
                if err != nil </span><span class="cov0" title="0">{
                        bd.logger.Error("Error during backlog detection", zap.Error(err))
                        return false, err
                }</span>
        default:<span class="cov0" title="0"></span>
        }

        // 检查时间维度的积压
        <span class="cov0" title="0">if !maxLagTime.IsZero() &amp;&amp; time.Since(maxLagTime) &gt; bd.maxTimeThreshold </span><span class="cov0" title="0">{
                hasBacklog = true
        }</span>

        // 更新检测结果
        <span class="cov0" title="0">bd.lastCheckTime = time.Now()
        bd.lastCheckResult = !hasBacklog

        if hasBacklog </span><span class="cov0" title="0">{
                bd.logger.Warn("Message backlog detected",
                        zap.Int64("totalLag", totalLag),
                        zap.Time("maxLagTime", maxLagTime),
                        zap.String("consumerGroup", bd.consumerGroup))
        }</span> else<span class="cov0" title="0"> {
                bd.logger.Debug("No message backlog detected",
                        zap.Int64("totalLag", totalLag),
                        zap.String("consumerGroup", bd.consumerGroup))
        }</span>

        <span class="cov0" title="0">return !hasBacklog, nil</span>
}

// checkTopicBacklog 检测单个topic的积压情况
func (bd *BacklogDetector) checkTopicBacklog(ctx context.Context, topic string, partitions []int32, groupPartitions map[int32]*sarama.OffsetFetchResponseBlock, lagChan chan&lt;- partitionLag) error <span class="cov0" title="0">{
        // 暂时忽略 ctx 参数，未来可用于取消操作
        _ = ctx

        // 获取topic的最新偏移量（这里只是为了验证topic存在）
        _, err := bd.client.GetOffset(topic, partitions[0], sarama.OffsetNewest)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get latest offset for topic %s: %w", topic, err)
        }</span>

        // 检测每个分区的积压
        <span class="cov0" title="0">for _, partition := range partitions </span><span class="cov0" title="0">{
                groupPartition, exists := groupPartitions[partition]
                if !exists </span><span class="cov0" title="0">{
                        continue</span>
                }

                // 获取分区的最新偏移量
                <span class="cov0" title="0">partitionLatestOffset, err := bd.client.GetOffset(topic, partition, sarama.OffsetNewest)
                if err != nil </span><span class="cov0" title="0">{
                        bd.logger.Error("Failed to get partition latest offset",
                                zap.String("topic", topic), zap.Int32("partition", partition), zap.Error(err))
                        continue</span>
                }

                // 计算积压
                <span class="cov0" title="0">lag := partitionLatestOffset - groupPartition.Offset
                if lag &lt; 0 </span><span class="cov0" title="0">{
                        lag = 0 // 避免负数
                }</span>

                // 获取消费时间戳（如果可用）
                <span class="cov0" title="0">timestamp := time.Now() // sarama.OffsetFetchResponseBlock 没有时间戳字段

                lagChan &lt;- partitionLag{
                        topic:     topic,
                        partition: partition,
                        lag:       lag,
                        timestamp: timestamp,
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetBacklogInfo 获取详细的积压信息
func (bd *BacklogDetector) GetBacklogInfo(ctx context.Context) (*BacklogInfo, error) <span class="cov0" title="0">{
        bd.mu.RLock()
        defer bd.mu.RUnlock()

        groupOffsets, err := bd.admin.ListConsumerGroupOffsets(bd.consumerGroup, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get consumer group offsets: %w", err)
        }</span>

        <span class="cov0" title="0">info := &amp;BacklogInfo{
                ConsumerGroup: bd.consumerGroup,
                CheckTime:     time.Now(),
                Topics:        make(map[string]*TopicBacklogInfo),
        }

        for topic, partitions := range groupOffsets.Blocks </span><span class="cov0" title="0">{
                topicInfo := &amp;TopicBacklogInfo{
                        Topic:      topic,
                        Partitions: make(map[int32]*PartitionBacklogInfo),
                }

                for partition, groupPartition := range partitions </span><span class="cov0" title="0">{
                        latestOffset, err := bd.client.GetOffset(topic, partition, sarama.OffsetNewest)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">lag := latestOffset - groupPartition.Offset
                        if lag &lt; 0 </span><span class="cov0" title="0">{
                                lag = 0
                        }</span>

                        <span class="cov0" title="0">topicInfo.Partitions[partition] = &amp;PartitionBacklogInfo{
                                Partition:      partition,
                                ConsumerOffset: groupPartition.Offset,
                                LatestOffset:   latestOffset,
                                Lag:            lag,
                                Timestamp:      time.Now(), // sarama.OffsetFetchResponseBlock 没有时间戳字段
                        }

                        topicInfo.TotalLag += lag</span>
                }

                <span class="cov0" title="0">info.Topics[topic] = topicInfo
                info.TotalLag += topicInfo.TotalLag</span>
        }

        <span class="cov0" title="0">return info, nil</span>
}

// BacklogInfo 积压信息
type BacklogInfo struct {
        ConsumerGroup string                       `json:"consumerGroup"`
        CheckTime     time.Time                    `json:"checkTime"`
        TotalLag      int64                        `json:"totalLag"`
        Topics        map[string]*TopicBacklogInfo `json:"topics"`
}

// TopicBacklogInfo topic积压信息
type TopicBacklogInfo struct {
        Topic      string                          `json:"topic"`
        TotalLag   int64                           `json:"totalLag"`
        Partitions map[int32]*PartitionBacklogInfo `json:"partitions"`
}

// PartitionBacklogInfo 分区积压信息
type PartitionBacklogInfo struct {
        Partition      int32     `json:"partition"`
        ConsumerOffset int64     `json:"consumerOffset"`
        LatestOffset   int64     `json:"latestOffset"`
        Lag            int64     `json:"lag"`
        Timestamp      time.Time `json:"timestamp"`
}

// RegisterCallback 注册积压状态回调
func (bd *BacklogDetector) RegisterCallback(callback BacklogStateCallback) error <span class="cov10" title="17">{
        bd.callbackMu.Lock()
        defer bd.callbackMu.Unlock()
        bd.callbacks = append(bd.callbacks, callback)
        return nil
}</span>

// Start 启动积压检测器
func (bd *BacklogDetector) Start(ctx context.Context) error <span class="cov4" title="3">{
        bd.mu.Lock()
        defer bd.mu.Unlock()

        if bd.isRunning </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov3" title="2">bd.ctx, bd.cancel = context.WithCancel(ctx)
        bd.ticker = time.NewTicker(bd.checkInterval)
        bd.isRunning = true

        bd.wg.Add(1)
        go bd.monitoringLoop()

        bd.logger.Info("Backlog detector started",
                zap.String("consumerGroup", bd.consumerGroup),
                zap.Duration("checkInterval", bd.checkInterval))

        return nil</span>
}

// Stop 停止积压检测器
func (bd *BacklogDetector) Stop() error <span class="cov5" title="4">{
        bd.mu.Lock()
        defer bd.mu.Unlock()

        if !bd.isRunning </span><span class="cov3" title="2">{
                return nil
        }</span>

        <span class="cov3" title="2">bd.isRunning = false
        if bd.cancel != nil </span><span class="cov3" title="2">{
                bd.cancel()
        }</span>
        <span class="cov3" title="2">if bd.ticker != nil </span><span class="cov3" title="2">{
                bd.ticker.Stop()
        }</span>

        <span class="cov3" title="2">bd.wg.Wait()

        bd.logger.Info("Backlog detector stopped")
        return nil</span>
}

// monitoringLoop 监控循环
func (bd *BacklogDetector) monitoringLoop() <span class="cov3" title="2">{
        defer bd.wg.Done()

        for </span><span class="cov3" title="2">{
                select </span>{
                case &lt;-bd.ticker.C:<span class="cov0" title="0">
                        bd.performBacklogCheck()</span>
                case &lt;-bd.ctx.Done():<span class="cov3" title="2">
                        return</span>
                }
        }
}

// performBacklogCheck 执行积压检查
func (bd *BacklogDetector) performBacklogCheck() <span class="cov0" title="0">{
        hasBacklog, err := bd.IsNoBacklog(bd.ctx)
        if err != nil </span><span class="cov0" title="0">{
                bd.logger.Error("Backlog check failed", zap.Error(err))
                return
        }</span>

        // 获取详细积压信息
        <span class="cov0" title="0">backlogInfo, err := bd.GetBacklogInfo(bd.ctx)
        if err != nil </span><span class="cov0" title="0">{
                bd.logger.Error("Failed to get backlog info", zap.Error(err))
                return
        }</span>

        // 构造状态
        <span class="cov0" title="0">state := BacklogState{
                HasBacklog:    !hasBacklog,
                ConsumerGroup: bd.consumerGroup,
                LagCount:      backlogInfo.TotalLag,
                Timestamp:     time.Now(),
        }

        // 计算最大积压时间（简化实现）
        if state.HasBacklog </span><span class="cov0" title="0">{
                state.LagTime = time.Since(bd.lastCheckTime)
        }</span>

        // 通知回调
        <span class="cov0" title="0">bd.notifyCallbacks(state)</span>
}

// notifyCallbacks 通知回调
func (bd *BacklogDetector) notifyCallbacks(state BacklogState) <span class="cov3" title="2">{
        bd.callbackMu.RLock()
        callbacks := make([]BacklogStateCallback, len(bd.callbacks))
        copy(callbacks, bd.callbacks)
        bd.callbackMu.RUnlock()

        // 从当前 context 派生，而不是使用 Background
        // 如果 ctx 为 nil，则使用 Background 作为后备
        bd.mu.RLock()
        parentCtx := bd.ctx
        bd.mu.RUnlock()
        if parentCtx == nil </span><span class="cov3" title="2">{
                parentCtx = context.Background()
        }</span>

        <span class="cov3" title="2">for _, callback := range callbacks </span><span class="cov5" title="4">{
                go func(cb BacklogStateCallback) </span><span class="cov5" title="4">{
                        // 使用父 context 派生，支持取消传播
                        ctx, cancel := context.WithTimeout(parentCtx, 10*time.Second)
                        defer cancel()

                        if err := cb(ctx, state); err != nil </span><span class="cov0" title="0">{
                                bd.logger.Error("Backlog callback failed",
                                        zap.Error(err),
                                        zap.Bool("hasBacklog", state.HasBacklog))
                        }</span>
                }(callback)
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package eventbus

import (
        "context"
        "errors"
        "fmt"
        "strings"
        "time"
)

// Envelope 统一消息包络结构（方案A）
type Envelope struct {
        AggregateID   string     `json:"aggregate_id"`             // 聚合ID（必填）
        EventType     string     `json:"event_type"`               // 事件类型（必填）
        EventVersion  int64      `json:"event_version"`            // 事件版本（预留，为了将来可能实现事件溯源预留）
        Timestamp     time.Time  `json:"timestamp"`                // 时间戳
        TraceID       string     `json:"trace_id,omitempty"`       // 链路追踪ID（可选）
        CorrelationID string     `json:"correlation_id,omitempty"` // 关联ID（可选）
        Payload       RawMessage `json:"payload"`                  // 业务负载
}

// NewEnvelope 创建新的消息包络
func NewEnvelope(aggregateID, eventType string, eventVersion int64, payload []byte) *Envelope <span class="cov3" title="9">{
        return &amp;Envelope{
                AggregateID:  aggregateID,
                EventType:    eventType,
                EventVersion: eventVersion,
                Timestamp:    time.Now(),
                Payload:      RawMessage(payload),
        }
}</span>

// Validate 校验包络字段
func (e *Envelope) Validate() error <span class="cov5" title="34">{
        if strings.TrimSpace(e.AggregateID) == "" </span><span class="cov3" title="8">{
                return errors.New("aggregate_id is required")
        }</span>
        <span class="cov5" title="26">if strings.TrimSpace(e.EventType) == "" </span><span class="cov1" title="2">{
                return errors.New("event_type is required")
        }</span>
        <span class="cov4" title="24">if e.EventVersion &lt;= 0 </span><span class="cov1" title="2">{
                return errors.New("event_version must be positive")
        }</span>
        <span class="cov4" title="22">if len(e.Payload) == 0 </span><span class="cov1" title="1">{
                return errors.New("payload is required")
        }</span>

        // 校验 aggregateID 格式
        <span class="cov4" title="21">if err := validateAggregateID(e.AggregateID); err != nil </span><span class="cov1" title="2">{
                return fmt.Errorf("invalid aggregate_id: %w", err)
        }</span>

        <span class="cov4" title="19">return nil</span>
}

// ToBytes 序列化为字节数组
func (e *Envelope) ToBytes() ([]byte, error) <span class="cov3" title="8">{
        if err := e.Validate(); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov3" title="7">return Marshal(e)</span>
}

// FromBytes 从字节数组反序列化
func FromBytes(data []byte) (*Envelope, error) <span class="cov7" title="278">{
        var env Envelope
        if err := Unmarshal(data, &amp;env); err != nil </span><span class="cov7" title="262">{
                return nil, fmt.Errorf("failed to unmarshal envelope: %w", err)
        }</span>
        <span class="cov4" title="16">if err := env.Validate(); err != nil </span><span class="cov2" title="5">{
                return nil, fmt.Errorf("invalid envelope: %w", err)
        }</span>
        <span class="cov3" title="11">return &amp;env, nil</span>
}

// ExtractAggregateID 从消息中提取聚合ID（决定是否使用Keyed-Worker池的关键函数）
//
// 优先级：Envelope &gt; Header &gt; Kafka Key/NATS Subject
//
// 核心逻辑：
// - 如果能提取到聚合ID → 使用Keyed-Worker池进行顺序处理
// - 如果无法提取聚合ID → 直接并发处理，不使用Keyed-Worker池
//
// 这就是为什么：
// - SubscribeEnvelope 自动使用Keyed-Worker池（Envelope.AggregateID总是存在）
// - Subscribe 通常不使用Keyed-Worker池（原始消息通常无聚合ID）
//
// 参数说明：
// - msgBytes: 消息字节数据（优先尝试解析为Envelope）
// - headers: 消息头（兼容性支持）
// - kafkaKey: Kafka消息键（兼容性支持）
// - natsSubject: NATS主题（启发式提取）
//
// 返回值：
// - string: 聚合ID（空字符串表示无法提取）
// - error: 解析错误（通常忽略，回退到下一优先级）
func ExtractAggregateID(msgBytes []byte, headers map[string]string, kafkaKey []byte, natsSubject string) (string, error) <span class="cov7" title="268">{
        // 1. 优先从 Envelope 提取
        if len(msgBytes) &gt; 0 </span><span class="cov7" title="268">{
                env, err := FromBytes(msgBytes)
                if err == nil &amp;&amp; env.AggregateID != "" </span><span class="cov2" title="3">{
                        return env.AggregateID, nil
                }</span>
        }

        // 2. 从 Headers 提取（兼容方案B）
        <span class="cov7" title="265">if headers != nil </span><span class="cov7" title="159">{
                for _, key := range []string{"X-Aggregate-ID", "x-aggregate-id", "Aggregate-ID", "aggregate-id"} </span><span class="cov8" title="624">{
                        if value, exists := headers[key]; exists &amp;&amp; strings.TrimSpace(value) != "" </span><span class="cov3" title="7">{
                                if err := validateAggregateID(value); err == nil </span><span class="cov3" title="7">{
                                        return strings.TrimSpace(value), nil
                                }</span>
                        }
                }
        }

        // 3. 从 Kafka Key 提取
        <span class="cov7" title="258">if len(kafkaKey) &gt; 0 </span><span class="cov1" title="2">{
                keyStr := strings.TrimSpace(string(kafkaKey))
                if keyStr != "" </span><span class="cov1" title="2">{
                        if err := validateAggregateID(keyStr); err == nil </span><span class="cov1" title="2">{
                                return keyStr, nil
                        }</span>
                }
        }

        // 4. 从 NATS Subject 启发式提取（最后兜底）
        <span class="cov7" title="256">if natsSubject != "" </span><span class="cov6" title="105">{
                parts := strings.Split(natsSubject, ".")
                for i := len(parts) - 1; i &gt;= 0; i-- </span><span class="cov6" title="105">{
                        segment := strings.TrimSpace(parts[i])
                        if segment != "" </span><span class="cov6" title="105">{
                                if err := validateAggregateID(segment); err == nil </span><span class="cov6" title="105">{
                                        return segment, nil
                                }</span>
                        }
                }
        }

        <span class="cov7" title="151">return "", errors.New("aggregate_id not found in any source")</span>
}

// validateAggregateID 校验聚合ID格式
func validateAggregateID(id string) error <span class="cov7" title="166">{
        id = strings.TrimSpace(id)
        if id == "" </span><span class="cov2" title="4">{
                return errors.New("aggregate_id cannot be empty")
        }</span>
        <span class="cov7" title="162">if len(id) &gt; 256 </span><span class="cov2" title="3">{
                return errors.New("aggregate_id too long (max 256 characters)")
        }</span>

        // 允许的字符：A-Z a-z 0-9 : _ - . /
        <span class="cov7" title="159">for _, r := range id </span><span class="cov10" title="1505">{
                switch </span>{
                case r &gt;= 'a' &amp;&amp; r &lt;= 'z':<span class="cov9" title="1343"></span>
                case r &gt;= 'A' &amp;&amp; r &lt;= 'Z':<span class="cov1" title="2"></span>
                case r &gt;= '0' &amp;&amp; r &lt;= '9':<span class="cov6" title="101"></span>
                case r == ':' || r == '_' || r == '-' || r == '.' || r == '/':<span class="cov5" title="49"></span>
                default:<span class="cov3" title="10">
                        return fmt.Errorf("aggregate_id contains invalid character: %c", r)</span>
                }
        }

        <span class="cov7" title="149">return nil</span>
}

// EnvelopePublisher 支持Envelope的发布器接口
type EnvelopePublisher interface {
        // PublishEnvelope 发布Envelope消息
        PublishEnvelope(ctx context.Context, topic string, envelope *Envelope) error
}

// EnvelopeSubscriber 支持Envelope的订阅器接口
type EnvelopeSubscriber interface {
        // SubscribeEnvelope 订阅Envelope消息
        SubscribeEnvelope(ctx context.Context, topic string, handler EnvelopeHandler) error
}

// EnvelopeHandler Envelope消息处理器
type EnvelopeHandler func(ctx context.Context, envelope *Envelope) error

// EnvelopeEventBus 支持Envelope的EventBus接口
type EnvelopeEventBus interface {
        EventBus
        EnvelopePublisher
        EnvelopeSubscriber
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package eventbus

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/ChenBigdata421/jxt-core/sdk/config"
        "github.com/ChenBigdata421/jxt-core/sdk/pkg/logger"
)

// eventBusManager 事件总线管理器
// 实现 EventBus 和 EnvelopeEventBus 接口
type eventBusManager struct {
        config                *EventBusConfig
        publisher             Publisher
        subscriber            Subscriber
        metrics               *Metrics
        healthStatus          *HealthStatus
        businessHealthChecker BusinessHealthChecker
        reconnectCallback     func(ctx context.Context) error
        mu                    sync.RWMutex
        closed                bool

        // 健康检查控制
        healthCheckCancel context.CancelFunc
        healthCheckDone   chan struct{}

        // 健康检查订阅监控器（Memory实现）
        healthCheckSubscriber *HealthCheckSubscriber
        // 健康检查发布器（Memory实现）
        healthChecker *HealthChecker

        // 主题配置管理
        topicConfigs   map[string]TopicOptions
        topicConfigsMu sync.RWMutex

        // 待注册的健康检查告警回调（在订阅器启动前注册）
        pendingAlertCallbacks []HealthCheckAlertCallback
        callbackMu            sync.Mutex
}

// NewEventBus 创建新的事件总线实例
func NewEventBus(config *EventBusConfig) (EventBus, error) <span class="cov6" title="111">{
        if config == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("config cannot be nil")
        }</span>

        <span class="cov6" title="110">manager := &amp;eventBusManager{
                config: config,
                metrics: &amp;Metrics{
                        LastHealthCheck:   time.Now(),
                        HealthCheckStatus: "unknown",
                },
                healthStatus: &amp;HealthStatus{
                        Overall:   "initializing",
                        Timestamp: time.Now(),
                        Infrastructure: InfrastructureHealth{
                                EventBus: EventBusHealthMetrics{
                                        ConnectionStatus: "initializing",
                                },
                        },
                        Details: make(map[string]interface{}),
                },
                topicConfigs: make(map[string]TopicOptions),
        }

        // 根据配置类型创建具体实现
        switch config.Type </span>{
        case "kafka":<span class="cov0" title="0">
                return manager.initKafka()</span>
        case "nats":<span class="cov0" title="0">
                return manager.initNATS()</span>
        case "memory":<span class="cov6" title="109">
                return manager.initMemory()</span>
        default:<span class="cov1" title="1">
                return nil, fmt.Errorf("unsupported eventbus type: %s", config.Type)</span>
        }
}

// Publish 发布消息
func (m *eventBusManager) Publish(ctx context.Context, topic string, message []byte) error <span class="cov9" title="1112">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        if m.closed </span><span class="cov2" title="5">{
                return fmt.Errorf("eventbus is closed")
        }</span>

        <span class="cov9" title="1107">if m.publisher == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("publisher not initialized")
        }</span>

        // 更新指标
        <span class="cov9" title="1106">start := time.Now()
        err := m.publisher.Publish(ctx, topic, message)

        m.updateMetrics(err == nil, true, time.Since(start))

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to publish message", "topic", topic, "error", err)
                return fmt.Errorf("failed to publish message to topic %s: %w", topic, err)
        }</span>

        <span class="cov9" title="1106">logger.Debug("Message published successfully", "topic", topic, "size", len(message))
        return nil</span>
}

// Subscribe 订阅消息
func (m *eventBusManager) Subscribe(ctx context.Context, topic string, handler MessageHandler) error <span class="cov5" title="60">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        if m.closed </span><span class="cov1" title="2">{
                return fmt.Errorf("eventbus is closed")
        }</span>

        <span class="cov5" title="58">if m.subscriber == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("subscriber not initialized")
        }</span>

        // 包装处理器以更新指标
        <span class="cov5" title="57">wrappedHandler := func(ctx context.Context, message []byte) error </span><span class="cov9" title="986">{
                start := time.Now()
                err := handler(ctx, message)
                m.updateMetrics(err == nil, false, time.Since(start))

                if err != nil </span><span class="cov3" title="10">{
                        logger.Error("Message handler failed", "topic", topic, "error", err)
                }</span> else<span class="cov9" title="975"> {
                        logger.Debug("Message processed successfully", "topic", topic, "size", len(message))
                }</span>

                <span class="cov9" title="985">return err</span>
        }

        <span class="cov5" title="57">err := m.subscriber.Subscribe(ctx, topic, wrappedHandler)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to subscribe to topic", "topic", topic, "error", err)
                return fmt.Errorf("failed to subscribe to topic %s: %w", topic, err)
        }</span>

        <span class="cov5" title="57">logger.Info("Successfully subscribed to topic", "topic", topic)
        return nil</span>
}

// performHealthCheck 内部健康检查（不对外暴露）
func (m *eventBusManager) performHealthCheck(ctx context.Context) error <span class="cov1" title="2">{
        status, err := m.performFullHealthCheck(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov1" title="1">if status.Overall != "healthy" </span><span class="cov0" title="0">{
                return fmt.Errorf("health check failed: %s", status.Overall)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// performFullHealthCheck 执行完整的健康检查（内部方法）
func (m *eventBusManager) performFullHealthCheck(ctx context.Context) (*HealthStatus, error) <span class="cov3" title="6">{
        start := time.Now()
        m.mu.Lock()
        defer m.mu.Unlock()

        if m.closed </span><span class="cov1" title="2">{
                return &amp;HealthStatus{
                        Overall:   "unhealthy",
                        Timestamp: time.Now(),
                        Infrastructure: InfrastructureHealth{
                                EventBus: EventBusHealthMetrics{
                                        ConnectionStatus: "closed",
                                },
                        },
                        CheckDuration: time.Since(start),
                }, fmt.Errorf("eventbus is closed")
        }</span>

        // 更新健康检查时间
        <span class="cov2" title="4">m.metrics.LastHealthCheck = time.Now()

        // 执行基础设施健康检查
        infraHealth, err := m.checkInfrastructureHealth(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;HealthStatus{
                        Overall:        "unhealthy",
                        Infrastructure: infraHealth,
                        Timestamp:      time.Now(),
                        CheckDuration:  time.Since(start),
                        Details:        map[string]interface{}{"error": err.Error()},
                }, err
        }</span>

        // 执行业务健康检查（如果已注册）
        <span class="cov2" title="4">var businessHealth interface{}
        if m.businessHealthChecker != nil </span><span class="cov1" title="2">{
                if err := m.businessHealthChecker.CheckBusinessHealth(ctx); err != nil </span><span class="cov1" title="1">{
                        return &amp;HealthStatus{
                                Overall:        "unhealthy",
                                Infrastructure: infraHealth,
                                Business:       map[string]interface{}{"error": err.Error()},
                                Timestamp:      time.Now(),
                                CheckDuration:  time.Since(start),
                        }, err
                }</span>
                <span class="cov1" title="1">businessHealth = m.businessHealthChecker.GetBusinessMetrics()</span>
        }

        // 更新健康状态
        <span class="cov2" title="3">m.healthStatus = &amp;HealthStatus{
                Overall:        "healthy",
                Infrastructure: infraHealth,
                Business:       businessHealth,
                Timestamp:      time.Now(),
                CheckDuration:  time.Since(start),
        }

        m.metrics.HealthCheckStatus = "healthy"
        logger.Debug("Health check completed successfully")
        return m.healthStatus, nil</span>
}

// checkInfrastructureHealth 检查基础设施健康状态
func (m *eventBusManager) checkInfrastructureHealth(ctx context.Context) (InfrastructureHealth, error) <span class="cov2" title="5">{
        infraHealth := InfrastructureHealth{
                EventBus: EventBusHealthMetrics{
                        ConnectionStatus: "unknown",
                },
        }

        // 检查 EventBus 连接状态
        if err := m.checkConnection(ctx); err != nil </span><span class="cov0" title="0">{
                infraHealth.EventBus.ConnectionStatus = "disconnected"
                infraHealth.EventBus.LastFailureTime = time.Now()
                return infraHealth, fmt.Errorf("eventbus connection check failed: %w", err)
        }</span>

        // 检查消息传输能力
        <span class="cov2" title="5">if err := m.checkMessageTransport(ctx); err != nil </span><span class="cov0" title="0">{
                infraHealth.EventBus.ConnectionStatus = "connected"
                infraHealth.EventBus.LastFailureTime = time.Now()
                return infraHealth, fmt.Errorf("eventbus message transport check failed: %w", err)
        }</span>

        // 获取 EventBus 指标
        <span class="cov2" title="5">infraHealth.EventBus = m.getEventBusMetrics()
        infraHealth.EventBus.ConnectionStatus = "connected"
        infraHealth.EventBus.LastSuccessTime = time.Now()

        return infraHealth, nil</span>
}

// checkConnection 检查基础连接状态（内部方法）
func (m *eventBusManager) checkConnection(ctx context.Context) error <span class="cov3" title="7">{
        // 检查发布器连接
        if m.publisher != nil </span><span class="cov3" title="6">{
                if healthChecker, ok := m.publisher.(interface{ HealthCheck(context.Context) error }); ok </span><span class="cov0" title="0">{
                        if err := healthChecker.HealthCheck(ctx); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("publisher health check failed: %w", err)
                        }</span>
                }
        }

        // 检查订阅器连接
        <span class="cov3" title="7">if m.subscriber != nil </span><span class="cov3" title="6">{
                if healthChecker, ok := m.subscriber.(interface{ HealthCheck(context.Context) error }); ok </span><span class="cov0" title="0">{
                        if err := healthChecker.HealthCheck(ctx); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("subscriber health check failed: %w", err)
                        }</span>
                }
        }

        <span class="cov3" title="7">return nil</span>
}

// checkMessageTransport 检查端到端消息传输（内部方法）
func (m *eventBusManager) checkMessageTransport(ctx context.Context) error <span class="cov3" title="8">{
        if m.publisher == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("publisher not initialized")
        }</span>

        // 创建带超时的上下文
        <span class="cov3" title="7">ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
        defer cancel()

        // 生成唯一的健康检查消息
        healthMsg := fmt.Sprintf("health-check-%d", time.Now().UnixNano())
        testTopic := "health_check_topic"

        // 如果有订阅器，进行完整的端到端测试
        if m.subscriber != nil </span><span class="cov3" title="7">{
                return m.performEndToEndTest(ctx, testTopic, healthMsg)
        }</span>

        // 如果没有订阅器，只测试发布能力
        <span class="cov0" title="0">start := time.Now()
        if err := m.publisher.Publish(ctx, testTopic, []byte(healthMsg)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to publish health check message: %w", err)
        }</span>

        <span class="cov0" title="0">publishLatency := time.Since(start)
        logger.Debug("Health check message published successfully",
                "latency", publishLatency,
                "topic", testTopic)

        return nil</span>
}

// performEndToEndTest 执行完整的端到端测试
func (m *eventBusManager) performEndToEndTest(ctx context.Context, testTopic, healthMsg string) error <span class="cov3" title="9">{
        // 创建接收通道
        receiveChan := make(chan string, 1)
        errorChan := make(chan error, 1)

        // 设置临时订阅来接收健康检查消息
        handler := func(ctx context.Context, message []byte) error </span><span class="cov3" title="9">{
                receivedMsg := string(message)
                if receivedMsg == healthMsg </span><span class="cov3" title="9">{
                        select </span>{
                        case receiveChan &lt;- receivedMsg:<span class="cov3" title="9"></span>
                        default:<span class="cov0" title="0"></span>
                        }
                }
                <span class="cov3" title="9">return nil</span>
        }

        // 订阅健康检查主题
        <span class="cov3" title="9">if err := m.subscriber.Subscribe(ctx, testTopic, handler); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to subscribe to health check topic: %w", err)
        }</span>

        // 等待一小段时间确保订阅生效
        <span class="cov3" title="9">time.Sleep(100 * time.Millisecond)

        // 发布健康检查消息
        start := time.Now()
        if err := m.publisher.Publish(ctx, testTopic, []byte(healthMsg)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to publish health check message: %w", err)
        }</span>
        <span class="cov3" title="9">publishLatency := time.Since(start)

        // 等待接收消息或超时
        select </span>{
        case receivedMsg := &lt;-receiveChan:<span class="cov3" title="8">
                totalLatency := time.Since(start)
                logger.Debug("End-to-end health check successful",
                        "publishLatency", publishLatency,
                        "totalLatency", totalLatency,
                        "message", receivedMsg)
                return nil</span>

        case err := &lt;-errorChan:<span class="cov0" title="0">
                return fmt.Errorf("health check subscription error: %w", err)</span>

        case &lt;-ctx.Done():<span class="cov1" title="1">
                return fmt.Errorf("health check timeout: message not received within timeout period")</span>

        case &lt;-time.After(5 * time.Second):<span class="cov0" title="0">
                return fmt.Errorf("health check timeout: message not received within 5 seconds")</span>
        }
}

// getEventBusMetrics 获取 EventBus 性能指标（内部方法）
func (m *eventBusManager) getEventBusMetrics() EventBusHealthMetrics <span class="cov3" title="6">{
        return EventBusHealthMetrics{
                ConnectionStatus:    "connected",
                PublishLatency:      0, // TODO: 实际测量
                SubscribeLatency:    0, // TODO: 实际测量
                LastSuccessTime:     time.Now(),
                ConsecutiveFailures: 0,
                ThroughputPerSecond: 0, // TODO: 实际统计
                MessageBacklog:      m.metrics.MessageBacklog,
                ReconnectCount:      0, // TODO: 实际统计
                BrokerCount:         1, // TODO: 实际获取
                TopicCount:          1, // TODO: 实际获取
        }
}</span>

// RegisterBusinessHealthCheck 注册业务健康检查
func (m *eventBusManager) RegisterBusinessHealthCheck(checker BusinessHealthChecker) <span class="cov2" title="3">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.businessHealthChecker = checker
}</span>

// Close 关闭连接
func (m *eventBusManager) Close() error <span class="cov6" title="132">{
        m.mu.Lock()

        if m.closed </span><span class="cov1" title="1">{
                m.mu.Unlock()
                return nil
        }</span>

        // 先标记为已关闭，防止新的操作
        <span class="cov6" title="131">m.closed = true

        // 获取需要关闭的组件引用
        healthChecker := m.healthChecker
        healthCheckSubscriber := m.healthCheckSubscriber
        publisher := m.publisher
        subscriber := m.subscriber

        m.mu.Unlock()

        var errors []error

        // 1. 先停止健康检查（避免在EventBus关闭后继续发送消息）
        if healthChecker != nil </span><span class="cov2" title="3">{
                logger.Debug("Stopping health check publisher before closing EventBus")
                if err := healthChecker.Stop(); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("failed to stop health checker: %w", err))
                }</span>
        }

        <span class="cov6" title="131">if healthCheckSubscriber != nil </span><span class="cov3" title="6">{
                logger.Debug("Stopping health check subscriber before closing EventBus")
                if err := healthCheckSubscriber.Stop(); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("failed to stop health check subscriber: %w", err))
                }</span>
        }

        // 2. 关闭发布器
        <span class="cov6" title="131">if publisher != nil </span><span class="cov6" title="131">{
                if err := publisher.Close(); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("failed to close publisher: %w", err))
                }</span>
        }

        // 3. 关闭订阅器
        <span class="cov6" title="131">if subscriber != nil </span><span class="cov6" title="131">{
                if err := subscriber.Close(); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("failed to close subscriber: %w", err))
                }</span>
        }

        <span class="cov6" title="131">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("errors during close: %v", errors)
        }</span>

        <span class="cov6" title="131">logger.Info("EventBus closed successfully")
        return nil</span>
}

// RegisterReconnectCallback 注册重连回调
func (m *eventBusManager) RegisterReconnectCallback(callback ReconnectCallback) error <span class="cov1" title="2">{
        m.mu.Lock()
        defer m.mu.Unlock()

        // 将新的回调类型转换为旧的类型
        m.reconnectCallback = func(ctx context.Context) error </span><span class="cov0" title="0">{
                return callback(ctx)
        }</span>
        <span class="cov1" title="2">logger.Info("Reconnect callback registered")
        return nil</span>
}

// GetMetrics 获取指标
func (m *eventBusManager) GetMetrics() Metrics <span class="cov3" title="7">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return *m.metrics
}</span>

// GetHealthStatus 获取健康状态（已废弃，使用GetHealthCheckPublisherStatus）
func (m *eventBusManager) GetHealthStatus() HealthCheckStatus <span class="cov1" title="1">{
        logger.Warn("GetHealthStatus is deprecated, use GetHealthCheckPublisherStatus instead")
        return m.GetHealthCheckPublisherStatus()
}</span>

// updateMetrics 更新指标
func (m *eventBusManager) updateMetrics(success bool, isPublish bool, duration time.Duration) <span class="cov10" title="2095">{
        if isPublish </span><span class="cov9" title="1108">{
                if success </span><span class="cov9" title="1107">{
                        m.metrics.MessagesPublished++
                }</span> else<span class="cov1" title="1"> {
                        m.metrics.PublishErrors++
                }</span>
        } else<span class="cov9" title="987"> {
                if success </span><span class="cov9" title="976">{
                        m.metrics.MessagesConsumed++
                }</span> else<span class="cov3" title="11"> {
                        m.metrics.ConsumeErrors++
                }</span>
        }

        // 可以在这里记录处理时间相关的指标
        <span class="cov10" title="2095">_ = duration</span> // 暂时忽略，未来可用于性能指标
}

// initKafka 初始化Kafka事件总线
func (m *eventBusManager) initKafka() (EventBus, error) <span class="cov0" title="0">{
        // 创建简化的配置格式
        kafkaConfig := &amp;config.KafkaConfig{
                Brokers: m.config.Kafka.Brokers,
                Producer: config.ProducerConfig{
                        RequiredAcks:   m.config.Kafka.Producer.RequiredAcks,
                        Timeout:        m.config.Kafka.Producer.Timeout,
                        Compression:    m.config.Kafka.Producer.Compression,
                        FlushFrequency: m.config.Kafka.Producer.FlushFrequency,
                        FlushMessages:  m.config.Kafka.Producer.FlushMessages,
                        RetryMax:       m.config.Kafka.Producer.RetryMax,
                        BatchSize:      m.config.Kafka.Producer.BatchSize,
                        BufferSize:     m.config.Kafka.Producer.BufferSize,
                },
                Consumer: config.ConsumerConfig{
                        GroupID:           m.config.Kafka.Consumer.GroupID,
                        AutoOffsetReset:   m.config.Kafka.Consumer.AutoOffsetReset,
                        SessionTimeout:    m.config.Kafka.Consumer.SessionTimeout,
                        HeartbeatInterval: m.config.Kafka.Consumer.HeartbeatInterval,
                        MaxProcessingTime: m.config.Kafka.Consumer.MaxProcessingTime,
                        FetchMinBytes:     m.config.Kafka.Consumer.FetchMinBytes,
                        FetchMaxBytes:     m.config.Kafka.Consumer.FetchMaxBytes,
                        FetchMaxWait:      m.config.Kafka.Consumer.FetchMaxWait,
                },
        }

        return NewKafkaEventBusWithFullConfig(kafkaConfig, m.config)
}</span>

// initNATS 初始化NATS事件总线
func (m *eventBusManager) initNATS() (EventBus, error) <span class="cov0" title="0">{
        // 创建简化的配置格式
        natsConfig := &amp;config.NATSConfig{
                URLs:              m.config.NATS.URLs,
                ClientID:          m.config.NATS.ClientID,
                MaxReconnects:     m.config.NATS.MaxReconnects,
                ReconnectWait:     m.config.NATS.ReconnectWait,
                ConnectionTimeout: m.config.NATS.ConnectionTimeout,
                JetStream: config.JetStreamConfig{
                        Enabled:        m.config.NATS.JetStream.Enabled,
                        Domain:         m.config.NATS.JetStream.Domain,
                        APIPrefix:      m.config.NATS.JetStream.APIPrefix,
                        PublishTimeout: m.config.NATS.JetStream.PublishTimeout,
                        AckWait:        m.config.NATS.JetStream.AckWait,
                        MaxDeliver:     m.config.NATS.JetStream.MaxDeliver,
                        Stream: config.StreamConfig{
                                Name:      m.config.NATS.JetStream.Stream.Name,
                                Subjects:  m.config.NATS.JetStream.Stream.Subjects,
                                Retention: m.config.NATS.JetStream.Stream.Retention,
                                Storage:   m.config.NATS.JetStream.Stream.Storage,
                                Replicas:  m.config.NATS.JetStream.Stream.Replicas,
                                MaxAge:    m.config.NATS.JetStream.Stream.MaxAge,
                                MaxBytes:  m.config.NATS.JetStream.Stream.MaxBytes,
                                MaxMsgs:   m.config.NATS.JetStream.Stream.MaxMsgs,
                                Discard:   m.config.NATS.JetStream.Stream.Discard,
                        },
                        Consumer: config.NATSConsumerConfig{
                                DurableName:   m.config.NATS.JetStream.Consumer.DurableName,
                                DeliverPolicy: m.config.NATS.JetStream.Consumer.DeliverPolicy,
                                AckPolicy:     m.config.NATS.JetStream.Consumer.AckPolicy,
                                ReplayPolicy:  m.config.NATS.JetStream.Consumer.ReplayPolicy,
                        },
                },
                Security: config.NATSSecurityConfig{
                        Enabled:  m.config.NATS.Security.Enabled,
                        Username: m.config.NATS.Security.Username,
                        Password: m.config.NATS.Security.Password,
                        CertFile: m.config.NATS.Security.CertFile,
                        KeyFile:  m.config.NATS.Security.KeyFile,
                        CAFile:   m.config.NATS.Security.CAFile,
                },
        }

        return NewNATSEventBusWithFullConfig(natsConfig, m.config)
}</span>

// ========== 生命周期管理 ==========

// Start 启动事件总线
func (m *eventBusManager) Start(ctx context.Context) error <span class="cov1" title="2">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if m.closed </span><span class="cov1" title="1">{
                return fmt.Errorf("eventbus is closed")
        }</span>

        <span class="cov1" title="1">logger.Info("EventBus started successfully")
        return nil</span>
}

// Stop 停止事件总线
func (m *eventBusManager) Stop() error <span class="cov1" title="1">{
        return m.Close()
}</span>

// ========== 高级发布功能 ==========

// PublishWithOptions 使用选项发布消息
func (m *eventBusManager) PublishWithOptions(ctx context.Context, topic string, message []byte, opts PublishOptions) error <span class="cov1" title="1">{
        // 基础实现，直接调用 Publish
        // 高级功能可以在具体实现中扩展
        return m.Publish(ctx, topic, message)
}</span>

// SetMessageFormatter 设置消息格式化器
func (m *eventBusManager) SetMessageFormatter(formatter MessageFormatter) error <span class="cov1" title="1">{
        // eventBusManager 是基础实现，不支持消息格式化器
        // 具体的实现（如 kafkaEventBus, natsEventBus）会重写此方法
        logger.Debug("Message formatter set for eventbus manager (base implementation)")
        return nil
}</span>

// RegisterPublishCallback 注册发布回调
func (m *eventBusManager) RegisterPublishCallback(callback PublishCallback) error <span class="cov1" title="1">{
        logger.Debug("Publish callback registered for eventbus manager")
        return nil
}</span>

// ========== 高级订阅功能 ==========

// SubscribeWithOptions 使用选项订阅消息
func (m *eventBusManager) SubscribeWithOptions(ctx context.Context, topic string, handler MessageHandler, opts SubscribeOptions) error <span class="cov1" title="1">{
        // 基础实现，直接调用 Subscribe
        // 高级功能可以在具体实现中扩展
        return m.Subscribe(ctx, topic, handler)
}</span>

// RegisterSubscriberBacklogCallback 注册订阅端积压回调
func (m *eventBusManager) RegisterSubscriberBacklogCallback(callback BacklogStateCallback) error <span class="cov1" title="2">{
        logger.Info("Subscriber backlog callback registered for eventbus manager")
        return nil
}</span>

// StartSubscriberBacklogMonitoring 启动订阅端积压监控
func (m *eventBusManager) StartSubscriberBacklogMonitoring(ctx context.Context) error <span class="cov1" title="2">{
        logger.Info("Subscriber backlog monitoring started for eventbus manager")
        return nil
}</span>

// StopSubscriberBacklogMonitoring 停止订阅端积压监控
func (m *eventBusManager) StopSubscriberBacklogMonitoring() error <span class="cov1" title="2">{
        logger.Info("Subscriber backlog monitoring stopped for eventbus manager")
        return nil
}</span>

// RegisterBacklogCallback 注册订阅端积压回调（已废弃，向后兼容）
func (m *eventBusManager) RegisterBacklogCallback(callback BacklogStateCallback) error <span class="cov1" title="1">{
        logger.Warn("RegisterBacklogCallback is deprecated, use RegisterSubscriberBacklogCallback instead")
        return m.RegisterSubscriberBacklogCallback(callback)
}</span>

// StartBacklogMonitoring 启动订阅端积压监控（已废弃，向后兼容）
func (m *eventBusManager) StartBacklogMonitoring(ctx context.Context) error <span class="cov1" title="1">{
        logger.Warn("StartBacklogMonitoring is deprecated, use StartSubscriberBacklogMonitoring instead")
        return m.StartSubscriberBacklogMonitoring(ctx)
}</span>

// StopBacklogMonitoring 停止订阅端积压监控（已废弃，向后兼容）
func (m *eventBusManager) StopBacklogMonitoring() error <span class="cov1" title="1">{
        logger.Warn("StopBacklogMonitoring is deprecated, use StopSubscriberBacklogMonitoring instead")
        return m.StopSubscriberBacklogMonitoring()
}</span>

// RegisterPublisherBacklogCallback 注册发送端积压回调
func (m *eventBusManager) RegisterPublisherBacklogCallback(callback PublisherBacklogCallback) error <span class="cov1" title="1">{
        logger.Debug("Publisher backlog callback registered for eventbus manager")
        return nil
}</span>

// StartPublisherBacklogMonitoring 启动发送端积压监控
func (m *eventBusManager) StartPublisherBacklogMonitoring(ctx context.Context) error <span class="cov0" title="0">{
        logger.Debug("Publisher backlog monitoring started for eventbus manager (not available)")
        return nil
}</span>

// StopPublisherBacklogMonitoring 停止发送端积压监控
func (m *eventBusManager) StopPublisherBacklogMonitoring() error <span class="cov0" title="0">{
        logger.Debug("Publisher backlog monitoring stopped for eventbus manager (not available)")
        return nil
}</span>

// StartAllBacklogMonitoring 根据配置启动所有积压监控
func (m *eventBusManager) StartAllBacklogMonitoring(ctx context.Context) error <span class="cov0" title="0">{
        logger.Info("All backlog monitoring started for eventbus manager")
        return nil
}</span>

// StopAllBacklogMonitoring 停止所有积压监控
func (m *eventBusManager) StopAllBacklogMonitoring() error <span class="cov0" title="0">{
        logger.Info("All backlog monitoring stopped for eventbus manager")
        return nil
}</span>

// SetMessageRouter 设置消息路由器
func (m *eventBusManager) SetMessageRouter(router MessageRouter) error <span class="cov0" title="0">{
        logger.Debug("Message router set for eventbus manager")
        return nil
}</span>

// SetErrorHandler 设置错误处理器
func (m *eventBusManager) SetErrorHandler(handler ErrorHandler) error <span class="cov0" title="0">{
        logger.Info("Error handler set for eventbus manager")
        return nil
}</span>

// RegisterSubscriptionCallback 注册订阅回调
func (m *eventBusManager) RegisterSubscriptionCallback(callback SubscriptionCallback) error <span class="cov0" title="0">{
        logger.Info("Subscription callback registered for eventbus manager")
        return nil
}</span>

// ========== 统一健康检查和监控 ==========

// StartHealthCheck 启动健康检查
// StartHealthCheck 启动健康检查（已废弃，使用StartHealthCheckPublisher）
func (m *eventBusManager) StartHealthCheck(ctx context.Context) error <span class="cov0" title="0">{
        logger.Warn("StartHealthCheck is deprecated, use StartHealthCheckPublisher instead")
        return m.StartHealthCheckPublisher(ctx)
}</span>

// StopHealthCheck 停止健康检查（已废弃，使用StopHealthCheckPublisher）
func (m *eventBusManager) StopHealthCheck() error <span class="cov0" title="0">{
        logger.Warn("StopHealthCheck is deprecated, use StopHealthCheckPublisher instead")
        return m.StopHealthCheckPublisher()
}</span>

// RegisterHealthCheckCallback 注册健康检查回调（已废弃，使用RegisterHealthCheckPublisherCallback）
func (m *eventBusManager) RegisterHealthCheckCallback(callback HealthCheckCallback) error <span class="cov0" title="0">{
        logger.Warn("RegisterHealthCheckCallback is deprecated, use RegisterHealthCheckPublisherCallback instead")
        return m.RegisterHealthCheckPublisherCallback(callback)
}</span>

// StartHealthCheckSubscriber 启动健康检查消息订阅监控
func (m *eventBusManager) StartHealthCheckSubscriber(ctx context.Context) error <span class="cov4" title="16">{
        m.mu.Lock()
        if m.healthCheckSubscriber != nil </span><span class="cov0" title="0">{
                m.mu.Unlock()
                return nil // 已经启动
        }</span>

        // 创建健康检查订阅监控器（使用全局配置中的健康检查设置）
        <span class="cov4" title="16">globalCfg := GetGlobalConfig()
        var healthConfig config.HealthCheckConfig
        if globalCfg != nil &amp;&amp; globalCfg.HealthCheck.Enabled </span><span class="cov4" title="15">{
                healthConfig = globalCfg.HealthCheck
        }</span> else<span class="cov1" title="1"> {
                healthConfig = GetDefaultHealthCheckConfig()
        }</span>
        <span class="cov4" title="16">subscriber := NewHealthCheckSubscriber(healthConfig, m, "memory-eventbus", "memory")
        m.mu.Unlock()

        // 启动监控器（在锁外启动以避免死锁）
        if err := subscriber.Start(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start health check subscriber: %w", err)
        }</span>

        // 重新获取锁并设置订阅监控器
        <span class="cov4" title="16">m.mu.Lock()
        m.healthCheckSubscriber = subscriber
        m.mu.Unlock()

        // 应用待注册的回调
        m.callbackMu.Lock()
        pendingCallbacks := m.pendingAlertCallbacks
        m.pendingAlertCallbacks = nil
        m.callbackMu.Unlock()

        for _, callback := range pendingCallbacks </span><span class="cov1" title="2">{
                if err := subscriber.RegisterAlertCallback(callback); err != nil </span><span class="cov0" title="0">{
                        logger.Warn("Failed to register pending alert callback", "error", err)
                }</span> else<span class="cov1" title="2"> {
                        logger.Debug("Applied pending alert callback after subscriber started")
                }</span>
        }

        <span class="cov4" title="16">logger.Info("Health check subscriber started for memory eventbus")
        return nil</span>
}

// StopHealthCheckSubscriber 停止健康检查消息订阅监控
func (m *eventBusManager) StopHealthCheckSubscriber() error <span class="cov3" title="10">{
        // 先获取 healthCheckSubscriber 的引用，避免在持有锁时调用 Stop()
        m.mu.Lock()
        subscriber := m.healthCheckSubscriber
        if subscriber == nil </span><span class="cov0" title="0">{
                m.mu.Unlock()
                return nil
        }</span>
        <span class="cov3" title="10">m.healthCheckSubscriber = nil
        m.mu.Unlock()

        // 在锁外调用 Stop()，避免死锁
        if err := subscriber.Stop(); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to stop health check subscriber", "error", err)
                return err
        }</span>

        <span class="cov3" title="10">logger.Info("Health check subscriber stopped for memory eventbus")
        return nil</span>
}

// RegisterHealthCheckAlertCallback 注册健康检查告警回调
// 支持在订阅器启动前注册，回调会在启动时自动应用
func (m *eventBusManager) RegisterHealthCheckAlertCallback(callback HealthCheckAlertCallback) error <span class="cov3" title="6">{
        m.callbackMu.Lock()
        defer m.callbackMu.Unlock()

        // 如果订阅器已启动，直接注册
        m.mu.RLock()
        subscriber := m.healthCheckSubscriber
        m.mu.RUnlock()

        if subscriber != nil </span><span class="cov2" title="3">{
                return subscriber.RegisterAlertCallback(callback)
        }</span>

        // 否则，保存到待注册列表
        <span class="cov2" title="3">m.pendingAlertCallbacks = append(m.pendingAlertCallbacks, callback)
        logger.Debug("Health check alert callback queued for registration after subscriber starts")
        return nil</span>
}

// GetHealthCheckSubscriberStats 获取健康检查订阅监控统计信息
func (m *eventBusManager) GetHealthCheckSubscriberStats() HealthCheckSubscriberStats <span class="cov4" title="19">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        if m.healthCheckSubscriber == nil </span><span class="cov0" title="0">{
                return HealthCheckSubscriberStats{
                        StartTime: time.Now(),
                        IsHealthy: true,
                }
        }</span>

        <span class="cov4" title="19">return m.healthCheckSubscriber.GetStats()</span>
}

// ========== 新的分离式健康检查接口实现 ==========

// StartHealthCheckPublisher 启动健康检查发布器
func (m *eventBusManager) StartHealthCheckPublisher(ctx context.Context) error <span class="cov4" title="17">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if m.healthChecker != nil </span><span class="cov1" title="1">{
                return nil // 已经启动
        }</span>

        // 创建健康检查发布器（使用全局配置中的健康检查设置）
        <span class="cov4" title="16">globalCfg := GetGlobalConfig()
        var healthConfig config.HealthCheckConfig
        if globalCfg != nil &amp;&amp; globalCfg.HealthCheck.Enabled </span><span class="cov4" title="14">{
                healthConfig = globalCfg.HealthCheck
        }</span> else<span class="cov1" title="2"> {
                healthConfig = GetDefaultHealthCheckConfig()
        }</span>
        <span class="cov4" title="16">m.healthChecker = NewHealthChecker(healthConfig, m, "memory-eventbus", "memory")

        // 启动健康检查发布器
        if err := m.healthChecker.Start(ctx); err != nil </span><span class="cov0" title="0">{
                m.healthChecker = nil
                return fmt.Errorf("failed to start health check publisher: %w", err)
        }</span>

        <span class="cov4" title="16">logger.Info("Health check publisher started for memory eventbus")
        return nil</span>
}

// StopHealthCheckPublisher 停止健康检查发布器
func (m *eventBusManager) StopHealthCheckPublisher() error <span class="cov4" title="13">{
        // 先获取 healthChecker 的引用，避免在持有锁时调用 Stop()
        m.mu.Lock()
        checker := m.healthChecker
        if checker == nil </span><span class="cov0" title="0">{
                m.mu.Unlock()
                return nil
        }</span>
        <span class="cov4" title="13">m.healthChecker = nil
        m.mu.Unlock()

        // 在锁外调用 Stop()，避免死锁
        if err := checker.Stop(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stop health check publisher: %w", err)
        }</span>

        <span class="cov4" title="13">logger.Info("Health check publisher stopped for memory eventbus")
        return nil</span>
}

// GetHealthCheckPublisherStatus 获取健康检查发布器状态
func (m *eventBusManager) GetHealthCheckPublisherStatus() HealthCheckStatus <span class="cov4" title="20">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        if m.healthChecker == nil </span><span class="cov2" title="5">{
                return HealthCheckStatus{
                        IsHealthy:           false,
                        ConsecutiveFailures: 0,
                        LastSuccessTime:     time.Time{},
                        LastFailureTime:     time.Now(),
                        IsRunning:           false,
                        EventBusType:        "memory",
                        Source:              "memory-eventbus",
                }
        }</span>

        <span class="cov4" title="15">return m.healthChecker.GetStatus()</span>
}

// RegisterHealthCheckPublisherCallback 注册健康检查发布器回调
func (m *eventBusManager) RegisterHealthCheckPublisherCallback(callback HealthCheckCallback) error <span class="cov1" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        if m.healthChecker == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("health check publisher not started")
        }</span>

        <span class="cov1" title="1">return m.healthChecker.RegisterCallback(callback)</span>
}

// RegisterHealthCheckSubscriberCallback 注册健康检查订阅器回调
func (m *eventBusManager) RegisterHealthCheckSubscriberCallback(callback HealthCheckAlertCallback) error <span class="cov3" title="6">{
        return m.RegisterHealthCheckAlertCallback(callback)
}</span>

// StartAllHealthCheck 根据配置启动所有健康检查
func (m *eventBusManager) StartAllHealthCheck(ctx context.Context) error <span class="cov0" title="0">{
        // 这里可以根据配置决定启动哪些健康检查
        // 为了演示，我们启动发布器和订阅器
        if err := m.StartHealthCheckPublisher(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start health check publisher: %w", err)
        }</span>

        <span class="cov0" title="0">if err := m.StartHealthCheckSubscriber(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start health check subscriber: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// StopAllHealthCheck 停止所有健康检查
func (m *eventBusManager) StopAllHealthCheck() error <span class="cov1" title="1">{
        var errs []error

        if err := m.StopHealthCheckPublisher(); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf("failed to stop health check publisher: %w", err))
        }</span>

        <span class="cov1" title="1">if err := m.StopHealthCheckSubscriber(); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf("failed to stop health check subscriber: %w", err))
        }</span>

        <span class="cov1" title="1">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("errors stopping health checks: %v", errs)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// GetConnectionState 获取连接状态
func (m *eventBusManager) GetConnectionState() ConnectionState <span class="cov1" title="2">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        isConnected := !m.closed &amp;&amp; m.publisher != nil &amp;&amp; m.subscriber != nil
        return ConnectionState{
                IsConnected:       isConnected,
                LastConnectedTime: time.Now(),
                ReconnectCount:    0,
                LastError:         "",
        }
}</span>

// ========== 方案A：Envelope 支持 ==========

// PublishEnvelope 发布Envelope消息（方案A）
func (m *eventBusManager) PublishEnvelope(ctx context.Context, topic string, envelope *Envelope) error <span class="cov1" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        if m.closed </span><span class="cov0" title="0">{
                return fmt.Errorf("eventbus is closed")
        }</span>

        // 检查publisher是否支持Envelope
        <span class="cov1" title="1">if envelopePublisher, ok := m.publisher.(EnvelopePublisher); ok </span><span class="cov0" title="0">{
                return envelopePublisher.PublishEnvelope(ctx, topic, envelope)
        }</span>

        // 回退到普通发布（序列化Envelope为字节数组）
        <span class="cov1" title="1">envelopeBytes, err := envelope.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to serialize envelope: %w", err)
        }</span>

        <span class="cov1" title="1">return m.publisher.Publish(ctx, topic, envelopeBytes)</span>
}

// SubscribeEnvelope 订阅Envelope消息（方案A）
func (m *eventBusManager) SubscribeEnvelope(ctx context.Context, topic string, handler EnvelopeHandler) error <span class="cov1" title="2">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        if m.closed </span><span class="cov0" title="0">{
                return fmt.Errorf("eventbus is closed")
        }</span>

        // 检查subscriber是否支持Envelope
        <span class="cov1" title="2">if envelopeSubscriber, ok := m.subscriber.(EnvelopeSubscriber); ok </span><span class="cov0" title="0">{
                return envelopeSubscriber.SubscribeEnvelope(ctx, topic, handler)
        }</span>

        // 回退到普通订阅（包装handler解析Envelope）
        <span class="cov1" title="2">wrappedHandler := func(ctx context.Context, message []byte) error </span><span class="cov3" title="6">{
                envelope, err := FromBytes(message)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse envelope: %w", err)
                }</span>
                <span class="cov3" title="6">return handler(ctx, envelope)</span>
        }

        <span class="cov1" title="2">return m.subscriber.Subscribe(ctx, topic, wrappedHandler)</span>
}

// ========== 主题持久化管理实现 ==========

// ConfigureTopic 配置主题的持久化策略和其他选项
// 注意：Memory EventBus不支持真正的持久化，此方法主要用于接口兼容性
func (m *eventBusManager) ConfigureTopic(ctx context.Context, topic string, options TopicOptions) error <span class="cov3" title="11">{
        m.topicConfigsMu.Lock()
        defer m.topicConfigsMu.Unlock()

        // 缓存配置（即使Memory不支持持久化，也保存配置用于查询）
        m.topicConfigs[topic] = options

        logger.Info("Topic configured for memory eventbus",
                "topic", topic,
                "persistenceMode", string(options.PersistenceMode),
                "note", "Memory EventBus does not support true persistence")

        return nil
}</span>

// SetTopicPersistence 设置主题是否持久化（简化接口）
func (m *eventBusManager) SetTopicPersistence(ctx context.Context, topic string, persistent bool) error <span class="cov3" title="7">{
        mode := TopicEphemeral
        if persistent </span><span class="cov3" title="6">{
                mode = TopicPersistent
        }</span>

        <span class="cov3" title="7">options := DefaultTopicOptions()
        options.PersistenceMode = mode

        return m.ConfigureTopic(ctx, topic, options)</span>
}

// GetTopicConfig 获取主题的当前配置
func (m *eventBusManager) GetTopicConfig(topic string) (TopicOptions, error) <span class="cov3" title="6">{
        m.topicConfigsMu.RLock()
        defer m.topicConfigsMu.RUnlock()

        if config, exists := m.topicConfigs[topic]; exists </span><span class="cov2" title="4">{
                return config, nil
        }</span>

        // 返回默认配置
        <span class="cov1" title="2">return DefaultTopicOptions(), nil</span>
}

// ListConfiguredTopics 列出所有已配置的主题
func (m *eventBusManager) ListConfiguredTopics() []string <span class="cov2" title="3">{
        m.topicConfigsMu.RLock()
        defer m.topicConfigsMu.RUnlock()

        topics := make([]string, 0, len(m.topicConfigs))
        for topic := range m.topicConfigs </span><span class="cov4" title="16">{
                topics = append(topics, topic)
        }</span>

        <span class="cov2" title="3">return topics</span>
}

// RemoveTopicConfig 移除主题配置（恢复为默认行为）
func (m *eventBusManager) RemoveTopicConfig(topic string) error <span class="cov1" title="2">{
        m.topicConfigsMu.Lock()
        defer m.topicConfigsMu.Unlock()

        delete(m.topicConfigs, topic)

        logger.Info("Topic configuration removed from memory eventbus", "topic", topic)
        return nil
}</span>

// SetTopicConfigStrategy 设置主题配置策略
func (m *eventBusManager) SetTopicConfigStrategy(strategy TopicConfigStrategy) <span class="cov0" title="0">{
        // 委托给底层实现
        if setter, ok := m.publisher.(interface {
                SetTopicConfigStrategy(TopicConfigStrategy)
        }); ok </span><span class="cov0" title="0">{
                setter.SetTopicConfigStrategy(strategy)
        }</span>

        <span class="cov0" title="0">if setter, ok := m.subscriber.(interface {
                SetTopicConfigStrategy(TopicConfigStrategy)
        }); ok </span><span class="cov0" title="0">{
                setter.SetTopicConfigStrategy(strategy)
        }</span>

        <span class="cov0" title="0">logger.Info("Topic config strategy updated", "strategy", string(strategy))</span>
}

// GetTopicConfigStrategy 获取当前主题配置策略
func (m *eventBusManager) GetTopicConfigStrategy() TopicConfigStrategy <span class="cov0" title="0">{
        // 从底层实现获取
        if getter, ok := m.publisher.(interface {
                GetTopicConfigStrategy() TopicConfigStrategy
        }); ok </span><span class="cov0" title="0">{
                return getter.GetTopicConfigStrategy()
        }</span>

        // 默认返回创建或更新策略
        <span class="cov0" title="0">return StrategyCreateOrUpdate</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package eventbus

import (
        "fmt"
        "sync"
        "time"

        "github.com/ChenBigdata421/jxt-core/sdk/config"
        "github.com/ChenBigdata421/jxt-core/sdk/pkg/logger"
)

var (
        // 全局事件总线实例
        globalEventBus EventBus
        globalMutex    sync.RWMutex
        initialized    bool

        // 全局配置存储
        globalConfig *config.EventBusConfig
)

// Factory 事件总线工厂
type Factory struct {
        config *EventBusConfig
}

// NewFactory 创建事件总线工厂
func NewFactory(config *EventBusConfig) *Factory <span class="cov10" title="36">{
        return &amp;Factory{config: config}
}</span>

// CreateEventBus 创建事件总线实例
func (f *Factory) CreateEventBus() (EventBus, error) <span class="cov9" title="34">{
        if f.config == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("eventbus config is required")
        }</span>

        // 验证配置
        <span class="cov9" title="33">if err := f.validateConfig(); err != nil </span><span class="cov4" title="4">{
                return nil, fmt.Errorf("invalid eventbus config: %w", err)
        }</span>

        // 创建事件总线实例
        <span class="cov9" title="29">eventBus, err := NewEventBus(f.config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create eventbus: %w", err)
        }</span>

        <span class="cov9" title="29">logger.Info("EventBus created successfully", "type", f.config.Type)
        return eventBus, nil</span>
}

// validateConfig 验证配置
func (f *Factory) validateConfig() error <span class="cov9" title="35">{
        if f.config.Type == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("eventbus type is required")
        }</span>

        <span class="cov9" title="34">switch f.config.Type </span>{
        case "kafka":<span class="cov1" title="1">
                return f.validateKafkaConfig()</span>
        case "nats":<span class="cov2" title="2">
                return f.validateNATSConfig()</span>
        case "memory":<span class="cov9" title="30">
                return f.validateMemoryConfig()</span>
        default:<span class="cov1" title="1">
                return fmt.Errorf("unsupported eventbus type: %s", f.config.Type)</span>
        }
}

// validateKafkaConfig 验证Kafka配置
func (f *Factory) validateKafkaConfig() error <span class="cov1" title="1">{
        kafka := &amp;f.config.Kafka

        if len(kafka.Brokers) == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("kafka brokers are required")
        }</span>

        // 设置默认值
        <span class="cov0" title="0">if kafka.HealthCheckInterval == 0 </span><span class="cov0" title="0">{
                kafka.HealthCheckInterval = 5 * time.Minute
        }</span>

        <span class="cov0" title="0">if kafka.Producer.RequiredAcks == 0 </span><span class="cov0" title="0">{
                kafka.Producer.RequiredAcks = 1 // WaitForLocal
        }</span>

        <span class="cov0" title="0">if kafka.Producer.FlushFrequency == 0 </span><span class="cov0" title="0">{
                kafka.Producer.FlushFrequency = 500 * time.Millisecond
        }</span>

        <span class="cov0" title="0">if kafka.Producer.FlushMessages == 0 </span><span class="cov0" title="0">{
                kafka.Producer.FlushMessages = 100
        }</span>

        <span class="cov0" title="0">if kafka.Producer.RetryMax == 0 </span><span class="cov0" title="0">{
                kafka.Producer.RetryMax = 3
        }</span>

        <span class="cov0" title="0">if kafka.Producer.Timeout == 0 </span><span class="cov0" title="0">{
                kafka.Producer.Timeout = 10 * time.Second
        }</span>

        <span class="cov0" title="0">if kafka.Consumer.GroupID == "" </span><span class="cov0" title="0">{
                kafka.Consumer.GroupID = "jxt-eventbus-group"
        }</span>

        <span class="cov0" title="0">if kafka.Consumer.AutoOffsetReset == "" </span><span class="cov0" title="0">{
                kafka.Consumer.AutoOffsetReset = "earliest"
        }</span>

        <span class="cov0" title="0">if kafka.Consumer.SessionTimeout == 0 </span><span class="cov0" title="0">{
                kafka.Consumer.SessionTimeout = 30 * time.Second
        }</span>

        <span class="cov0" title="0">if kafka.Consumer.HeartbeatInterval == 0 </span><span class="cov0" title="0">{
                kafka.Consumer.HeartbeatInterval = 3 * time.Second
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateNATSConfig 验证NATS配置
func (f *Factory) validateNATSConfig() error <span class="cov2" title="2">{
        nats := &amp;f.config.NATS

        if len(nats.URLs) == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("nats urls are required")
        }</span>

        // 设置默认值
        <span class="cov1" title="1">if nats.ClientID == "" </span><span class="cov1" title="1">{
                nats.ClientID = "jxt-client"
        }</span>

        <span class="cov1" title="1">if nats.MaxReconnects == 0 </span><span class="cov1" title="1">{
                nats.MaxReconnects = 10
        }</span>

        <span class="cov1" title="1">if nats.ReconnectWait == 0 </span><span class="cov1" title="1">{
                nats.ReconnectWait = 2 * time.Second
        }</span>

        <span class="cov1" title="1">if nats.ConnectionTimeout == 0 </span><span class="cov1" title="1">{
                nats.ConnectionTimeout = 10 * time.Second
        }</span>

        <span class="cov1" title="1">if nats.HealthCheckInterval == 0 </span><span class="cov1" title="1">{
                nats.HealthCheckInterval = 5 * time.Minute
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// validateMemoryConfig 验证内存配置
func (f *Factory) validateMemoryConfig() error <span class="cov9" title="30">{
        // 内存实现不需要特殊配置验证
        return nil
}</span>

// GetDefaultConfig 获取默认配置
func GetDefaultConfig(eventBusType string) *EventBusConfig <span class="cov3" title="3">{
        config := &amp;EventBusConfig{
                Type: eventBusType,
                Metrics: MetricsConfig{
                        Enabled:         true,
                        CollectInterval: DefaultMetricsCollectInterval,
                },
                Tracing: TracingConfig{
                        Enabled:    false,
                        SampleRate: DefaultTracingSampleRate,
                },
        }

        switch eventBusType </span>{
        case "kafka":<span class="cov1" title="1">
                config.Kafka = KafkaConfig{
                        Brokers:             []string{"localhost:9092"},
                        HealthCheckInterval: DefaultKafkaHealthCheckInterval,
                        Producer: ProducerConfig{
                                RequiredAcks:   DefaultKafkaProducerRequiredAcks,
                                Compression:    "snappy",
                                FlushFrequency: DefaultKafkaProducerFlushFrequency,
                                FlushMessages:  DefaultKafkaProducerFlushMessages,
                                RetryMax:       DefaultKafkaProducerRetryMax,
                                Timeout:        DefaultKafkaProducerTimeout,
                                BatchSize:      DefaultKafkaProducerBatchSize,
                                BufferSize:     DefaultKafkaProducerBufferSize,
                        },
                        Consumer: ConsumerConfig{
                                GroupID:           "jxt-eventbus-group",
                                AutoOffsetReset:   "earliest",
                                SessionTimeout:    DefaultKafkaConsumerSessionTimeout,
                                HeartbeatInterval: DefaultKafkaConsumerHeartbeatInterval,
                                MaxProcessingTime: DefaultKafkaConsumerMaxProcessingTime,
                                FetchMinBytes:     DefaultKafkaConsumerFetchMinBytes,
                                FetchMaxBytes:     DefaultKafkaConsumerFetchMaxBytes,
                                FetchMaxWait:      DefaultKafkaConsumerFetchMaxWait,
                        },
                }</span>
        case "nats":<span class="cov1" title="1">
                config.NATS = NATSConfig{
                        URLs:                []string{"nats://localhost:4222"},
                        ClientID:            "jxt-client",
                        MaxReconnects:       DefaultNATSMaxReconnects,
                        ReconnectWait:       DefaultNATSReconnectWait,
                        ConnectionTimeout:   DefaultNATSConnectionTimeout,
                        HealthCheckInterval: DefaultNATSHealthCheckInterval,
                }</span>
        }

        <span class="cov3" title="3">return config</span>
}

// GetDefaultPersistentNATSConfig 获取持久化NATS配置
func GetDefaultPersistentNATSConfig(urls []string, clientID string) *EventBusConfig <span class="cov2" title="2">{
        if len(urls) == 0 </span><span class="cov1" title="1">{
                urls = []string{"nats://localhost:4222"}
        }</span>
        <span class="cov2" title="2">if clientID == "" </span><span class="cov1" title="1">{
                clientID = "jxt-persistent-client"
        }</span>

        <span class="cov2" title="2">return &amp;EventBusConfig{
                Type: "nats",
                NATS: NATSConfig{
                        URLs:                urls,
                        ClientID:            clientID,
                        MaxReconnects:       DefaultNATSMaxReconnects,
                        ReconnectWait:       DefaultNATSReconnectWait,
                        ConnectionTimeout:   DefaultNATSConnectionTimeout,
                        HealthCheckInterval: DefaultNATSHealthCheckInterval,
                        JetStream: JetStreamConfig{
                                Enabled:        true, // 启用持久化
                                PublishTimeout: DefaultNATSPublishTimeout,
                                AckWait:        DefaultNATSAckWait,
                                MaxDeliver:     DefaultNATSMaxDeliver,
                                Stream: StreamConfig{
                                        Name:      "PERSISTENT_STREAM",
                                        Subjects:  []string{"*"}, // 接受所有主题
                                        Retention: "limits",
                                        Storage:   "file", // 文件存储，持久化
                                        Replicas:  DefaultNATSStreamReplicas,
                                        MaxAge:    DefaultNATSStreamMaxAge,
                                        MaxBytes:  DefaultNATSStreamMaxBytes,
                                        MaxMsgs:   DefaultNATSStreamMaxMsgs,
                                        Discard:   "old",
                                },
                                Consumer: NATSConsumerConfig{
                                        DurableName:   "persistent-consumer",
                                        DeliverPolicy: "all",
                                        AckPolicy:     "explicit",
                                        ReplayPolicy:  "instant",
                                        MaxAckPending: DefaultNATSConsumerMaxAckPending,
                                        MaxWaiting:    DefaultNATSConsumerMaxWaiting,
                                        MaxDeliver:    DefaultNATSMaxDeliver,
                                },
                        },
                },
                Metrics: MetricsConfig{
                        Enabled:         true,
                        CollectInterval: DefaultMetricsCollectInterval,
                },
                Tracing: TracingConfig{
                        Enabled:    false,
                        SampleRate: DefaultTracingSampleRate,
                },
        }</span>
}

// GetDefaultEphemeralNATSConfig 获取非持久化NATS配置
func GetDefaultEphemeralNATSConfig(urls []string, clientID string) *EventBusConfig <span class="cov2" title="2">{
        if len(urls) == 0 </span><span class="cov1" title="1">{
                urls = []string{"nats://localhost:4222"}
        }</span>
        <span class="cov2" title="2">if clientID == "" </span><span class="cov1" title="1">{
                clientID = "jxt-ephemeral-client"
        }</span>

        <span class="cov2" title="2">return &amp;EventBusConfig{
                Type: "nats",
                NATS: NATSConfig{
                        URLs:                urls,
                        ClientID:            clientID,
                        MaxReconnects:       DefaultNATSMaxReconnects,
                        ReconnectWait:       DefaultNATSReconnectWait,
                        ConnectionTimeout:   DefaultNATSConnectionTimeout,
                        HealthCheckInterval: DefaultNATSHealthCheckInterval,
                        JetStream: JetStreamConfig{
                                Enabled: false, // 禁用持久化，使用Core NATS
                        },
                },
                Metrics: MetricsConfig{
                        Enabled:         true,
                        CollectInterval: DefaultMetricsCollectInterval,
                },
                Tracing: TracingConfig{
                        Enabled:    false,
                        SampleRate: DefaultTracingSampleRate,
                },
        }</span>
}

// InitializeGlobal 初始化全局事件总线
func InitializeGlobal(config *EventBusConfig) error <span class="cov9" title="29">{
        globalMutex.Lock()
        defer globalMutex.Unlock()

        if initialized </span><span class="cov1" title="1">{
                return fmt.Errorf("global eventbus already initialized")
        }</span>

        <span class="cov9" title="28">factory := NewFactory(config)
        eventBus, err := factory.CreateEventBus()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize global eventbus: %w", err)
        }</span>

        <span class="cov9" title="28">globalEventBus = eventBus
        initialized = true

        logger.Info("Global EventBus initialized successfully", "type", config.Type)
        return nil</span>
}

// GetGlobal 获取全局事件总线实例
func GetGlobal() EventBus <span class="cov8" title="22">{
        globalMutex.RLock()
        defer globalMutex.RUnlock()

        if !initialized </span><span class="cov2" title="2">{
                logger.Warn("Global eventbus not initialized, returning nil")
                return nil
        }</span>

        <span class="cov8" title="20">return globalEventBus</span>
}

// CloseGlobal 关闭全局事件总线
func CloseGlobal() error <span class="cov9" title="32">{
        globalMutex.Lock()
        defer globalMutex.Unlock()

        if !initialized </span><span class="cov4" title="4">{
                return nil
        }</span>

        <span class="cov9" title="28">if globalEventBus != nil </span><span class="cov9" title="28">{
                if err := globalEventBus.Close(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to close global eventbus: %w", err)
                }</span>
        }

        <span class="cov9" title="28">globalEventBus = nil
        globalConfig = nil
        initialized = false

        logger.Info("Global EventBus closed successfully")
        return nil</span>
}

// IsInitialized 检查全局事件总线是否已初始化
func IsInitialized() bool <span class="cov5" title="5">{
        globalMutex.RLock()
        defer globalMutex.RUnlock()
        return initialized
}</span>

// SetGlobalConfig 设置全局配置
func SetGlobalConfig(cfg *config.EventBusConfig) <span class="cov8" title="24">{
        globalMutex.Lock()
        defer globalMutex.Unlock()
        globalConfig = cfg
}</span>

// GetGlobalConfig 获取全局配置
func GetGlobalConfig() *config.EventBusConfig <span class="cov9" title="32">{
        globalMutex.RLock()
        defer globalMutex.RUnlock()
        return globalConfig
}</span>

// ========== 便捷工厂方法 ==========

// NewPersistentNATSEventBus 创建持久化NATS EventBus实例
func NewPersistentNATSEventBus(urls []string, clientID string) (EventBus, error) <span class="cov0" title="0">{
        config := GetDefaultPersistentNATSConfig(urls, clientID)
        return NewEventBus(config)
}</span>

// NewEphemeralNATSEventBus 创建非持久化NATS EventBus实例
func NewEphemeralNATSEventBus(urls []string, clientID string) (EventBus, error) <span class="cov0" title="0">{
        config := GetDefaultEphemeralNATSConfig(urls, clientID)
        return NewEventBus(config)
}</span>

// NewPersistentKafkaEventBus 创建持久化Kafka EventBus实例
func NewPersistentKafkaEventBus(brokers []string) (EventBus, error) <span class="cov0" title="0">{
        config := GetDefaultConfig("kafka")
        config.Kafka.Brokers = brokers
        // Kafka默认就是持久化的
        return NewEventBus(config)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package eventbus

import (
        "crypto/rand"
        "encoding/hex"
        "fmt"
        "time"
)

// 统一健康检查主题常量
const (
        // DefaultHealthCheckTopic jxt-core 统一管理的健康检查主题
        DefaultHealthCheckTopic = "jxt-core-health-check"

        // 按事件总线类型的健康检查主题
        KafkaHealthCheckTopic  = "jxt-core-kafka-health-check"
        NATSHealthCheckTopic   = "jxt-core-nats-health-check"
        MemoryHealthCheckTopic = "jxt-core-memory-health-check"
)

// HealthCheckMessage 标准化的健康检查消息
type HealthCheckMessage struct {
        MessageID    string            `json:"messageId"`
        Timestamp    time.Time         `json:"timestamp"`
        Source       string            `json:"source"`       // 微服务名称
        EventBusType string            `json:"eventBusType"` // kafka/nats/memory
        Version      string            `json:"version"`      // jxt-core版本
        Metadata     map[string]string `json:"metadata"`
}

// CreateHealthCheckMessage 创建标准健康检查消息
func CreateHealthCheckMessage(source, eventBusType string) *HealthCheckMessage <span class="cov8" title="150">{
        return &amp;HealthCheckMessage{
                MessageID:    generateHealthCheckMessageID(),
                Timestamp:    time.Now(),
                Source:       source,
                EventBusType: eventBusType,
                Version:      GetJXTCoreVersion(),
                Metadata:     make(map[string]string),
        }
}</span>

// ToBytes 序列化为字节数组
func (h *HealthCheckMessage) ToBytes() ([]byte, error) <span class="cov8" title="145">{
        // 确保 Metadata 不为 nil
        if h.Metadata == nil </span><span class="cov0" title="0">{
                h.Metadata = make(map[string]string)
        }</span>
        <span class="cov8" title="145">return Marshal(h)</span>
}

// FromBytes 从字节数组反序列化
func (h *HealthCheckMessage) FromBytes(data []byte) error <span class="cov2" title="2">{
        return Unmarshal(data, h)
}</span>

// IsValid 验证消息是否有效
func (h *HealthCheckMessage) IsValid() bool <span class="cov3" title="6">{
        if h.MessageID == "" || h.Source == "" || h.EventBusType == "" </span><span class="cov2" title="3">{
                return false
        }</span>

        // 检查时间戳是否在合理范围内（避免时钟偏移问题）
        <span class="cov2" title="3">now := time.Now()
        if h.Timestamp.After(now.Add(1*time.Minute)) ||
                h.Timestamp.Before(now.Add(-5*time.Minute)) </span><span class="cov2" title="2">{
                return false
        }</span>

        <span class="cov1" title="1">return true</span>
}

// IsExpired 检查消息是否过期
func (h *HealthCheckMessage) IsExpired(ttl time.Duration) bool <span class="cov8" title="127">{
        return time.Since(h.Timestamp) &gt; ttl
}</span>

// SetMetadata 设置元数据
func (h *HealthCheckMessage) SetMetadata(key, value string) <span class="cov9" title="291">{
        if h.Metadata == nil </span><span class="cov1" title="1">{
                h.Metadata = make(map[string]string)
        }</span>
        <span class="cov9" title="291">h.Metadata[key] = value</span>
}

// GetMetadata 获取元数据
func (h *HealthCheckMessage) GetMetadata(key string) (string, bool) <span class="cov3" title="7">{
        if h.Metadata == nil </span><span class="cov1" title="1">{
                return "", false
        }</span>
        <span class="cov3" title="6">value, exists := h.Metadata[key]
        return value, exists</span>
}

// generateHealthCheckMessageID 生成健康检查消息ID
func generateHealthCheckMessageID() string <span class="cov8" title="150">{
        bytes := make([]byte, 8)
        rand.Read(bytes)
        return fmt.Sprintf("hc-%d-%s", time.Now().UnixNano(), hex.EncodeToString(bytes))
}</span>

// GetJXTCoreVersion 获取 jxt-core 版本
func GetJXTCoreVersion() string <span class="cov8" title="150">{
        // 这里应该从构建信息获取，暂时使用硬编码
        return "2.0.0"
}</span>

// GetHealthCheckTopic 根据事件总线类型获取健康检查主题
func GetHealthCheckTopic(eventBusType string) string <span class="cov5" title="27">{
        switch eventBusType </span>{
        case "kafka":<span class="cov2" title="3">
                return KafkaHealthCheckTopic</span>
        case "nats":<span class="cov2" title="3">
                return NATSHealthCheckTopic</span>
        case "memory":<span class="cov5" title="20">
                return MemoryHealthCheckTopic</span>
        default:<span class="cov1" title="1">
                return DefaultHealthCheckTopic</span>
        }
}

// HealthCheckMessageValidator 健康检查消息验证器
type HealthCheckMessageValidator struct {
        MaxMessageAge  time.Duration // 最大消息年龄
        RequiredFields []string      // 必需字段
}

// NewHealthCheckMessageValidator 创建健康检查消息验证器
func NewHealthCheckMessageValidator() *HealthCheckMessageValidator <span class="cov7" title="67">{
        return &amp;HealthCheckMessageValidator{
                MaxMessageAge:  DefaultBacklogTimeThreshold, // 使用默认积压时间阈值
                RequiredFields: []string{"messageId", "timestamp", "source", "eventBusType", "version"},
        }
}</span>

// Validate 验证健康检查消息
func (v *HealthCheckMessageValidator) Validate(msg *HealthCheckMessage) error <span class="cov8" title="134">{
        if msg == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("health check message cannot be nil")
        }</span>

        // 验证必需字段
        <span class="cov8" title="133">if msg.MessageID == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("messageId is required")
        }</span>
        <span class="cov8" title="132">if msg.Source == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("source is required")
        }</span>
        <span class="cov8" title="131">if msg.EventBusType == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("eventBusType is required")
        }</span>
        <span class="cov8" title="130">if msg.Version == "" </span><span class="cov2" title="3">{
                return fmt.Errorf("version is required")
        }</span>

        // 验证时间戳
        <span class="cov8" title="127">if msg.Timestamp.IsZero() </span><span class="cov0" title="0">{
                return fmt.Errorf("timestamp is required")
        }</span>

        // 验证消息年龄
        <span class="cov8" title="127">if msg.IsExpired(v.MaxMessageAge) </span><span class="cov0" title="0">{
                return fmt.Errorf("message is too old: %v", time.Since(msg.Timestamp))
        }</span>

        // 验证事件总线类型
        <span class="cov8" title="127">validTypes := []string{"kafka", "nats", "memory"}
        isValidType := false
        for _, validType := range validTypes </span><span class="cov10" title="381">{
                if msg.EventBusType == validType </span><span class="cov8" title="127">{
                        isValidType = true
                        break</span>
                }
        }
        <span class="cov8" title="127">if !isValidType </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid eventBusType: %s", msg.EventBusType)
        }</span>

        <span class="cov8" title="127">return nil</span>
}

// HealthCheckMessageBuilder 健康检查消息构建器
type HealthCheckMessageBuilder struct {
        message *HealthCheckMessage
}

// NewHealthCheckMessageBuilder 创建健康检查消息构建器
func NewHealthCheckMessageBuilder(source, eventBusType string) *HealthCheckMessageBuilder <span class="cov8" title="142">{
        return &amp;HealthCheckMessageBuilder{
                message: CreateHealthCheckMessage(source, eventBusType),
        }
}</span>

// WithMetadata 添加元数据
func (b *HealthCheckMessageBuilder) WithMetadata(key, value string) *HealthCheckMessageBuilder <span class="cov1" title="1">{
        b.message.SetMetadata(key, value)
        return b
}</span>

// WithCheckType 设置检查类型
func (b *HealthCheckMessageBuilder) WithCheckType(checkType string) *HealthCheckMessageBuilder <span class="cov8" title="141">{
        b.message.SetMetadata("checkType", checkType)
        return b
}</span>

// WithInstanceID 设置实例ID
func (b *HealthCheckMessageBuilder) WithInstanceID(instanceID string) *HealthCheckMessageBuilder <span class="cov8" title="141">{
        b.message.SetMetadata("instanceId", instanceID)
        return b
}</span>

// WithEnvironment 设置环境
func (b *HealthCheckMessageBuilder) WithEnvironment(env string) *HealthCheckMessageBuilder <span class="cov1" title="1">{
        b.message.SetMetadata("environment", env)
        return b
}</span>

// Build 构建消息
func (b *HealthCheckMessageBuilder) Build() *HealthCheckMessage <span class="cov8" title="142">{
        return b.message
}</span>

// HealthCheckMessageParser 健康检查消息解析器
type HealthCheckMessageParser struct {
        validator *HealthCheckMessageValidator
}

// NewHealthCheckMessageParser 创建健康检查消息解析器
func NewHealthCheckMessageParser() *HealthCheckMessageParser <span class="cov7" title="66">{
        return &amp;HealthCheckMessageParser{
                validator: NewHealthCheckMessageValidator(),
        }
}</span>

// Parse 解析健康检查消息
func (p *HealthCheckMessageParser) Parse(data []byte) (*HealthCheckMessage, error) <span class="cov8" title="128">{
        var msg HealthCheckMessage
        if err := Unmarshal(data, &amp;msg); err != nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("failed to unmarshal health check message: %w", err)
        }</span>

        <span class="cov8" title="126">if err := p.validator.Validate(&amp;msg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("health check message validation failed: %w", err)
        }</span>

        <span class="cov8" title="126">return &amp;msg, nil</span>
}

// ParseWithoutValidation 解析健康检查消息（不验证）
func (p *HealthCheckMessageParser) ParseWithoutValidation(data []byte) (*HealthCheckMessage, error) <span class="cov0" title="0">{
        var msg HealthCheckMessage
        if err := Unmarshal(data, &amp;msg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal health check message: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;msg, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package eventbus

import (
        "context"
        "fmt"
        "sync"
        "sync/atomic"
        "time"

        "github.com/ChenBigdata421/jxt-core/sdk/config"
        "github.com/ChenBigdata421/jxt-core/sdk/pkg/logger"
)

// HealthCheckAlertCallback 健康检查告警回调函数
type HealthCheckAlertCallback func(ctx context.Context, alert HealthCheckAlert) error

// HealthCheckAlert 健康检查告警信息
type HealthCheckAlert struct {
        AlertType         string            `json:"alertType"`         // 告警类型：no_messages, connection_lost, message_expired
        Severity          string            `json:"severity"`          // 严重程度：warning, error, critical
        Source            string            `json:"source"`            // 告警来源
        EventBusType      string            `json:"eventBusType"`      // EventBus类型
        Topic             string            `json:"topic"`             // 健康检查主题
        LastMessageTime   time.Time         `json:"lastMessageTime"`   // 最后收到消息的时间
        TimeSinceLastMsg  time.Duration     `json:"timeSinceLastMsg"`  // 距离最后消息的时间
        ExpectedInterval  time.Duration     `json:"expectedInterval"`  // 期望的消息间隔
        ConsecutiveMisses int               `json:"consecutiveMisses"` // 连续错过的消息数
        Timestamp         time.Time         `json:"timestamp"`         // 告警时间
        Metadata          map[string]string `json:"metadata"`          // 额外元数据
}

// HealthCheckSubscriber 健康检查消息订阅监控器
type HealthCheckSubscriber struct {
        config       config.HealthCheckConfig
        eventBus     EventBus
        source       string
        eventBusType string

        // 状态管理
        isRunning             atomic.Bool
        lastMessageTime       atomic.Value // time.Time
        consecutiveMisses     atomic.Int32
        totalMessagesReceived atomic.Int64

        // 控制
        ctx    context.Context
        cancel context.CancelFunc
        wg     sync.WaitGroup

        // 告警回调
        alertCallbacks []HealthCheckAlertCallback
        callbackMu     sync.RWMutex

        // 消息解析器
        parser *HealthCheckMessageParser

        // 监控统计
        stats   HealthCheckSubscriberStats
        statsMu sync.RWMutex
}

// HealthCheckSubscriberStats 订阅监控器统计信息
type HealthCheckSubscriberStats struct {
        StartTime             time.Time `json:"startTime"`
        LastMessageTime       time.Time `json:"lastMessageTime"`
        TotalMessagesReceived int64     `json:"totalMessagesReceived"`
        ConsecutiveMisses     int32     `json:"consecutiveMisses"`
        TotalAlerts           int64     `json:"totalAlerts"`
        LastAlertTime         time.Time `json:"lastAlertTime"`
        IsHealthy             bool      `json:"isHealthy"`
        UptimeSeconds         float64   `json:"uptimeSeconds"`
}

// NewHealthCheckSubscriber 创建健康检查订阅监控器
func NewHealthCheckSubscriber(config config.HealthCheckConfig, eventBus EventBus, source, eventBusType string) *HealthCheckSubscriber <span class="cov6" title="29">{
        hcs := &amp;HealthCheckSubscriber{
                config:       config,
                eventBus:     eventBus,
                source:       source,
                eventBusType: eventBusType,
                parser:       NewHealthCheckMessageParser(),
        }

        // 设置默认配置
        if hcs.config.Subscriber.Topic == "" </span><span class="cov5" title="12">{
                hcs.config.Subscriber.Topic = GetHealthCheckTopic(eventBusType)
        }</span>
        <span class="cov6" title="29">if hcs.config.Publisher.Interval == 0 </span><span class="cov5" title="13">{
                hcs.config.Publisher.Interval = 2 * time.Minute
        }</span>
        <span class="cov6" title="29">if hcs.config.Publisher.Timeout == 0 </span><span class="cov5" title="13">{
                hcs.config.Publisher.Timeout = 10 * time.Second
        }</span>
        <span class="cov6" title="29">if hcs.config.Publisher.FailureThreshold == 0 </span><span class="cov5" title="13">{
                hcs.config.Publisher.FailureThreshold = 3
        }</span>
        <span class="cov6" title="29">if hcs.config.Publisher.MessageTTL == 0 </span><span class="cov5" title="13">{
                hcs.config.Publisher.MessageTTL = 5 * time.Minute
        }</span>

        // 订阅监控器默认值
        <span class="cov6" title="29">if hcs.config.Subscriber.MonitorInterval == 0 </span><span class="cov5" title="13">{
                hcs.config.Subscriber.MonitorInterval = 30 * time.Second
        }</span>
        <span class="cov6" title="29">if hcs.config.Subscriber.WarningThreshold == 0 </span><span class="cov5" title="13">{
                hcs.config.Subscriber.WarningThreshold = 3
        }</span>
        <span class="cov6" title="29">if hcs.config.Subscriber.ErrorThreshold == 0 </span><span class="cov5" title="13">{
                hcs.config.Subscriber.ErrorThreshold = 5
        }</span>
        <span class="cov6" title="29">if hcs.config.Subscriber.CriticalThreshold == 0 </span><span class="cov5" title="13">{
                hcs.config.Subscriber.CriticalThreshold = 10
        }</span>

        // 初始化统计信息
        <span class="cov6" title="29">hcs.stats.StartTime = time.Now()
        hcs.lastMessageTime.Store(time.Time{})

        return hcs</span>
}

// Start 启动健康检查订阅监控
func (hcs *HealthCheckSubscriber) Start(ctx context.Context) error <span class="cov5" title="19">{
        if hcs.isRunning.Load() </span><span class="cov1" title="1">{
                return nil // 已经在运行
        }</span>

        <span class="cov5" title="18">hcs.ctx, hcs.cancel = context.WithCancel(ctx)
        hcs.isRunning.Store(true)

        // 启动订阅健康检查主题
        if err := hcs.subscribeToHealthCheckTopic(); err != nil </span><span class="cov0" title="0">{
                hcs.isRunning.Store(false)
                return fmt.Errorf("failed to subscribe to health check topic: %w", err)
        }</span>

        // 启动监控循环
        <span class="cov5" title="18">hcs.wg.Add(1)
        go hcs.monitoringLoop()

        logger.Info("Health check subscriber started",
                "source", hcs.source,
                "eventBusType", hcs.eventBusType,
                "topic", hcs.config.Subscriber.Topic,
                "expectedInterval", hcs.config.Publisher.Interval)

        return nil</span>
}

// Stop 停止健康检查订阅监控
func (hcs *HealthCheckSubscriber) Stop() error <span class="cov5" title="19">{
        if !hcs.isRunning.Load() </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov5" title="18">hcs.cancel()
        hcs.wg.Wait()
        hcs.isRunning.Store(false)

        logger.Info("Health check subscriber stopped",
                "source", hcs.source,
                "eventBusType", hcs.eventBusType)

        return nil</span>
}

// subscribeToHealthCheckTopic 订阅健康检查主题
func (hcs *HealthCheckSubscriber) subscribeToHealthCheckTopic() error <span class="cov5" title="18">{
        handler := func(ctx context.Context, data []byte) error </span><span class="cov8" title="123">{
                return hcs.handleHealthCheckMessage(ctx, data)
        }</span>

        <span class="cov5" title="18">return hcs.eventBus.Subscribe(hcs.ctx, hcs.config.Subscriber.Topic, handler)</span>
}

// handleHealthCheckMessage 处理健康检查消息
func (hcs *HealthCheckSubscriber) handleHealthCheckMessage(ctx context.Context, data []byte) error <span class="cov8" title="123">{
        // 解析健康检查消息
        healthMsg, err := hcs.parser.Parse(data)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn("Failed to parse health check message",
                        "source", hcs.source,
                        "error", err,
                        "rawData", string(data))
                return nil // 不返回错误，避免影响其他消息处理
        }</span>

        // 更新最后消息时间
        <span class="cov8" title="123">now := time.Now()
        hcs.lastMessageTime.Store(now)
        hcs.totalMessagesReceived.Add(1)

        // 重置连续错过计数
        hcs.consecutiveMisses.Store(0)

        // 更新统计信息
        hcs.updateStats(now, healthMsg)

        logger.Debug("Received health check message",
                "source", hcs.source,
                "messageSource", healthMsg.Source,
                "messageId", healthMsg.MessageID,
                "eventBusType", healthMsg.EventBusType,
                "timestamp", healthMsg.Timestamp)

        return nil</span>
}

// monitoringLoop 监控循环
func (hcs *HealthCheckSubscriber) monitoringLoop() <span class="cov5" title="18">{
        defer hcs.wg.Done()

        // 使用配置的监控间隔，如果未设置则使用发布间隔的一半作为后备
        monitorInterval := hcs.config.Subscriber.MonitorInterval
        if monitorInterval == 0 </span><span class="cov0" title="0">{
                monitorInterval = hcs.config.Publisher.Interval / 2
        }</span>

        // 最小监控间隔为100ms，避免过于频繁的检查
        <span class="cov5" title="18">if monitorInterval &lt; 100*time.Millisecond </span><span class="cov1" title="1">{
                monitorInterval = 100 * time.Millisecond
        }</span>

        <span class="cov5" title="18">ticker := time.NewTicker(monitorInterval)
        defer ticker.Stop()

        logger.Debug("Health check monitoring loop started",
                "source", hcs.source,
                "monitorInterval", monitorInterval,
                "expectedInterval", hcs.config.Publisher.Interval)

        for </span><span class="cov10" title="226">{
                select </span>{
                case &lt;-hcs.ctx.Done():<span class="cov5" title="18">
                        logger.Debug("Health check monitoring loop stopped", "source", hcs.source)
                        return</span>
                case &lt;-ticker.C:<span class="cov9" title="208">
                        hcs.checkHealthStatus()</span>
                }
        }
}

// checkHealthStatus 检查健康状态
func (hcs *HealthCheckSubscriber) checkHealthStatus() <span class="cov9" title="208">{
        lastMsgTime := hcs.getLastMessageTime()
        now := time.Now()

        // 如果从未收到消息，且启动时间超过期望间隔，则告警
        if lastMsgTime.IsZero() </span><span class="cov4" title="11">{
                if time.Since(hcs.stats.StartTime) &gt; hcs.config.Publisher.Interval </span><span class="cov0" title="0">{
                        hcs.triggerAlert("no_messages", "warning",
                                "No health check messages received since startup", now, lastMsgTime)
                }</span>
                <span class="cov4" title="11">return</span>
        }

        // 检查消息是否超时
        <span class="cov9" title="197">timeSinceLastMsg := now.Sub(lastMsgTime)
        if timeSinceLastMsg &gt; hcs.config.Publisher.Interval </span><span class="cov6" title="28">{
                // 增加连续错过计数
                misses := hcs.consecutiveMisses.Add(1)

                // 根据连续错过次数确定告警级别
                severity := "warning"
                if misses &gt;= int32(hcs.config.Publisher.FailureThreshold) </span><span class="cov3" title="6">{
                        severity = "critical"
                }</span> else<span class="cov6" title="22"> if misses &gt;= int32(hcs.config.Publisher.FailureThreshold)/2 </span><span class="cov6" title="22">{
                        severity = "error"
                }</span>

                <span class="cov6" title="28">hcs.triggerAlert("no_messages", severity,
                        fmt.Sprintf("No health check messages received for %v (consecutive misses: %d)",
                                timeSinceLastMsg, misses), now, lastMsgTime)</span>
        }
}

// triggerAlert 触发告警
func (hcs *HealthCheckSubscriber) triggerAlert(alertType, severity, message string, timestamp, lastMsgTime time.Time) <span class="cov6" title="28">{
        alert := HealthCheckAlert{
                AlertType:         alertType,
                Severity:          severity,
                Source:            hcs.source,
                EventBusType:      hcs.eventBusType,
                Topic:             hcs.config.Subscriber.Topic,
                LastMessageTime:   lastMsgTime,
                TimeSinceLastMsg:  timestamp.Sub(lastMsgTime),
                ExpectedInterval:  hcs.config.Publisher.Interval,
                ConsecutiveMisses: int(hcs.consecutiveMisses.Load()),
                Timestamp:         timestamp,
                Metadata: map[string]string{
                        "message": message,
                },
        }

        // 更新统计信息
        hcs.statsMu.Lock()
        hcs.stats.TotalAlerts++
        hcs.stats.LastAlertTime = timestamp
        hcs.stats.IsHealthy = severity != "critical"
        hcs.statsMu.Unlock()

        // 记录日志
        logLevel := logger.Info
        if severity == "error" </span><span class="cov6" title="22">{
                logLevel = logger.Warn
        }</span> else<span class="cov3" title="6"> if severity == "critical" </span><span class="cov3" title="6">{
                logLevel = logger.Error
        }</span>

        <span class="cov6" title="28">logLevel("Health check alert triggered",
                "source", hcs.source,
                "alertType", alertType,
                "severity", severity,
                "message", message,
                "timeSinceLastMsg", alert.TimeSinceLastMsg,
                "consecutiveMisses", alert.ConsecutiveMisses)

        // 调用告警回调
        hcs.notifyAlertCallbacks(alert)</span>
}

// notifyAlertCallbacks 通知告警回调
func (hcs *HealthCheckSubscriber) notifyAlertCallbacks(alert HealthCheckAlert) <span class="cov6" title="28">{
        hcs.callbackMu.RLock()
        callbacks := make([]HealthCheckAlertCallback, len(hcs.alertCallbacks))
        copy(callbacks, hcs.alertCallbacks)
        hcs.callbackMu.RUnlock()

        // 从当前 context 派生，而不是使用 Background
        // 如果 ctx 为 nil，则使用 Background 作为后备
        parentCtx := hcs.ctx
        if parentCtx == nil </span><span class="cov0" title="0">{
                parentCtx = context.Background()
        }</span>

        <span class="cov6" title="28">for _, callback := range callbacks </span><span class="cov3" title="6">{
                go func(cb HealthCheckAlertCallback) </span><span class="cov3" title="6">{
                        // 使用父 context 派生，支持取消传播
                        ctx, cancel := context.WithTimeout(parentCtx, 5*time.Second)
                        defer cancel()

                        if err := cb(ctx, alert); err != nil </span><span class="cov0" title="0">{
                                logger.Error("Health check alert callback failed",
                                        "source", hcs.source,
                                        "alertType", alert.AlertType,
                                        "error", err)
                        }</span>
                }(callback)
        }
}

// RegisterAlertCallback 注册告警回调
func (hcs *HealthCheckSubscriber) RegisterAlertCallback(callback HealthCheckAlertCallback) error <span class="cov4" title="8">{
        hcs.callbackMu.Lock()
        defer hcs.callbackMu.Unlock()
        hcs.alertCallbacks = append(hcs.alertCallbacks, callback)
        return nil
}</span>

// updateStats 更新统计信息
func (hcs *HealthCheckSubscriber) updateStats(now time.Time, healthMsg *HealthCheckMessage) <span class="cov8" title="123">{
        hcs.statsMu.Lock()
        defer hcs.statsMu.Unlock()

        hcs.stats.LastMessageTime = now
        hcs.stats.TotalMessagesReceived = hcs.totalMessagesReceived.Load()
        hcs.stats.ConsecutiveMisses = hcs.consecutiveMisses.Load()
        hcs.stats.IsHealthy = hcs.stats.ConsecutiveMisses &lt; int32(hcs.config.Publisher.FailureThreshold)
        hcs.stats.UptimeSeconds = time.Since(hcs.stats.StartTime).Seconds()
}</span>

// getLastMessageTime 获取最后消息时间
func (hcs *HealthCheckSubscriber) getLastMessageTime() time.Time <span class="cov9" title="208">{
        if t := hcs.lastMessageTime.Load(); t != nil </span><span class="cov9" title="208">{
                return t.(time.Time)
        }</span>
        <span class="cov0" title="0">return time.Time{}</span>
}

// GetStats 获取统计信息
func (hcs *HealthCheckSubscriber) GetStats() HealthCheckSubscriberStats <span class="cov5" title="20">{
        hcs.statsMu.RLock()
        defer hcs.statsMu.RUnlock()

        stats := hcs.stats
        stats.TotalMessagesReceived = hcs.totalMessagesReceived.Load()
        stats.ConsecutiveMisses = hcs.consecutiveMisses.Load()
        stats.UptimeSeconds = time.Since(hcs.stats.StartTime).Seconds()

        return stats
}</span>

// IsHealthy 检查是否健康
func (hcs *HealthCheckSubscriber) IsHealthy() bool <span class="cov1" title="1">{
        misses := hcs.consecutiveMisses.Load()
        return misses &lt; int32(hcs.config.Publisher.FailureThreshold)
}</span>

// GetLastMessageTime 获取最后消息时间（公开方法）
func (hcs *HealthCheckSubscriber) GetLastMessageTime() time.Time <span class="cov0" title="0">{
        return hcs.getLastMessageTime()
}</span>

// GetConsecutiveMisses 获取连续错过次数
func (hcs *HealthCheckSubscriber) GetConsecutiveMisses() int <span class="cov0" title="0">{
        return int(hcs.consecutiveMisses.Load())
}</span>

// GetTotalMessagesReceived 获取总接收消息数
func (hcs *HealthCheckSubscriber) GetTotalMessagesReceived() int64 <span class="cov0" title="0">{
        return hcs.totalMessagesReceived.Load()
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package eventbus

import (
        "context"
        "fmt"
        "sync"
        "sync/atomic"
        "time"

        "github.com/ChenBigdata421/jxt-core/sdk/config"
        "github.com/ChenBigdata421/jxt-core/sdk/pkg/logger"
)

// HealthChecker 统一健康检查器
type HealthChecker struct {
        config       config.HealthCheckConfig
        eventBus     EventBus
        source       string // 微服务名称
        eventBusType string // 事件总线类型

        // 状态管理
        isRunning           atomic.Bool
        consecutiveFailures int32
        lastSuccessTime     atomic.Value // time.Time
        lastFailureTime     atomic.Value // time.Time

        // 控制
        ctx    context.Context
        cancel context.CancelFunc
        wg     sync.WaitGroup

        // 回调
        callbacks  []HealthCheckCallback
        callbackMu sync.RWMutex

        // 消息解析器
        parser *HealthCheckMessageParser
}

// NewHealthChecker 创建健康检查器
func NewHealthChecker(config config.HealthCheckConfig, eventBus EventBus, source, eventBusType string) *HealthChecker <span class="cov7" title="32">{
        hc := &amp;HealthChecker{
                config:       config,
                eventBus:     eventBus,
                source:       source,
                eventBusType: eventBusType,
                parser:       NewHealthCheckMessageParser(),
        }

        // 初始化时间
        hc.lastSuccessTime.Store(time.Now())
        hc.lastFailureTime.Store(time.Time{})

        // 设置默认配置
        if hc.config.Publisher.Topic == "" </span><span class="cov5" title="11">{
                hc.config.Publisher.Topic = GetHealthCheckTopic(eventBusType)
        }</span>
        <span class="cov7" title="32">if hc.config.Publisher.Interval == 0 </span><span class="cov5" title="9">{
                hc.config.Publisher.Interval = 2 * time.Minute
        }</span>
        <span class="cov7" title="32">if hc.config.Publisher.Timeout == 0 </span><span class="cov5" title="15">{
                hc.config.Publisher.Timeout = 10 * time.Second
        }</span>
        <span class="cov7" title="32">if hc.config.Publisher.FailureThreshold == 0 </span><span class="cov5" title="14">{
                hc.config.Publisher.FailureThreshold = 3
        }</span>
        <span class="cov7" title="32">if hc.config.Publisher.MessageTTL == 0 </span><span class="cov5" title="15">{
                hc.config.Publisher.MessageTTL = 5 * time.Minute
        }</span>

        <span class="cov7" title="32">return hc</span>
}

// Start 启动健康检查
func (hc *HealthChecker) Start(ctx context.Context) error <span class="cov6" title="25">{
        if hc.isRunning.Load() </span><span class="cov1" title="1">{
                return nil // 已经在运行
        }</span>

        <span class="cov6" title="24">if !hc.config.Enabled </span><span class="cov1" title="1">{
                logger.Info("Health check is disabled", "source", hc.source)
                return nil
        }</span>

        <span class="cov6" title="23">hc.ctx, hc.cancel = context.WithCancel(ctx)
        hc.isRunning.Store(true)

        hc.wg.Add(1)
        go hc.healthCheckLoop()

        logger.Info("Health checker started",
                "source", hc.source,
                "eventBusType", hc.eventBusType,
                "topic", hc.config.Publisher.Topic,
                "interval", hc.config.Publisher.Interval)

        return nil</span>
}

// Stop 停止健康检查
func (hc *HealthChecker) Stop() error <span class="cov6" title="24">{
        if !hc.isRunning.Load() </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov6" title="23">hc.cancel()
        hc.wg.Wait()
        hc.isRunning.Store(false)

        logger.Info("Health checker stopped", "source", hc.source)
        return nil</span>
}

// healthCheckLoop 健康检查循环
func (hc *HealthChecker) healthCheckLoop() <span class="cov6" title="23">{
        defer hc.wg.Done()

        ticker := time.NewTicker(hc.config.Publisher.Interval)
        defer ticker.Stop()

        // 立即执行一次健康检查
        hc.performHealthCheck()

        for </span><span class="cov10" title="139">{
                select </span>{
                case &lt;-hc.ctx.Done():<span class="cov6" title="23">
                        return</span>
                case &lt;-ticker.C:<span class="cov9" title="116">
                        hc.performHealthCheck()</span>
                }
        }
}

// performHealthCheck 执行健康检查
func (hc *HealthChecker) performHealthCheck() <span class="cov10" title="139">{
        start := time.Now()

        // 创建标准健康检查消息
        healthMsg := NewHealthCheckMessageBuilder(hc.source, hc.eventBusType).
                WithCheckType("periodic").
                WithInstanceID(hc.generateInstanceID()).
                Build()

        // 序列化消息
        msgBytes, err := healthMsg.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                hc.recordFailure(fmt.Errorf("failed to serialize health check message: %w", err), start)
                return
        }</span>

        // 创建带超时的上下文
        <span class="cov10" title="139">ctx, cancel := context.WithTimeout(hc.ctx, hc.config.Publisher.Timeout)
        defer cancel()

        // 发布健康检查消息到配置的主题
        err = hc.eventBus.Publish(ctx, hc.config.Publisher.Topic, msgBytes)

        if err != nil </span><span class="cov2" title="2">{
                hc.recordFailure(fmt.Errorf("health check publish failed: %w", err), start)
        }</span> else<span class="cov9" title="137"> {
                hc.recordSuccess(start)
        }</span>
}

// recordSuccess 记录成功
func (hc *HealthChecker) recordSuccess(startTime time.Time) <span class="cov9" title="137">{
        atomic.StoreInt32(&amp;hc.consecutiveFailures, 0)
        hc.lastSuccessTime.Store(startTime)

        result := HealthCheckResult{
                Success:             true,
                Timestamp:           startTime,
                Duration:            time.Since(startTime),
                ConsecutiveFailures: 0,
                EventBusType:        hc.eventBusType,
                Source:              hc.source,
        }

        logger.Debug("Health check succeeded",
                "source", hc.source,
                "duration", result.Duration,
                "topic", hc.config.Publisher.Topic)

        hc.notifyCallbacks(result)
}</span>

// recordFailure 记录失败
func (hc *HealthChecker) recordFailure(err error, startTime time.Time) <span class="cov2" title="2">{
        failures := atomic.AddInt32(&amp;hc.consecutiveFailures, 1)
        hc.lastFailureTime.Store(startTime)

        result := HealthCheckResult{
                Success:             false,
                Timestamp:           startTime,
                Duration:            time.Since(startTime),
                Error:               err,
                ConsecutiveFailures: int(failures),
                EventBusType:        hc.eventBusType,
                Source:              hc.source,
        }

        logger.Error("Health check failed",
                "source", hc.source,
                "error", err,
                "consecutiveFailures", failures,
                "duration", result.Duration)

        hc.notifyCallbacks(result)
}</span>

// RegisterCallback 注册回调
func (hc *HealthChecker) RegisterCallback(callback HealthCheckCallback) error <span class="cov3" title="4">{
        hc.callbackMu.Lock()
        defer hc.callbackMu.Unlock()
        hc.callbacks = append(hc.callbacks, callback)
        return nil
}</span>

// notifyCallbacks 通知回调
func (hc *HealthChecker) notifyCallbacks(result HealthCheckResult) <span class="cov10" title="139">{
        hc.callbackMu.RLock()
        callbacks := make([]HealthCheckCallback, len(hc.callbacks))
        copy(callbacks, hc.callbacks)
        hc.callbackMu.RUnlock()

        // 从当前 context 派生，而不是使用 Background
        // 如果 ctx 为 nil，则使用 Background 作为后备
        parentCtx := hc.ctx
        if parentCtx == nil </span><span class="cov0" title="0">{
                parentCtx = context.Background()
        }</span>

        <span class="cov10" title="139">for _, callback := range callbacks </span><span class="cov2" title="2">{
                go func(cb HealthCheckCallback) </span><span class="cov2" title="2">{
                        // 使用父 context 派生，支持取消传播
                        ctx, cancel := context.WithTimeout(parentCtx, 5*time.Second)
                        defer cancel()

                        if err := cb(ctx, result); err != nil </span><span class="cov0" title="0">{
                                logger.Error("Health check callback failed",
                                        "source", hc.source,
                                        "error", err)
                        }</span>
                }(callback)
        }
}

// GetStatus 获取健康状态
func (hc *HealthChecker) GetStatus() HealthCheckStatus <span class="cov6" title="16">{
        failures := atomic.LoadInt32(&amp;hc.consecutiveFailures)
        lastSuccess := hc.lastSuccessTime.Load().(time.Time)
        lastFailure := hc.lastFailureTime.Load().(time.Time)

        return HealthCheckStatus{
                IsHealthy:           failures &lt; int32(hc.config.Publisher.FailureThreshold),
                ConsecutiveFailures: int(failures),
                LastSuccessTime:     lastSuccess,
                LastFailureTime:     lastFailure,
                IsRunning:           hc.isRunning.Load(),
                EventBusType:        hc.eventBusType,
                Source:              hc.source,
        }
}</span>

// IsHealthy 检查是否健康
func (hc *HealthChecker) IsHealthy() bool <span class="cov1" title="1">{
        failures := atomic.LoadInt32(&amp;hc.consecutiveFailures)
        return failures &lt; int32(hc.config.Publisher.FailureThreshold)
}</span>

// GetConsecutiveFailures 获取连续失败次数
func (hc *HealthChecker) GetConsecutiveFailures() int <span class="cov0" title="0">{
        return int(atomic.LoadInt32(&amp;hc.consecutiveFailures))
}</span>

// GetLastSuccessTime 获取最后成功时间
func (hc *HealthChecker) GetLastSuccessTime() time.Time <span class="cov0" title="0">{
        return hc.lastSuccessTime.Load().(time.Time)
}</span>

// GetLastFailureTime 获取最后失败时间
func (hc *HealthChecker) GetLastFailureTime() time.Time <span class="cov0" title="0">{
        return hc.lastFailureTime.Load().(time.Time)
}</span>

// generateInstanceID 生成实例ID
func (hc *HealthChecker) generateInstanceID() string <span class="cov10" title="139">{
        // 这里可以使用更复杂的实例ID生成逻辑
        // 比如结合主机名、进程ID等
        return fmt.Sprintf("%s-%d", hc.source, time.Now().Unix())
}</span>

// GetDefaultHealthCheckConfig 获取默认健康检查配置
func GetDefaultHealthCheckConfig() config.HealthCheckConfig <span class="cov3" title="3">{
        return config.HealthCheckConfig{
                Enabled: true,
                Publisher: config.HealthCheckPublisherConfig{
                        Topic:            DefaultHealthCheckTopic,
                        Interval:         2 * time.Minute,
                        Timeout:          10 * time.Second,
                        FailureThreshold: 3,
                        MessageTTL:       5 * time.Minute,
                },
                Subscriber: config.HealthCheckSubscriberConfig{
                        Topic:             DefaultHealthCheckTopic,
                        MonitorInterval:   30 * time.Second,
                        WarningThreshold:  3,
                        ErrorThreshold:    5,
                        CriticalThreshold: 10,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package eventbus

import (
        "fmt"
        "time"

        "github.com/ChenBigdata421/jxt-core/sdk/config"
        "github.com/ChenBigdata421/jxt-core/sdk/pkg/logger"
)

// setDefaults 设置默认值
func setDefaults(cfg *EventBusConfig) <span class="cov6" title="7">{
        // 如果没有指定类型，默认使用内存实现
        if cfg.Type == "" </span><span class="cov3" title="3">{
                cfg.Type = "memory"
        }</span>

        // Kafka默认值
        <span class="cov6" title="7">if cfg.Type == "kafka" </span><span class="cov2" title="2">{
                if len(cfg.Kafka.Brokers) == 0 </span><span class="cov1" title="1">{
                        cfg.Kafka.Brokers = []string{"localhost:9092"}
                }</span>
                <span class="cov2" title="2">if cfg.Kafka.HealthCheckInterval == 0 </span><span class="cov2" title="2">{
                        cfg.Kafka.HealthCheckInterval = 5 * time.Minute
                }</span>
                <span class="cov2" title="2">if cfg.Kafka.Producer.RequiredAcks == 0 </span><span class="cov1" title="1">{
                        cfg.Kafka.Producer.RequiredAcks = 1
                }</span>
                <span class="cov2" title="2">if cfg.Kafka.Producer.Compression == "" </span><span class="cov2" title="2">{
                        cfg.Kafka.Producer.Compression = "snappy"
                }</span>
                <span class="cov2" title="2">if cfg.Kafka.Producer.FlushFrequency == 0 </span><span class="cov2" title="2">{
                        cfg.Kafka.Producer.FlushFrequency = 500 * time.Millisecond
                }</span>
                <span class="cov2" title="2">if cfg.Kafka.Producer.FlushMessages == 0 </span><span class="cov2" title="2">{
                        cfg.Kafka.Producer.FlushMessages = 100
                }</span>
                <span class="cov2" title="2">if cfg.Kafka.Producer.RetryMax == 0 </span><span class="cov2" title="2">{
                        cfg.Kafka.Producer.RetryMax = 3
                }</span>
                <span class="cov2" title="2">if cfg.Kafka.Producer.Timeout == 0 </span><span class="cov2" title="2">{
                        cfg.Kafka.Producer.Timeout = 10 * time.Second
                }</span>
                <span class="cov2" title="2">if cfg.Kafka.Consumer.GroupID == "" </span><span class="cov2" title="2">{
                        cfg.Kafka.Consumer.GroupID = "jxt-eventbus-group"
                }</span>
                <span class="cov2" title="2">if cfg.Kafka.Consumer.AutoOffsetReset == "" </span><span class="cov2" title="2">{
                        cfg.Kafka.Consumer.AutoOffsetReset = "earliest"
                }</span>
                <span class="cov2" title="2">if cfg.Kafka.Consumer.SessionTimeout == 0 </span><span class="cov2" title="2">{
                        cfg.Kafka.Consumer.SessionTimeout = 30 * time.Second
                }</span>
                <span class="cov2" title="2">if cfg.Kafka.Consumer.HeartbeatInterval == 0 </span><span class="cov2" title="2">{
                        cfg.Kafka.Consumer.HeartbeatInterval = 3 * time.Second
                }</span>
        }

        // NATS默认值（智能双模式）
        <span class="cov6" title="7">if cfg.Type == "nats" </span><span class="cov2" title="2">{
                if len(cfg.NATS.URLs) == 0 </span><span class="cov1" title="1">{
                        cfg.NATS.URLs = []string{"nats://localhost:4222"}
                }</span>

                <span class="cov2" title="2">if cfg.NATS.ClientID == "" </span><span class="cov1" title="1">{
                        cfg.NATS.ClientID = "jxt-client"
                }</span>
                <span class="cov2" title="2">if cfg.NATS.MaxReconnects == 0 </span><span class="cov2" title="2">{
                        cfg.NATS.MaxReconnects = 10
                }</span>
                <span class="cov2" title="2">if cfg.NATS.ReconnectWait == 0 </span><span class="cov2" title="2">{
                        cfg.NATS.ReconnectWait = 2 * time.Second
                }</span>
                <span class="cov2" title="2">if cfg.NATS.ConnectionTimeout == 0 </span><span class="cov2" title="2">{
                        cfg.NATS.ConnectionTimeout = 10 * time.Second
                }</span>
                <span class="cov2" title="2">if cfg.NATS.HealthCheckInterval == 0 </span><span class="cov2" title="2">{
                        cfg.NATS.HealthCheckInterval = 5 * time.Minute
                }</span>

                // 默认启用JetStream（可配置关闭）
                <span class="cov2" title="2">if !cfg.NATS.JetStream.Enabled </span><span class="cov2" title="2">{
                        // 如果未明确配置，默认启用JetStream
                        cfg.NATS.JetStream.Enabled = true
                }</span>

                // JetStream默认配置（仅在启用时设置）
                <span class="cov2" title="2">if cfg.NATS.JetStream.Enabled </span><span class="cov2" title="2">{
                        if cfg.NATS.JetStream.Stream.Name == "" </span><span class="cov2" title="2">{
                                cfg.NATS.JetStream.Stream.Name = "JXT_STREAM"
                        }</span>
                        <span class="cov2" title="2">if len(cfg.NATS.JetStream.Stream.Subjects) == 0 </span><span class="cov2" title="2">{
                                cfg.NATS.JetStream.Stream.Subjects = []string{"persistent.&gt;", "order.&gt;", "payment.&gt;", "audit.&gt;", "critical.&gt;", "durable.&gt;"}
                        }</span>
                        <span class="cov2" title="2">if cfg.NATS.JetStream.Stream.Retention == "" </span><span class="cov2" title="2">{
                                cfg.NATS.JetStream.Stream.Retention = "limits"
                        }</span>
                        <span class="cov2" title="2">if cfg.NATS.JetStream.Stream.Storage == "" </span><span class="cov2" title="2">{
                                cfg.NATS.JetStream.Stream.Storage = "file"
                        }</span>
                        <span class="cov2" title="2">if cfg.NATS.JetStream.Consumer.DurableName == "" </span><span class="cov2" title="2">{
                                cfg.NATS.JetStream.Consumer.DurableName = "jxt-consumer"
                        }</span>
                        <span class="cov2" title="2">if cfg.NATS.JetStream.Consumer.AckPolicy == "" </span><span class="cov2" title="2">{
                                cfg.NATS.JetStream.Consumer.AckPolicy = "explicit"
                        }</span>
                }
        }

        // Metrics默认值
        <span class="cov6" title="7">if cfg.Metrics.CollectInterval == 0 </span><span class="cov6" title="7">{
                cfg.Metrics.CollectInterval = 30 * time.Second
        }</span>

        // Tracing默认值
        <span class="cov6" title="7">if cfg.Tracing.SampleRate == 0 </span><span class="cov6" title="7">{
                cfg.Tracing.SampleRate = 0.1
        }</span>
}

// ==========================================================================
// 新配置结构支持
// ==========================================================================

// InitializeFromConfig 从配置初始化事件总线
func InitializeFromConfig(cfg *config.EventBusConfig) error <span class="cov9" title="25">{
        if cfg == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("eventbus config is required")
        }</span>

        // 设置默认值（必须在验证之前）
        <span class="cov9" title="24">cfg.SetDefaults()

        // 验证配置
        if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid unified config: %w", err)
        }</span>

        // 设置全局配置
        <span class="cov9" title="24">SetGlobalConfig(cfg)

        // 转换配置
        eventBusConfig := convertConfig(cfg)

        // 初始化全局事件总线
        if err := InitializeGlobal(eventBusConfig); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize eventbus from unified config: %w", err)
        }</span>

        <span class="cov9" title="24">logger.Info("EventBus initialized from unified config successfully",
                "type", cfg.Type,
                "serviceName", cfg.ServiceName,
                "healthCheckEnabled", cfg.HealthCheck.Enabled,
                "publisherConfigured", cfg.Publisher.PublishTimeout &gt; 0,
                "subscriberConfigured", cfg.Subscriber.MaxConcurrency &gt; 0)
        return nil</span>
}

// convertConfig 转换配置格式
func convertConfig(cfg *config.EventBusConfig) *EventBusConfig <span class="cov10" title="28">{
        eventBusConfig := &amp;EventBusConfig{
                Type: cfg.Type,
        }

        // 转换健康检查配置到企业特性
        eventBusConfig.Enterprise.HealthCheck = HealthCheckConfig{
                Enabled:          cfg.HealthCheck.Enabled,
                Topic:            cfg.HealthCheck.Publisher.Topic,
                Interval:         cfg.HealthCheck.Publisher.Interval,
                Timeout:          cfg.HealthCheck.Publisher.Timeout,
                FailureThreshold: cfg.HealthCheck.Publisher.FailureThreshold,
                MessageTTL:       cfg.HealthCheck.Publisher.MessageTTL,
        }

        // 转换发布端企业特性（根据现有结构）
        eventBusConfig.Enterprise.Publisher = PublisherEnterpriseConfig{
                BacklogDetection: cfg.Publisher.BacklogDetection,
                MessageFormatter: MessageFormatterConfig{
                        Enabled: true,
                        Type:    "json", // 默认使用JSON格式
                },
                PublishCallback: PublishCallbackConfig{
                        Enabled: false, // 默认关闭
                },
                RetryPolicy: RetryPolicyConfig{
                        Enabled:         cfg.Publisher.MaxReconnectAttempts &gt; 0,
                        MaxRetries:      cfg.Publisher.MaxReconnectAttempts,
                        InitialInterval: cfg.Publisher.InitialBackoff,
                        MaxInterval:     cfg.Publisher.MaxBackoff,
                        Multiplier:      2.0, // 默认倍数
                },
        }

        // 转换订阅端企业特性（根据现有结构）
        eventBusConfig.Enterprise.Subscriber = SubscriberEnterpriseConfig{
                BacklogDetection: cfg.Subscriber.BacklogDetection,
                RateLimit: RateLimitConfig{
                        RatePerSecond: cfg.Subscriber.RateLimit.RatePerSecond,
                        BurstSize:     cfg.Subscriber.RateLimit.BurstSize,
                },
                DeadLetter: DeadLetterConfig{
                        Enabled:    cfg.Subscriber.ErrorHandling.DeadLetterTopic != "",
                        Topic:      cfg.Subscriber.ErrorHandling.DeadLetterTopic,
                        MaxRetries: cfg.Subscriber.ErrorHandling.MaxRetryAttempts,
                },
                MessageRouter: MessageRouterConfig{
                        Enabled: false,  // 默认关闭
                        Type:    "hash", // 默认哈希路由
                },
                ErrorHandler: ErrorHandlerConfig{
                        Enabled: cfg.Subscriber.ErrorHandling.MaxRetryAttempts &gt; 0,
                        Type:    "retry", // 默认重试策略
                },
        }

        // 转换监控配置
        eventBusConfig.Metrics = MetricsConfig{
                Enabled:         cfg.Monitoring.Enabled,
                CollectInterval: cfg.Monitoring.CollectInterval,
                ExportEndpoint:  cfg.Monitoring.ExportEndpoint,
        }

        // 根据类型转换特定配置
        switch cfg.Type </span>{
        case "kafka":<span class="cov2" title="2">
                eventBusConfig.Kafka = KafkaConfig{
                        Brokers: cfg.Kafka.Brokers,
                        Producer: ProducerConfig{
                                RequiredAcks:   cfg.Kafka.Producer.RequiredAcks,
                                Compression:    cfg.Kafka.Producer.Compression,
                                FlushFrequency: cfg.Kafka.Producer.FlushFrequency,
                                FlushMessages:  cfg.Kafka.Producer.FlushMessages,
                                RetryMax:       cfg.Kafka.Producer.RetryMax,
                                Timeout:        cfg.Kafka.Producer.Timeout,
                                BatchSize:      cfg.Kafka.Producer.BatchSize,
                                BufferSize:     cfg.Kafka.Producer.BufferSize,
                        },
                        Consumer: ConsumerConfig{
                                GroupID:           cfg.Kafka.Consumer.GroupID,
                                AutoOffsetReset:   cfg.Kafka.Consumer.AutoOffsetReset,
                                SessionTimeout:    cfg.Kafka.Consumer.SessionTimeout,
                                HeartbeatInterval: cfg.Kafka.Consumer.HeartbeatInterval,
                                MaxProcessingTime: cfg.Kafka.Consumer.MaxProcessingTime,
                                FetchMinBytes:     cfg.Kafka.Consumer.FetchMinBytes,
                                FetchMaxBytes:     cfg.Kafka.Consumer.FetchMaxBytes,
                                FetchMaxWait:      cfg.Kafka.Consumer.FetchMaxWait,
                        },
                        Security: SecurityConfig{
                                Enabled:  cfg.Security.Enabled,
                                Protocol: cfg.Security.Protocol,
                                Username: cfg.Security.Username,
                                Password: cfg.Security.Password,
                                CertFile: cfg.Security.CertFile,
                                KeyFile:  cfg.Security.KeyFile,
                                CAFile:   cfg.Security.CAFile,
                        },
                }</span>
        case "nats":<span class="cov1" title="1">
                eventBusConfig.NATS = NATSConfig{
                        URLs:              cfg.NATS.URLs,
                        ClientID:          cfg.NATS.ClientID,
                        MaxReconnects:     cfg.NATS.MaxReconnects,
                        ReconnectWait:     cfg.NATS.ReconnectWait,
                        ConnectionTimeout: cfg.NATS.ConnectionTimeout,
                        // JetStream配置需要单独转换，这里先使用基本配置
                        JetStream: JetStreamConfig{
                                Enabled: cfg.NATS.JetStream.Enabled,
                                Domain:  cfg.NATS.JetStream.Domain,
                        },
                        Security: NATSSecurityConfig{
                                Enabled:  cfg.Security.Enabled,
                                Username: cfg.Security.Username,
                                Password: cfg.Security.Password,
                                CertFile: cfg.Security.CertFile,
                                KeyFile:  cfg.Security.KeyFile,
                                CAFile:   cfg.Security.CAFile,
                        },
                }</span>
        }

        <span class="cov10" title="28">return eventBusConfig</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package eventbus

import (
        "encoding/json"

        jsoniter "github.com/json-iterator/go"
)

// JSON 统一的 jsoniter 配置实例
// 使用 ConfigCompatibleWithStandardLibrary 确保与标准库完全兼容
// 同时获得更高的性能
var JSON = jsoniter.ConfigCompatibleWithStandardLibrary

// JSONFast 高性能 jsoniter 配置实例
// 使用 ConfigFastest 获得最高性能，但可能在某些边缘情况下与标准库不完全兼容
// 适用于性能敏感的场景
var JSONFast = jsoniter.ConfigFastest

// JSONDefault 默认 jsoniter 配置实例
// 使用 ConfigDefault 平衡性能和兼容性
var JSONDefault = jsoniter.ConfigDefault

// 性能优化说明：
//
// 1. ConfigCompatibleWithStandardLibrary:
//    - 与标准库 encoding/json 100% 兼容
//    - 性能提升约 2-3 倍
//    - 推荐用于需要完全兼容性的场景
//
// 2. ConfigFastest:
//    - 最高性能，提升约 5-10 倍
//    - 可能在某些边缘情况下行为略有不同
//    - 推荐用于性能敏感且数据格式可控的场景
//
// 3. ConfigDefault:
//    - 平衡性能和兼容性
//    - 性能提升约 3-5 倍
//    - 推荐用于大多数场景

// MarshalToString 将对象序列化为 JSON 字符串
// 使用 jsoniter 的高性能 API
func MarshalToString(v interface{}) (string, error) <span class="cov2" title="3">{
        return JSON.MarshalToString(v)
}</span>

// UnmarshalFromString 从 JSON 字符串反序列化对象
// 使用 jsoniter 的高性能 API
func UnmarshalFromString(str string, v interface{}) error <span class="cov2" title="3">{
        return JSON.UnmarshalFromString(str, v)
}</span>

// Marshal 序列化对象为 JSON 字节数组
// 兼容标准库 json.Marshal 接口
// 暂时使用标准库避免jsoniter的map序列化问题
func Marshal(v interface{}) ([]byte, error) <span class="cov8" title="168">{
        // 使用标准库JSON避免jsoniter在某些Go版本中的map序列化问题
        return json.Marshal(v)
}</span>

// Unmarshal 从 JSON 字节数组反序列化对象
// 兼容标准库 json.Unmarshal 接口
func Unmarshal(data []byte, v interface{}) error <span class="cov10" title="414">{
        return json.Unmarshal(data, v)
}</span>

// MarshalFast 使用最高性能配置序列化对象
// 适用于性能敏感的场景
func MarshalFast(v interface{}) ([]byte, error) <span class="cov2" title="2">{
        return JSONFast.Marshal(v)
}</span>

// UnmarshalFast 使用最高性能配置反序列化对象
// 适用于性能敏感的场景
func UnmarshalFast(data []byte, v interface{}) error <span class="cov2" title="2">{
        return JSONFast.Unmarshal(data, v)
}</span>

// RawMessage jsoniter 兼容的 RawMessage 类型
// 与标准库 json.RawMessage 完全兼容
type RawMessage = jsoniter.RawMessage

// 使用示例：
//
// 1. 基本使用（兼容标准库）：
//    data, err := eventbus.Marshal(obj)
//    err = eventbus.Unmarshal(data, &amp;obj)
//
// 2. 高性能使用：
//    data, err := eventbus.MarshalFast(obj)
//    err = eventbus.UnmarshalFast(data, &amp;obj)
//
// 3. 字符串操作（避免字节数组转换）：
//    str, err := eventbus.MarshalToString(obj)
//    err = eventbus.UnmarshalFromString(str, &amp;obj)
//
// 4. RawMessage 使用：
//    type Message struct {
//        Data eventbus.RawMessage `json:"data"`
//    }
</pre>
		
		<pre class="file" id="file9" style="display: none">package eventbus

import (
        "context"
        "fmt"
        "sync"
        "sync/atomic"
        "time"

        "github.com/ChenBigdata421/jxt-core/sdk/config"
        "github.com/ChenBigdata421/jxt-core/sdk/pkg/logger"
        "github.com/IBM/sarama"
        "go.uber.org/zap"
)

// ReconnectConfig 重连配置
type ReconnectConfig struct {
        MaxAttempts      int           // 最大重连次数
        InitialBackoff   time.Duration // 初始退避时间
        MaxBackoff       time.Duration // 最大退避时间
        BackoffFactor    float64       // 退避因子
        FailureThreshold int           // 触发重连的连续失败次数
}

// DefaultReconnectConfig 默认重连配置
func DefaultReconnectConfig() ReconnectConfig <span class="cov4" title="19">{
        return ReconnectConfig{
                MaxAttempts:      DefaultMaxReconnectAttempts,
                InitialBackoff:   DefaultReconnectInitialBackoff,
                MaxBackoff:       DefaultReconnectMaxBackoff,
                BackoffFactor:    DefaultReconnectBackoffFactor,
                FailureThreshold: DefaultReconnectFailureThreshold,
        }
}</span>

// kafkaEventBus Kafka事件总线实现
// 企业级增强版本，集成积压检测、流量控制、聚合处理等特性
// 支持方案A（Envelope）消息包络
type kafkaEventBus struct {
        config   *config.KafkaConfig
        producer sarama.SyncProducer
        consumer sarama.Consumer
        client   sarama.Client
        admin    sarama.ClusterAdmin
        logger   *zap.Logger
        mu       sync.RWMutex
        closed   bool

        // 企业级特性
        backlogDetector          *BacklogDetector          // 订阅端积压检测器
        publisherBacklogDetector *PublisherBacklogDetector // 发送端积压检测器
        rateLimiter              *RateLimiter

        // 完整配置（用于访问 Publisher/Subscriber 配置）
        fullConfig *EventBusConfig

        messageFormatter MessageFormatter
        publishCallback  PublishCallback
        errorHandler     ErrorHandler
        messageRouter    MessageRouter

        // 统计信息
        publishedMessages atomic.Int64
        consumedMessages  atomic.Int64
        errorCount        atomic.Int64

        // 健康检查控制
        healthCheckCancel context.CancelFunc
        healthCheckDone   chan struct{}

        // 健康检查订阅监控器
        healthCheckSubscriber *HealthCheckSubscriber
        // 健康检查发布器
        healthChecker *HealthChecker

        // 自动重连控制
        reconnectConfig   ReconnectConfig
        failureCount      atomic.Int32
        lastReconnectTime atomic.Value // time.Time
        reconnectCallback ReconnectCallback

        // 订阅管理（用于重连后恢复订阅）
        subscriptions   map[string]MessageHandler // topic -&gt; handler
        subscriptionsMu sync.RWMutex

        // Keyed worker pools (per topic)
        keyedPools   map[string]*KeyedWorkerPool
        keyedPoolsMu sync.RWMutex

        // 主题配置管理
        topicConfigs          map[string]TopicOptions
        topicConfigsMu        sync.RWMutex
        topicConfigStrategy   TopicConfigStrategy       // 配置策略
        topicConfigOnMismatch TopicConfigMismatchAction // 配置不一致时的行为
}

// NewKafkaEventBus 创建企业级Kafka事件总线
func NewKafkaEventBus(cfg *config.KafkaConfig) (EventBus, error) <span class="cov4" title="11">{
        return NewKafkaEventBusWithFullConfig(cfg, nil)
}</span>

// NewKafkaEventBusWithFullConfig 创建企业级Kafka事件总线（带完整配置）
func NewKafkaEventBusWithFullConfig(cfg *config.KafkaConfig, fullConfig *EventBusConfig) (EventBus, error) <span class="cov4" title="11">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("kafka config cannot be nil")
        }</span>

        <span class="cov4" title="10">if len(cfg.Brokers) == 0 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("kafka brokers cannot be empty")
        }</span>

        // 创建Sarama配置
        <span class="cov3" title="9">saramaConfig := sarama.NewConfig()
        if err := configureSarama(saramaConfig, cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to configure sarama: %w", err)
        }</span>

        // 创建客户端
        <span class="cov3" title="9">client, err := sarama.NewClient(cfg.Brokers, saramaConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create kafka client: %w", err)
        }</span>

        // 创建生产者
        <span class="cov3" title="9">producer, err := sarama.NewSyncProducerFromClient(client)
        if err != nil </span><span class="cov0" title="0">{
                client.Close()
                return nil, fmt.Errorf("failed to create kafka producer: %w", err)
        }</span>

        // 创建消费者
        <span class="cov3" title="9">consumer, err := sarama.NewConsumerFromClient(client)
        if err != nil </span><span class="cov0" title="0">{
                producer.Close()
                client.Close()
                return nil, fmt.Errorf("failed to create kafka consumer: %w", err)
        }</span>

        // 创建管理客户端
        <span class="cov3" title="9">admin, err := sarama.NewClusterAdminFromClient(client)
        if err != nil </span><span class="cov0" title="0">{
                consumer.Close()
                producer.Close()
                client.Close()
                return nil, fmt.Errorf("failed to create kafka admin: %w", err)
        }</span>

        // 获取配置策略（从环境变量或使用默认值）
        <span class="cov3" title="9">configStrategy := StrategyCreateOrUpdate
        configOnMismatch := TopicConfigMismatchAction{
                LogLevel: "warn",
                FailFast: false,
        }

        // 创建EventBus实例
        eventBus := &amp;kafkaEventBus{
                config:                cfg,
                fullConfig:            fullConfig,
                producer:              producer,
                consumer:              consumer,
                client:                client,
                admin:                 admin,
                logger:                logger.Logger,
                reconnectConfig:       DefaultReconnectConfig(),
                subscriptions:         make(map[string]MessageHandler),
                keyedPools:            make(map[string]*KeyedWorkerPool),
                topicConfigs:          make(map[string]TopicOptions),
                topicConfigStrategy:   configStrategy,
                topicConfigOnMismatch: configOnMismatch,
        }

        // 初始化时间戳
        eventBus.lastReconnectTime.Store(time.Time{})

        // 初始化企业级特性
        if err := eventBus.initEnterpriseFeatures(); err != nil </span><span class="cov0" title="0">{
                eventBus.Close()
                return nil, fmt.Errorf("failed to initialize enterprise features: %w", err)
        }</span>

        <span class="cov3" title="9">return eventBus, nil</span>
}

// configureSarama 配置Sarama
func configureSarama(config *sarama.Config, cfg *config.KafkaConfig) error <span class="cov5" title="20">{
        // 生产者配置
        config.Producer.RequiredAcks = sarama.RequiredAcks(cfg.Producer.RequiredAcks)
        config.Producer.Timeout = cfg.Producer.Timeout
        config.Producer.Retry.Max = cfg.Producer.RetryMax
        config.Producer.Return.Successes = true
        config.Producer.Return.Errors = true

        // 设置压缩算法
        switch cfg.Producer.Compression </span>{
        case "gzip":<span class="cov1" title="2">
                config.Producer.Compression = sarama.CompressionGZIP</span>
        case "snappy":<span class="cov1" title="1">
                config.Producer.Compression = sarama.CompressionSnappy</span>
        case "lz4":<span class="cov1" title="1">
                config.Producer.Compression = sarama.CompressionLZ4</span>
        case "zstd":<span class="cov1" title="1">
                config.Producer.Compression = sarama.CompressionZSTD</span>
        default:<span class="cov4" title="15">
                config.Producer.Compression = sarama.CompressionNone</span>
        }

        // 幂等性配置
        <span class="cov5" title="20">config.Producer.Idempotent = cfg.Producer.Idempotent
        if cfg.Producer.Idempotent </span><span class="cov0" title="0">{
                config.Producer.RequiredAcks = sarama.WaitForAll
                config.Producer.Retry.Max = 5
                config.Net.MaxOpenRequests = 1
        }</span>

        // 批处理配置
        <span class="cov5" title="20">if cfg.Producer.FlushFrequency &gt; 0 </span><span class="cov0" title="0">{
                config.Producer.Flush.Frequency = cfg.Producer.FlushFrequency
        }</span>
        <span class="cov5" title="20">if cfg.Producer.FlushMessages &gt; 0 </span><span class="cov0" title="0">{
                config.Producer.Flush.Messages = cfg.Producer.FlushMessages
        }</span>
        <span class="cov5" title="20">if cfg.Producer.FlushBytes &gt; 0 </span><span class="cov0" title="0">{
                config.Producer.Flush.Bytes = cfg.Producer.FlushBytes
        }</span>

        // 消费者配置
        <span class="cov5" title="20">config.Consumer.Group.Session.Timeout = cfg.Consumer.SessionTimeout
        config.Consumer.Group.Heartbeat.Interval = cfg.Consumer.HeartbeatInterval
        config.Consumer.MaxProcessingTime = cfg.Consumer.MaxProcessingTime
        config.Consumer.Fetch.Min = int32(cfg.Consumer.FetchMinBytes)
        config.Consumer.Fetch.Max = int32(cfg.Consumer.FetchMaxBytes)
        config.Consumer.MaxWaitTime = cfg.Consumer.FetchMaxWait

        // 设置偏移量重置策略
        switch cfg.Consumer.AutoOffsetReset </span>{
        case "earliest":<span class="cov4" title="18">
                config.Consumer.Offsets.Initial = sarama.OffsetOldest</span>
        case "latest":<span class="cov1" title="1">
                config.Consumer.Offsets.Initial = sarama.OffsetNewest</span>
        default:<span class="cov1" title="1">
                config.Consumer.Offsets.Initial = sarama.OffsetNewest</span>
        }

        // 网络配置
        <span class="cov5" title="20">if cfg.Net.DialTimeout &gt; 0 </span><span class="cov0" title="0">{
                config.Net.DialTimeout = cfg.Net.DialTimeout
        }</span>
        <span class="cov5" title="20">if cfg.Net.ReadTimeout &gt; 0 </span><span class="cov0" title="0">{
                config.Net.ReadTimeout = cfg.Net.ReadTimeout
        }</span>
        <span class="cov5" title="20">if cfg.Net.WriteTimeout &gt; 0 </span><span class="cov0" title="0">{
                config.Net.WriteTimeout = cfg.Net.WriteTimeout
        }</span>

        // 版本配置
        <span class="cov5" title="20">config.Version = sarama.V2_6_0_0

        return nil</span>
}

// kafkaConsumerHandler Kafka消费者处理器
type kafkaConsumerHandler struct {
        eventBus *kafkaEventBus
        handler  MessageHandler
        topic    string
}

// Setup 消费者组设置
func (h *kafkaConsumerHandler) Setup(sarama.ConsumerGroupSession) error <span class="cov3" title="9">{
        return nil
}</span>

// Cleanup 消费者组清理
func (h *kafkaConsumerHandler) Cleanup(sarama.ConsumerGroupSession) error <span class="cov3" title="9">{
        return nil
}</span>

// ConsumeClaim 消费消息
func (h *kafkaConsumerHandler) ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error <span class="cov3" title="8">{
        for </span><span class="cov7" title="157">{
                select </span>{
                case message := &lt;-claim.Messages():<span class="cov7" title="149">
                        if message == nil </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        // 处理消息
                        <span class="cov7" title="149">if err := h.processMessage(session.Context(), message); err != nil </span><span class="cov4" title="17">{
                                h.eventBus.logger.Error("Failed to process message",
                                        zap.String("topic", message.Topic),
                                        zap.Int32("partition", message.Partition),
                                        zap.Int64("offset", message.Offset),
                                        zap.Error(err))
                                h.eventBus.errorCount.Add(1)
                        }</span> else<span class="cov7" title="132"> {
                                h.eventBus.consumedMessages.Add(1)
                                session.MarkMessage(message, "")
                        }</span>

                case &lt;-session.Context().Done():<span class="cov3" title="8">
                        return nil</span>
                }
        }
}

// processMessage 处理单个消息
func (h *kafkaConsumerHandler) processMessage(ctx context.Context, message *sarama.ConsumerMessage) error <span class="cov7" title="149">{
        // 流量控制
        if h.eventBus.rateLimiter != nil </span><span class="cov0" title="0">{
                if err := h.eventBus.rateLimiter.Wait(ctx); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("rate limit error: %w", err)
                }</span>
        }

        // ⭐ 智能路由决策：根据聚合ID提取结果决定处理模式
        // 构建headers映射
        <span class="cov7" title="149">headersMap := make(map[string]string, len(message.Headers))
        for _, header := range message.Headers </span><span class="cov0" title="0">{
                headersMap[string(header.Key)] = string(header.Value)
        }</span>

        // 尝试提取聚合ID（优先级：Envelope &gt; Header &gt; Kafka Key）
        <span class="cov7" title="149">aggregateID, _ := ExtractAggregateID(message.Value, headersMap, message.Key, "")
        if aggregateID != "" </span><span class="cov0" title="0">{
                // ✅ 有聚合ID：使用Keyed-Worker池进行顺序处理
                // 这种情况通常发生在：
                // 1. SubscribeEnvelope订阅的Envelope消息
                // 2. 手动在Header中设置了聚合ID的消息
                // 3. Kafka Key恰好是有效的聚合ID
                // 获取该 topic 的 keyed 池
                h.eventBus.keyedPoolsMu.RLock()
                pool := h.eventBus.keyedPools[h.topic]
                h.eventBus.keyedPoolsMu.RUnlock()
                if pool != nil </span><span class="cov0" title="0">{
                        // 使用 Keyed-Worker 池处理
                        aggMsg := &amp;AggregateMessage{
                                Topic:       message.Topic,
                                Partition:   message.Partition,
                                Offset:      message.Offset,
                                Key:         message.Key,
                                Value:       message.Value,
                                Headers:     make(map[string][]byte),
                                Timestamp:   message.Timestamp,
                                AggregateID: aggregateID,
                                Context:     ctx,
                                Done:        make(chan error, 1),
                        }
                        for _, header := range message.Headers </span><span class="cov0" title="0">{
                                aggMsg.Headers[string(header.Key)] = header.Value
                        }</span>
                        <span class="cov0" title="0">if err := pool.ProcessMessage(ctx, aggMsg); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">select </span>{
                        case err := &lt;-aggMsg.Done:<span class="cov0" title="0">
                                return err</span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return ctx.Err()</span>
                        }
                }
        }

        // ❌ 无聚合ID：直接并发处理（不使用Keyed-Worker池）
        // 这种情况通常发生在：
        // 1. Subscribe订阅的原始消息（如JSON、文本等）
        // 2. 无法从消息中提取有效聚合ID的情况
        // 3. 简单消息传递场景（通知、缓存失效等）
        <span class="cov7" title="149">return h.handler(ctx, message.Value)</span>
}

// initEnterpriseFeatures 初始化企业级特性
func (k *kafkaEventBus) initEnterpriseFeatures() error <span class="cov3" title="9">{
        // 如果没有完整配置，使用默认配置
        if k.fullConfig == nil </span><span class="cov3" title="9">{
                k.logger.Info("No full config available, skipping enterprise features")
                return nil
        }</span>

        // 初始化订阅端积压检测器
        <span class="cov0" title="0">if k.fullConfig.Enterprise.Subscriber.BacklogDetection.Enabled </span><span class="cov0" title="0">{
                backlogConfig := BacklogDetectionConfig{
                        MaxLagThreshold:  k.fullConfig.Enterprise.Subscriber.BacklogDetection.MaxLagThreshold,
                        MaxTimeThreshold: k.fullConfig.Enterprise.Subscriber.BacklogDetection.MaxTimeThreshold,
                        CheckInterval:    k.fullConfig.Enterprise.Subscriber.BacklogDetection.CheckInterval,
                }
                k.backlogDetector = NewBacklogDetector(k.client, k.admin, k.config.Consumer.GroupID, backlogConfig)
                k.logger.Info("Subscriber backlog detector initialized",
                        zap.Int64("maxLagThreshold", backlogConfig.MaxLagThreshold),
                        zap.Duration("maxTimeThreshold", backlogConfig.MaxTimeThreshold),
                        zap.Duration("checkInterval", backlogConfig.CheckInterval))
        }</span>

        // 初始化发送端积压检测器
        <span class="cov0" title="0">if k.fullConfig.Enterprise.Publisher.BacklogDetection.Enabled </span><span class="cov0" title="0">{
                k.publisherBacklogDetector = NewPublisherBacklogDetector(k.client, k.admin, k.fullConfig.Enterprise.Publisher.BacklogDetection)
                k.logger.Info("Publisher backlog detector initialized",
                        zap.Int64("maxQueueDepth", k.fullConfig.Enterprise.Publisher.BacklogDetection.MaxQueueDepth),
                        zap.Duration("maxPublishLatency", k.fullConfig.Enterprise.Publisher.BacklogDetection.MaxPublishLatency),
                        zap.Float64("rateThreshold", k.fullConfig.Enterprise.Publisher.BacklogDetection.RateThreshold),
                        zap.Duration("checkInterval", k.fullConfig.Enterprise.Publisher.BacklogDetection.CheckInterval))
        }</span>

        <span class="cov0" title="0">k.logger.Info("Enterprise features initialized successfully")
        return nil</span>
}

// Kafka EventBus 实现

// Publish 发布消息
func (k *kafkaEventBus) Publish(ctx context.Context, topic string, message []byte) error <span class="cov7" title="133">{
        k.mu.RLock()
        defer k.mu.RUnlock()

        if k.closed </span><span class="cov0" title="0">{
                return fmt.Errorf("kafka eventbus is closed")
        }</span>

        // 流量控制
        <span class="cov7" title="133">if k.rateLimiter != nil </span><span class="cov0" title="0">{
                if err := k.rateLimiter.Wait(ctx); err != nil </span><span class="cov0" title="0">{
                        k.errorCount.Add(1)
                        return fmt.Errorf("rate limit error: %w", err)
                }</span>
        }

        // 创建Kafka消息
        <span class="cov7" title="133">msg := &amp;sarama.ProducerMessage{
                Topic: topic,
                Value: sarama.ByteEncoder(message),
        }

        // 发送消息
        partition, offset, err := k.producer.SendMessage(msg)
        if err != nil </span><span class="cov0" title="0">{
                k.errorCount.Add(1)
                k.logger.Error("Failed to publish message",
                        zap.String("topic", topic),
                        zap.Error(err))
                return fmt.Errorf("failed to publish message: %w", err)
        }</span>

        <span class="cov7" title="133">k.publishedMessages.Add(1)
        k.logger.Debug("Message published successfully",
                zap.String("topic", topic),
                zap.Int32("partition", partition),
                zap.Int64("offset", offset))

        return nil</span>
}

// Subscribe 订阅原始消息（不使用Keyed-Worker池）
//
// 特点：
// - 消息格式：原始字节数据
// - 处理模式：直接并发处理，无顺序保证
// - 性能：极致性能，微秒级延迟
// - 聚合ID：通常无法从原始消息中提取聚合ID
// - Keyed-Worker池：不使用（因为无聚合ID）
//
// 适用场景：
// - 简单消息传递（通知、提醒）
// - 缓存失效消息
// - 系统监控指标
// - 不需要顺序保证的业务场景
//
// 示例：
//
//        bus.Subscribe(ctx, "notifications", func(ctx context.Context, data []byte) error {
//            var notification Notification
//            json.Unmarshal(data, &amp;notification)
//            return processNotification(notification) // 直接并发处理
//        })
func (k *kafkaEventBus) Subscribe(ctx context.Context, topic string, handler MessageHandler) error <span class="cov3" title="9">{
        k.mu.RLock()
        defer k.mu.RUnlock()

        if k.closed </span><span class="cov0" title="0">{
                return fmt.Errorf("kafka eventbus is closed")
        }</span>

        // 创建消费者组
        <span class="cov3" title="9">consumerGroup, err := sarama.NewConsumerGroupFromClient(k.config.Consumer.GroupID, k.client)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create consumer group: %w", err)
        }</span>

        // 创建消费者处理器
        <span class="cov3" title="9">consumerHandler := &amp;kafkaConsumerHandler{
                eventBus: k,
                handler:  handler,
                topic:    topic,
        }

        // 启动消费循环
        go func() </span><span class="cov3" title="9">{
                defer consumerGroup.Close()

                for </span><span class="cov10" title="812">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                k.logger.Info("Consumer context cancelled", zap.String("topic", topic))
                                return</span>
                        default:<span class="cov10" title="812">
                                if err := consumerGroup.Consume(ctx, []string{topic}, consumerHandler); err != nil </span><span class="cov9" title="803">{
                                        k.logger.Error("Consumer group consume error",
                                                zap.String("topic", topic),
                                                zap.Error(err))
                                        time.Sleep(time.Second) // 避免快速重试
                                }</span>
                        }
                }
        }()

        // 记录订阅信息（用于重连后恢复）
        <span class="cov3" title="9">k.subscriptionsMu.Lock()
        k.subscriptions[topic] = handler
        k.subscriptionsMu.Unlock()

        // Create per-topic Keyed-Worker pool (Phase 1)
        k.keyedPoolsMu.Lock()
        if _, ok := k.keyedPools[topic]; !ok </span><span class="cov3" title="9">{
                pool := NewKeyedWorkerPool(KeyedWorkerPoolConfig{
                        WorkerCount: 1024,
                        QueueSize:   1000,
                        WaitTimeout: 200 * time.Millisecond,
                }, handler)
                k.keyedPools[topic] = pool
        }</span>
        <span class="cov3" title="9">k.keyedPoolsMu.Unlock()

        k.logger.Info("Subscribed to topic", zap.String("topic", topic), zap.String("groupID", k.config.Consumer.GroupID))
        return nil</span>
}

// healthCheck 内部健康检查（不对外暴露）
func (k *kafkaEventBus) healthCheck(ctx context.Context) error <span class="cov0" title="0">{
        k.mu.Lock()
        defer k.mu.Unlock()

        if k.closed </span><span class="cov0" title="0">{
                return fmt.Errorf("kafka eventbus is closed")
        }</span>

        // 检查客户端连接
        <span class="cov0" title="0">if !k.client.Closed() </span><span class="cov0" title="0">{
                // 尝试获取broker信息
                brokers := k.client.Brokers()
                if len(brokers) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("no available brokers")
                }</span>

                // 检查至少一个broker是否可达
                <span class="cov0" title="0">for _, broker := range brokers </span><span class="cov0" title="0">{
                        if connected, _ := broker.Connected(); connected </span><span class="cov0" title="0">{
                                k.logger.Debug("Kafka eventbus health check passed",
                                        zap.Int("brokers", len(brokers)),
                                        zap.String("connectedBroker", broker.Addr()))
                                return nil
                        }</span>
                }

                <span class="cov0" title="0">return fmt.Errorf("no connected brokers available")</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("kafka client is closed")</span>
}

// CheckConnection 检查 Kafka 连接状态
func (k *kafkaEventBus) CheckConnection(ctx context.Context) error <span class="cov0" title="0">{
        k.mu.RLock()
        defer k.mu.RUnlock()

        if k.closed </span><span class="cov0" title="0">{
                return fmt.Errorf("kafka eventbus is closed")
        }</span>

        <span class="cov0" title="0">if k.client.Closed() </span><span class="cov0" title="0">{
                return fmt.Errorf("kafka client is closed")
        }</span>

        // 检查 broker 连接
        <span class="cov0" title="0">brokers := k.client.Brokers()
        if len(brokers) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no available brokers")
        }</span>

        <span class="cov0" title="0">connectedBrokers := 0
        for _, broker := range brokers </span><span class="cov0" title="0">{
                if connected, _ := broker.Connected(); connected </span><span class="cov0" title="0">{
                        connectedBrokers++
                }</span>
        }

        <span class="cov0" title="0">if connectedBrokers == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no connected brokers available")
        }</span>

        <span class="cov0" title="0">k.logger.Debug("Kafka connection check passed",
                zap.Int("totalBrokers", len(brokers)),
                zap.Int("connectedBrokers", connectedBrokers))

        return nil</span>
}

// CheckMessageTransport 检查端到端消息传输
func (k *kafkaEventBus) CheckMessageTransport(ctx context.Context) error <span class="cov0" title="0">{
        testTopic := "health_check_topic"
        testMessage := fmt.Sprintf("health-check-%d", time.Now().UnixNano())

        // 创建带超时的上下文
        ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
        defer cancel()

        // 检查是否支持端到端测试
        if k.consumer != nil </span><span class="cov0" title="0">{
                return k.performKafkaEndToEndTest(ctx, testTopic, testMessage)
        }</span>

        // 如果没有消费者组，只测试发布能力
        <span class="cov0" title="0">start := time.Now()
        err := k.Publish(ctx, testTopic, []byte(testMessage))
        publishLatency := time.Since(start)

        if err != nil </span><span class="cov0" title="0">{
                k.logger.Error("Kafka health check message transport failed",
                        zap.Error(err),
                        zap.Duration("publishLatency", publishLatency))
                return fmt.Errorf("failed to publish health check message: %w", err)
        }</span>

        <span class="cov0" title="0">k.logger.Debug("Kafka health check message transport successful",
                zap.Duration("publishLatency", publishLatency))

        return nil</span>
}

// performKafkaEndToEndTest 执行 Kafka 端到端测试
func (k *kafkaEventBus) performKafkaEndToEndTest(ctx context.Context, testTopic, testMessage string) error <span class="cov0" title="0">{
        // 创建接收通道
        receiveChan := make(chan string, 1)
        errorChan := make(chan error, 1)

        // 创建分区消费者来接收健康检查消息
        partitionConsumer, err := k.consumer.ConsumePartition(testTopic, 0, sarama.OffsetNewest)
        if err != nil </span><span class="cov0" title="0">{
                k.logger.Warn("Failed to create partition consumer for health check, falling back to publish-only test",
                        zap.Error(err))
                // 回退到只测试发布
                start := time.Now()
                if err := k.Publish(ctx, testTopic, []byte(testMessage)); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to publish health check message: %w", err)
                }</span>
                <span class="cov0" title="0">publishLatency := time.Since(start)
                k.logger.Debug("Kafka health check message published (no consumer test)",
                        zap.Duration("publishLatency", publishLatency))
                return nil</span>
        }
        <span class="cov0" title="0">defer partitionConsumer.Close()

        // 启动消费者（在后台）
        go func() </span><span class="cov0" title="0">{
                defer close(receiveChan)
                defer close(errorChan)

                for </span><span class="cov0" title="0">{
                        select </span>{
                        case message := &lt;-partitionConsumer.Messages():<span class="cov0" title="0">
                                if message != nil </span><span class="cov0" title="0">{
                                        receivedMsg := string(message.Value)
                                        if receivedMsg == testMessage </span><span class="cov0" title="0">{
                                                select </span>{
                                                case receiveChan &lt;- receivedMsg:<span class="cov0" title="0">
                                                        return</span>
                                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                                        return</span>
                                                }
                                        }
                                }
                        case err := &lt;-partitionConsumer.Errors():<span class="cov0" title="0">
                                if err != nil </span><span class="cov0" title="0">{
                                        select </span>{
                                        case errorChan &lt;- err:<span class="cov0" title="0">
                                                return</span>
                                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                                return</span>
                                        }
                                }
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()

        // 等待一小段时间确保消费者准备就绪
        <span class="cov0" title="0">time.Sleep(200 * time.Millisecond)

        // 发布健康检查消息
        start := time.Now()
        if err := k.Publish(ctx, testTopic, []byte(testMessage)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to publish health check message: %w", err)
        }</span>
        <span class="cov0" title="0">publishLatency := time.Since(start)

        // 等待接收消息或超时
        select </span>{
        case receivedMsg := &lt;-receiveChan:<span class="cov0" title="0">
                totalLatency := time.Since(start)
                k.logger.Debug("Kafka end-to-end health check successful",
                        zap.Duration("publishLatency", publishLatency),
                        zap.Duration("totalLatency", totalLatency),
                        zap.String("message", receivedMsg))
                return nil</span>

        case err := &lt;-errorChan:<span class="cov0" title="0">
                return fmt.Errorf("kafka health check consumer error: %w", err)</span>

        case &lt;-ctx.Done():<span class="cov0" title="0">
                return fmt.Errorf("kafka health check timeout: message not received within timeout period")</span>

        case &lt;-time.After(8 * time.Second):<span class="cov0" title="0">
                return fmt.Errorf("kafka health check timeout: message not received within 8 seconds")</span>
        }
}

// GetEventBusMetrics 获取 Kafka EventBus 性能指标
func (k *kafkaEventBus) GetEventBusMetrics() EventBusHealthMetrics <span class="cov0" title="0">{
        k.mu.RLock()
        defer k.mu.RUnlock()

        connectionStatus := "disconnected"
        brokerCount := 0
        topicCount := 0

        if !k.closed &amp;&amp; !k.client.Closed() </span><span class="cov0" title="0">{
                brokers := k.client.Brokers()
                brokerCount = len(brokers)

                connectedBrokers := 0
                for _, broker := range brokers </span><span class="cov0" title="0">{
                        if connected, _ := broker.Connected(); connected </span><span class="cov0" title="0">{
                                connectedBrokers++
                        }</span>
                }

                <span class="cov0" title="0">if connectedBrokers &gt; 0 </span><span class="cov0" title="0">{
                        connectionStatus = "connected"
                }</span>

                // 获取 topic 数量
                <span class="cov0" title="0">if topics, err := k.client.Topics(); err == nil </span><span class="cov0" title="0">{
                        topicCount = len(topics)
                }</span>
        }

        <span class="cov0" title="0">return EventBusHealthMetrics{
                ConnectionStatus:    connectionStatus,
                PublishLatency:      0,                          // TODO: 实际测量并缓存
                SubscribeLatency:    0,                          // TODO: 实际测量并缓存
                LastSuccessTime:     time.Now(),                 // TODO: 实际跟踪
                LastFailureTime:     time.Time{},                // TODO: 实际跟踪
                ConsecutiveFailures: 0,                          // TODO: 实际统计
                ThroughputPerSecond: k.publishedMessages.Load(), // 简化实现
                MessageBacklog:      0,                          // TODO: 实际计算
                ReconnectCount:      0,                          // TODO: 实际统计
                BrokerCount:         brokerCount,
                TopicCount:          topicCount,
        }</span>
}

// Close 关闭连接
func (k *kafkaEventBus) Close() error <span class="cov4" title="10">{
        k.mu.Lock()

        // Stop keyed worker pools
        k.keyedPoolsMu.Lock()
        for topic, pool := range k.keyedPools </span><span class="cov3" title="9">{
                if pool != nil </span><span class="cov3" title="9">{
                        pool.Stop()
                }</span>
                <span class="cov3" title="9">delete(k.keyedPools, topic)</span>
        }
        <span class="cov4" title="10">k.keyedPoolsMu.Unlock()

        defer k.mu.Unlock()

        if k.closed </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov3" title="9">var errors []error

        // 关闭管理客户端
        if k.admin != nil </span><span class="cov3" title="9">{
                if err := k.admin.Close(); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("failed to close kafka admin: %w", err))
                }</span>
        }

        // 关闭消费者
        <span class="cov3" title="9">if k.consumer != nil </span><span class="cov3" title="9">{
                if err := k.consumer.Close(); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("failed to close kafka consumer: %w", err))
                }</span>
        }

        // 关闭生产者
        <span class="cov3" title="9">if k.producer != nil </span><span class="cov3" title="9">{
                if err := k.producer.Close(); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("failed to close kafka producer: %w", err))
                }</span>
        }

        // 关闭客户端
        <span class="cov3" title="9">if k.client != nil </span><span class="cov3" title="9">{
                if err := k.client.Close(); err != nil </span><span class="cov3" title="9">{
                        errors = append(errors, fmt.Errorf("failed to close kafka client: %w", err))
                }</span>
        }

        <span class="cov3" title="9">k.closed = true
        k.logger.Info("Kafka eventbus closed successfully")

        if len(errors) &gt; 0 </span><span class="cov3" title="9">{
                return fmt.Errorf("errors during kafka eventbus close: %v", errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RegisterReconnectCallback 注册重连回调
func (k *kafkaEventBus) RegisterReconnectCallback(callback ReconnectCallback) error <span class="cov0" title="0">{
        k.mu.Lock()
        defer k.mu.Unlock()

        k.reconnectCallback = callback
        k.logger.Info("Reconnect callback registered for kafka eventbus")
        return nil
}</span>

// reconnect 执行重连逻辑
func (k *kafkaEventBus) reconnect(ctx context.Context) error <span class="cov0" title="0">{
        k.logger.Warn("Kafka connection failed, attempting to reconnect...")

        // 记录重连时间
        k.lastReconnectTime.Store(time.Now())

        backoff := k.reconnectConfig.InitialBackoff

        for attempt := 1; attempt &lt;= k.reconnectConfig.MaxAttempts; attempt++ </span><span class="cov0" title="0">{
                k.logger.Info("Reconnection attempt",
                        zap.Int("attempt", attempt),
                        zap.Int("maxAttempts", k.reconnectConfig.MaxAttempts))

                // 尝试重新初始化连接
                if err := k.reinitializeConnection(); err != nil </span><span class="cov0" title="0">{
                        k.logger.Error("Reconnection attempt failed",
                                zap.Int("attempt", attempt),
                                zap.Error(err))

                        // 如果不是最后一次尝试，等待后重试
                        if attempt &lt; k.reconnectConfig.MaxAttempts </span><span class="cov0" title="0">{
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return fmt.Errorf("reconnection cancelled: %w", ctx.Err())</span>
                                case &lt;-time.After(backoff):<span class="cov0" title="0">
                                        // 指数退避
                                        backoff = time.Duration(float64(backoff) * k.reconnectConfig.BackoffFactor)
                                        if backoff &gt; k.reconnectConfig.MaxBackoff </span><span class="cov0" title="0">{
                                                backoff = k.reconnectConfig.MaxBackoff
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">continue</span>
                }

                // 重连成功，恢复订阅
                <span class="cov0" title="0">if err := k.restoreSubscriptions(ctx); err != nil </span><span class="cov0" title="0">{
                        k.logger.Error("Failed to restore subscriptions after reconnect", zap.Error(err))
                        return fmt.Errorf("failed to restore subscriptions: %w", err)
                }</span>

                // 重置失败计数
                <span class="cov0" title="0">k.failureCount.Store(0)

                k.logger.Info("Kafka reconnection successful", zap.Int("attempt", attempt))

                // 调用重连回调
                if k.reconnectCallback != nil </span><span class="cov0" title="0">{
                        k.reconnectCallback(ctx)
                }</span>

                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("failed to reconnect after %d attempts", k.reconnectConfig.MaxAttempts)</span>
}

// reinitializeConnection 重新初始化连接
func (k *kafkaEventBus) reinitializeConnection() error <span class="cov0" title="0">{
        k.mu.Lock()
        defer k.mu.Unlock()

        // 关闭现有连接
        if k.producer != nil </span><span class="cov0" title="0">{
                k.producer.Close()
        }</span>
        <span class="cov0" title="0">if k.consumer != nil </span><span class="cov0" title="0">{
                k.consumer.Close()
        }</span>
        <span class="cov0" title="0">if k.admin != nil </span><span class="cov0" title="0">{
                k.admin.Close()
        }</span>
        <span class="cov0" title="0">if k.client != nil </span><span class="cov0" title="0">{
                k.client.Close()
        }</span>

        // 创建Sarama配置
        <span class="cov0" title="0">saramaConfig := sarama.NewConfig()
        if err := configureSarama(saramaConfig, k.config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to configure sarama: %w", err)
        }</span>

        // 重新创建客户端
        <span class="cov0" title="0">client, err := sarama.NewClient(k.config.Brokers, saramaConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create kafka client: %w", err)
        }</span>

        // 重新创建生产者
        <span class="cov0" title="0">producer, err := sarama.NewSyncProducerFromClient(client)
        if err != nil </span><span class="cov0" title="0">{
                client.Close()
                return fmt.Errorf("failed to create kafka producer: %w", err)
        }</span>

        // 重新创建消费者
        <span class="cov0" title="0">consumer, err := sarama.NewConsumerFromClient(client)
        if err != nil </span><span class="cov0" title="0">{
                producer.Close()
                client.Close()
                return fmt.Errorf("failed to create kafka consumer: %w", err)
        }</span>

        // 重新创建管理客户端
        <span class="cov0" title="0">admin, err := sarama.NewClusterAdminFromClient(client)
        if err != nil </span><span class="cov0" title="0">{
                consumer.Close()
                producer.Close()
                client.Close()
                return fmt.Errorf("failed to create kafka admin: %w", err)
        }</span>

        // 更新实例字段
        <span class="cov0" title="0">k.client = client
        k.producer = producer
        k.consumer = consumer
        k.admin = admin

        k.logger.Info("Kafka connection reinitialized successfully")
        return nil</span>
}

// restoreSubscriptions 恢复订阅
func (k *kafkaEventBus) restoreSubscriptions(ctx context.Context) error <span class="cov0" title="0">{
        k.subscriptionsMu.RLock()
        subscriptions := make(map[string]MessageHandler)
        for topic, handler := range k.subscriptions </span><span class="cov0" title="0">{
                subscriptions[topic] = handler
        }</span>
        <span class="cov0" title="0">k.subscriptionsMu.RUnlock()

        for topic, handler := range subscriptions </span><span class="cov0" title="0">{
                k.logger.Info("Restoring subscription", zap.String("topic", topic))
                if err := k.Subscribe(ctx, topic, handler); err != nil </span><span class="cov0" title="0">{
                        k.logger.Error("Failed to restore subscription",
                                zap.String("topic", topic),
                                zap.Error(err))
                        return fmt.Errorf("failed to restore subscription for topic %s: %w", topic, err)
                }</span>
        }

        <span class="cov0" title="0">k.logger.Info("All subscriptions restored successfully",
                zap.Int("count", len(subscriptions)))
        return nil</span>
}

// SetReconnectConfig 设置重连配置
func (k *kafkaEventBus) SetReconnectConfig(config ReconnectConfig) error <span class="cov0" title="0">{
        k.mu.Lock()
        defer k.mu.Unlock()

        k.reconnectConfig = config
        k.logger.Info("Reconnect config updated",
                zap.Int("maxAttempts", config.MaxAttempts),
                zap.Duration("initialBackoff", config.InitialBackoff),
                zap.Duration("maxBackoff", config.MaxBackoff),
                zap.Float64("backoffFactor", config.BackoffFactor),
                zap.Int("failureThreshold", config.FailureThreshold))
        return nil
}</span>

// GetReconnectStatus 获取重连状态
func (k *kafkaEventBus) GetReconnectStatus() ReconnectStatus <span class="cov0" title="0">{
        failures := k.failureCount.Load()
        lastReconnect := k.lastReconnectTime.Load().(time.Time)

        return ReconnectStatus{
                FailureCount:      int(failures),
                LastReconnectTime: lastReconnect,
                IsReconnecting:    false, // 简化实现，实际可以添加状态跟踪
                Config:            k.reconnectConfig,
        }
}</span>

// ReconnectStatus 重连状态
type ReconnectStatus struct {
        FailureCount      int             `json:"failure_count"`
        LastReconnectTime time.Time       `json:"last_reconnect_time"`
        IsReconnecting    bool            `json:"is_reconnecting"`
        Config            ReconnectConfig `json:"config"`
}

// ========== 生命周期管理 ==========

// Start 启动事件总线
func (k *kafkaEventBus) Start(ctx context.Context) error <span class="cov0" title="0">{
        k.mu.Lock()
        defer k.mu.Unlock()

        if k.closed </span><span class="cov0" title="0">{
                return fmt.Errorf("kafka eventbus is closed")
        }</span>

        <span class="cov0" title="0">k.logger.Info("Kafka eventbus started successfully")
        return nil</span>
}

// Stop 停止事件总线
func (k *kafkaEventBus) Stop() error <span class="cov0" title="0">{
        return k.Close()
}</span>

// ========== 高级发布功能 ==========

// PublishWithOptions 使用选项发布消息
func (k *kafkaEventBus) PublishWithOptions(ctx context.Context, topic string, message []byte, opts PublishOptions) error <span class="cov0" title="0">{
        start := time.Now()

        // 应用消息格式化器
        if k.messageFormatter != nil </span><span class="cov0" title="0">{
                // 生成消息UUID
                msgUUID := fmt.Sprintf("%d", time.Now().UnixNano())
                formattedMsg, err := k.messageFormatter.FormatMessage(msgUUID, opts.AggregateID, message)
                if err != nil </span><span class="cov0" title="0">{
                        k.logger.Error("Failed to format message", zap.Error(err))
                        return fmt.Errorf("failed to format message: %w", err)
                }</span>

                // 设置元数据
                <span class="cov0" title="0">if opts.Metadata != nil </span><span class="cov0" title="0">{
                        if err := k.messageFormatter.SetMetadata(formattedMsg, opts.Metadata); err != nil </span><span class="cov0" title="0">{
                                k.logger.Error("Failed to set metadata", zap.Error(err))
                                return fmt.Errorf("failed to set metadata: %w", err)
                        }</span>
                }

                // 将格式化后的消息转换为字节
                <span class="cov0" title="0">if formattedMsg.Payload != nil </span><span class="cov0" title="0">{
                        message = formattedMsg.Payload
                }</span>
        }

        // 构建 Kafka 消息
        <span class="cov0" title="0">kafkaMsg := &amp;sarama.ProducerMessage{
                Topic: topic,
                Value: sarama.ByteEncoder(message),
        }

        // 设置消息头
        if opts.Metadata != nil </span><span class="cov0" title="0">{
                headers := make([]sarama.RecordHeader, 0, len(opts.Metadata))
                for key, value := range opts.Metadata </span><span class="cov0" title="0">{
                        headers = append(headers, sarama.RecordHeader{
                                Key:   []byte(key),
                                Value: []byte(value),
                        })
                }</span>
                <span class="cov0" title="0">kafkaMsg.Headers = headers</span>
        }

        // 设置分区键（如果提供了 AggregateID）
        <span class="cov0" title="0">if opts.AggregateID != nil </span><span class="cov0" title="0">{
                var aggregateKey string
                if k.messageFormatter != nil </span><span class="cov0" title="0">{
                        aggregateKey = k.messageFormatter.ExtractAggregateID(opts.AggregateID)
                }</span> else<span class="cov0" title="0"> {
                        aggregateKey = fmt.Sprintf("%v", opts.AggregateID)
                }</span>
                <span class="cov0" title="0">if aggregateKey != "" </span><span class="cov0" title="0">{
                        kafkaMsg.Key = sarama.StringEncoder(aggregateKey)
                }</span>
        }

        // 发布消息
        <span class="cov0" title="0">partition, offset, err := k.producer.SendMessage(kafkaMsg)

        // 记录指标
        duration := time.Since(start)
        if err != nil </span><span class="cov0" title="0">{
                k.errorCount.Add(1)
                k.logger.Error("Failed to publish message with options",
                        zap.String("topic", topic),
                        zap.Error(err),
                        zap.Duration("duration", duration))
        }</span> else<span class="cov0" title="0"> {
                k.publishedMessages.Add(1)
                k.logger.Debug("Message published with options",
                        zap.String("topic", topic),
                        zap.Int32("partition", partition),
                        zap.Int64("offset", offset),
                        zap.Duration("duration", duration))
        }</span>

        // 调用发布回调
        <span class="cov0" title="0">if k.publishCallback != nil </span><span class="cov0" title="0">{
                go func() </span><span class="cov0" title="0">{
                        callbackErr := k.publishCallback(ctx, topic, message, err)
                        if callbackErr != nil </span><span class="cov0" title="0">{
                                k.logger.Error("Publish callback failed", zap.Error(callbackErr))
                        }</span>
                }()
        }

        <span class="cov0" title="0">return err</span>
}

// SetMessageFormatter 设置消息格式化器
func (k *kafkaEventBus) SetMessageFormatter(formatter MessageFormatter) error <span class="cov0" title="0">{
        k.mu.Lock()
        defer k.mu.Unlock()

        k.messageFormatter = formatter
        k.logger.Info("Message formatter set for kafka eventbus")
        return nil
}</span>

// RegisterPublishCallback 注册发布回调
func (k *kafkaEventBus) RegisterPublishCallback(callback PublishCallback) error <span class="cov0" title="0">{
        k.mu.Lock()
        defer k.mu.Unlock()

        k.publishCallback = callback
        k.logger.Debug("Publish callback registered for kafka eventbus")
        return nil
}</span>

// ========== 高级订阅功能 ==========

// SubscribeWithOptions 使用选项订阅消息
func (k *kafkaEventBus) SubscribeWithOptions(ctx context.Context, topic string, handler MessageHandler, opts SubscribeOptions) error <span class="cov0" title="0">{
        // 包装处理器以支持企业特性
        wrappedHandler := func(ctx context.Context, message []byte) error </span><span class="cov0" title="0">{
                start := time.Now()

                // 应用流量控制
                if k.rateLimiter != nil </span><span class="cov0" title="0">{
                        if !k.rateLimiter.Allow() </span><span class="cov0" title="0">{
                                k.logger.Warn("Message dropped due to rate limiting", zap.String("topic", topic))
                                return fmt.Errorf("rate limit exceeded")
                        }</span>
                }

                // 直接处理消息
                <span class="cov0" title="0">err := handler(ctx, message)

                // 记录指标
                duration := time.Since(start)
                if err != nil </span><span class="cov0" title="0">{
                        k.errorCount.Add(1)
                        k.logger.Error("Message processing failed",
                                zap.String("topic", topic),
                                zap.Error(err),
                                zap.Duration("duration", duration))

                        // 调用错误处理器
                        if k.errorHandler != nil </span><span class="cov0" title="0">{
                                go func() </span><span class="cov0" title="0">{
                                        errorAction := k.errorHandler.HandleError(ctx, err, message, topic)
                                        k.logger.Info("Error handler executed",
                                                zap.String("action", string(errorAction.Action)),
                                                zap.Bool("deadLetter", errorAction.DeadLetter),
                                                zap.Bool("skipMessage", errorAction.SkipMessage))
                                }</span>()
                        }
                } else<span class="cov0" title="0"> {
                        k.consumedMessages.Add(1)
                        k.logger.Debug("Message processed successfully",
                                zap.String("topic", topic),
                                zap.Duration("duration", duration))
                }</span>

                <span class="cov0" title="0">return err</span>
        }

        // 使用包装后的处理器订阅
        <span class="cov0" title="0">return k.Subscribe(ctx, topic, wrappedHandler)</span>
}

// RegisterSubscriberBacklogCallback 注册订阅端积压回调
func (k *kafkaEventBus) RegisterSubscriberBacklogCallback(callback BacklogStateCallback) error <span class="cov0" title="0">{
        if k.backlogDetector != nil </span><span class="cov0" title="0">{
                return k.backlogDetector.RegisterCallback(callback)
        }</span>
        <span class="cov0" title="0">k.logger.Info("Subscriber backlog callback registered (detector not available)")
        return nil</span>
}

// StartSubscriberBacklogMonitoring 启动订阅端积压监控
func (k *kafkaEventBus) StartSubscriberBacklogMonitoring(ctx context.Context) error <span class="cov0" title="0">{
        if k.backlogDetector != nil </span><span class="cov0" title="0">{
                return k.backlogDetector.Start(ctx)
        }</span>
        <span class="cov0" title="0">k.logger.Info("Subscriber backlog monitoring not available")
        return nil</span>
}

// StopSubscriberBacklogMonitoring 停止订阅端积压监控
func (k *kafkaEventBus) StopSubscriberBacklogMonitoring() error <span class="cov0" title="0">{
        if k.backlogDetector != nil </span><span class="cov0" title="0">{
                return k.backlogDetector.Stop()
        }</span>
        <span class="cov0" title="0">k.logger.Info("Subscriber backlog monitoring not available")
        return nil</span>
}

// RegisterBacklogCallback 注册订阅端积压回调（已废弃，向后兼容）
func (k *kafkaEventBus) RegisterBacklogCallback(callback BacklogStateCallback) error <span class="cov0" title="0">{
        k.logger.Warn("RegisterBacklogCallback is deprecated, use RegisterSubscriberBacklogCallback instead")
        return k.RegisterSubscriberBacklogCallback(callback)
}</span>

// StartBacklogMonitoring 启动订阅端积压监控（已废弃，向后兼容）
func (k *kafkaEventBus) StartBacklogMonitoring(ctx context.Context) error <span class="cov0" title="0">{
        k.logger.Warn("StartBacklogMonitoring is deprecated, use StartSubscriberBacklogMonitoring instead")
        return k.StartSubscriberBacklogMonitoring(ctx)
}</span>

// StopBacklogMonitoring 停止订阅端积压监控（已废弃，向后兼容）
func (k *kafkaEventBus) StopBacklogMonitoring() error <span class="cov0" title="0">{
        k.logger.Warn("StopBacklogMonitoring is deprecated, use StopSubscriberBacklogMonitoring instead")
        return k.StopSubscriberBacklogMonitoring()
}</span>

// RegisterPublisherBacklogCallback 注册发送端积压回调
func (k *kafkaEventBus) RegisterPublisherBacklogCallback(callback PublisherBacklogCallback) error <span class="cov0" title="0">{
        if k.publisherBacklogDetector != nil </span><span class="cov0" title="0">{
                return k.publisherBacklogDetector.RegisterCallback(callback)
        }</span>
        <span class="cov0" title="0">k.logger.Debug("Publisher backlog callback registered (detector not available)")
        return nil</span>
}

// StartPublisherBacklogMonitoring 启动发送端积压监控
func (k *kafkaEventBus) StartPublisherBacklogMonitoring(ctx context.Context) error <span class="cov0" title="0">{
        if k.publisherBacklogDetector != nil </span><span class="cov0" title="0">{
                return k.publisherBacklogDetector.Start(ctx)
        }</span>
        <span class="cov0" title="0">k.logger.Debug("Publisher backlog monitoring not available (not configured)")
        return nil</span>
}

// StopPublisherBacklogMonitoring 停止发送端积压监控
func (k *kafkaEventBus) StopPublisherBacklogMonitoring() error <span class="cov0" title="0">{
        if k.publisherBacklogDetector != nil </span><span class="cov0" title="0">{
                return k.publisherBacklogDetector.Stop()
        }</span>
        <span class="cov0" title="0">k.logger.Debug("Publisher backlog monitoring not available (not configured)")
        return nil</span>
}

// StartAllBacklogMonitoring 根据配置启动所有积压监控
func (k *kafkaEventBus) StartAllBacklogMonitoring(ctx context.Context) error <span class="cov0" title="0">{
        var errs []error

        // 启动订阅端积压监控
        if err := k.StartSubscriberBacklogMonitoring(ctx); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf("failed to start subscriber backlog monitoring: %w", err))
        }</span>

        // 启动发送端积压监控
        <span class="cov0" title="0">if err := k.StartPublisherBacklogMonitoring(ctx); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf("failed to start publisher backlog monitoring: %w", err))
        }</span>

        <span class="cov0" title="0">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start some backlog monitoring: %v", errs)
        }</span>

        <span class="cov0" title="0">k.logger.Info("All backlog monitoring started successfully")
        return nil</span>
}

// StopAllBacklogMonitoring 停止所有积压监控
func (k *kafkaEventBus) StopAllBacklogMonitoring() error <span class="cov0" title="0">{
        var errs []error

        // 停止订阅端积压监控
        if err := k.StopSubscriberBacklogMonitoring(); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf("failed to stop subscriber backlog monitoring: %w", err))
        }</span>

        // 停止发送端积压监控
        <span class="cov0" title="0">if err := k.StopPublisherBacklogMonitoring(); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf("failed to stop publisher backlog monitoring: %w", err))
        }</span>

        <span class="cov0" title="0">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stop some backlog monitoring: %v", errs)
        }</span>

        <span class="cov0" title="0">k.logger.Info("All backlog monitoring stopped successfully")
        return nil</span>
}

// SetMessageRouter 设置消息路由器
func (k *kafkaEventBus) SetMessageRouter(router MessageRouter) error <span class="cov0" title="0">{
        k.mu.Lock()
        defer k.mu.Unlock()

        k.messageRouter = router
        k.logger.Info("Message router set for kafka eventbus")
        return nil
}</span>

// SetErrorHandler 设置错误处理器
func (k *kafkaEventBus) SetErrorHandler(handler ErrorHandler) error <span class="cov0" title="0">{
        k.mu.Lock()
        defer k.mu.Unlock()

        k.errorHandler = handler
        k.logger.Info("Error handler set for kafka eventbus")
        return nil
}</span>

// RegisterSubscriptionCallback 注册订阅回调
func (k *kafkaEventBus) RegisterSubscriptionCallback(callback SubscriptionCallback) error <span class="cov0" title="0">{
        k.logger.Info("Subscription callback registered for kafka eventbus")
        return nil
}</span>

// ========== 统一健康检查和监控 ==========

// StartHealthCheck 启动健康检查
func (k *kafkaEventBus) StartHealthCheck(ctx context.Context) error <span class="cov0" title="0">{
        k.mu.Lock()
        defer k.mu.Unlock()

        // 如果已经启动，先停止之前的
        if k.healthCheckCancel != nil </span><span class="cov0" title="0">{
                k.healthCheckCancel()
                if k.healthCheckDone != nil </span><span class="cov0" title="0">{
                        &lt;-k.healthCheckDone // 等待之前的健康检查完全停止
                }</span>
        }

        // 创建新的控制 context
        <span class="cov0" title="0">healthCtx, cancel := context.WithCancel(ctx)
        k.healthCheckCancel = cancel
        k.healthCheckDone = make(chan struct{})

        // 启动健康检查协程
        go func() </span><span class="cov0" title="0">{
                defer close(k.healthCheckDone)

                ticker := time.NewTicker(2 * time.Minute) // 默认健康检查间隔
                defer ticker.Stop()

                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-healthCtx.Done():<span class="cov0" title="0">
                                k.logger.Info("Health check stopped for kafka eventbus")
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                if err := k.healthCheck(healthCtx); err != nil </span><span class="cov0" title="0">{
                                        k.logger.Error("Health check failed", zap.Error(err))

                                        // 增加失败计数
                                        failures := k.failureCount.Add(1)
                                        k.logger.Warn("Health check failure count increased",
                                                zap.Int32("failures", failures),
                                                zap.Int("threshold", k.reconnectConfig.FailureThreshold))

                                        // 检查是否需要触发重连
                                        if int(failures) &gt;= k.reconnectConfig.FailureThreshold </span><span class="cov0" title="0">{
                                                k.logger.Warn("Health check failure threshold reached, triggering reconnection",
                                                        zap.Int32("failures", failures),
                                                        zap.Int("threshold", k.reconnectConfig.FailureThreshold))

                                                // 执行重连
                                                if reconnectErr := k.reconnect(healthCtx); reconnectErr != nil </span><span class="cov0" title="0">{
                                                        k.logger.Error("Automatic reconnection failed", zap.Error(reconnectErr))
                                                }</span> else<span class="cov0" title="0"> {
                                                        k.logger.Info("Automatic reconnection successful")
                                                }</span>
                                        }
                                } else<span class="cov0" title="0"> {
                                        // 健康检查成功，重置失败计数
                                        if k.failureCount.Load() &gt; 0 </span><span class="cov0" title="0">{
                                                k.failureCount.Store(0)
                                                k.logger.Debug("Health check passed, failure count reset")
                                        }</span>
                                }
                        }
                }
        }()

        <span class="cov0" title="0">k.logger.Info("Health check started for kafka eventbus")
        return nil</span>
}

// StopHealthCheck 停止健康检查
func (k *kafkaEventBus) StopHealthCheck() error <span class="cov0" title="0">{
        k.mu.Lock()
        defer k.mu.Unlock()

        if k.healthCheckCancel != nil </span><span class="cov0" title="0">{
                // 取消健康检查 context
                k.healthCheckCancel()

                // 等待健康检查 goroutine 完全停止
                if k.healthCheckDone != nil </span><span class="cov0" title="0">{
                        &lt;-k.healthCheckDone
                }</span>

                // 清理资源
                <span class="cov0" title="0">k.healthCheckCancel = nil
                k.healthCheckDone = nil

                k.logger.Info("Health check stopped for kafka eventbus")</span>
        } else<span class="cov0" title="0"> {
                k.logger.Debug("Health check was not running")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetHealthStatus 获取健康状态
func (k *kafkaEventBus) GetHealthStatus() HealthCheckStatus <span class="cov0" title="0">{
        return HealthCheckStatus{
                IsHealthy:           !k.closed &amp;&amp; k.client != nil,
                ConsecutiveFailures: 0,
                LastSuccessTime:     time.Now(),
                LastFailureTime:     time.Time{},
                IsRunning:           !k.closed,
                EventBusType:        "kafka",
                Source:              "kafka-eventbus",
        }
}</span>

// RegisterHealthCheckCallback 注册健康检查回调
func (k *kafkaEventBus) RegisterHealthCheckCallback(callback HealthCheckCallback) error <span class="cov0" title="0">{
        k.logger.Info("Health check callback registered for kafka eventbus")
        return nil
}</span>

// StartHealthCheckSubscriber 启动健康检查消息订阅监控
func (k *kafkaEventBus) StartHealthCheckSubscriber(ctx context.Context) error <span class="cov0" title="0">{
        k.mu.Lock()
        defer k.mu.Unlock()

        if k.healthCheckSubscriber != nil </span><span class="cov0" title="0">{
                return nil // 已经启动
        }</span>

        // 创建健康检查订阅监控器
        <span class="cov0" title="0">config := GetDefaultHealthCheckConfig()
        k.healthCheckSubscriber = NewHealthCheckSubscriber(config, k, "kafka-eventbus", "kafka")

        // 启动监控器
        if err := k.healthCheckSubscriber.Start(ctx); err != nil </span><span class="cov0" title="0">{
                k.healthCheckSubscriber = nil
                return fmt.Errorf("failed to start health check subscriber: %w", err)
        }</span>

        <span class="cov0" title="0">k.logger.Info("Health check subscriber started for kafka eventbus")
        return nil</span>
}

// StopHealthCheckSubscriber 停止健康检查消息订阅监控
func (k *kafkaEventBus) StopHealthCheckSubscriber() error <span class="cov0" title="0">{
        k.mu.Lock()
        defer k.mu.Unlock()

        if k.healthCheckSubscriber == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if err := k.healthCheckSubscriber.Stop(); err != nil </span><span class="cov0" title="0">{
                k.logger.Error("Failed to stop health check subscriber", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">k.healthCheckSubscriber = nil
        k.logger.Info("Health check subscriber stopped for kafka eventbus")
        return nil</span>
}

// RegisterHealthCheckAlertCallback 注册健康检查告警回调
func (k *kafkaEventBus) RegisterHealthCheckAlertCallback(callback HealthCheckAlertCallback) error <span class="cov0" title="0">{
        k.mu.RLock()
        defer k.mu.RUnlock()

        if k.healthCheckSubscriber == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("health check subscriber not started")
        }</span>

        <span class="cov0" title="0">return k.healthCheckSubscriber.RegisterAlertCallback(callback)</span>
}

// GetHealthCheckSubscriberStats 获取健康检查订阅监控统计信息
func (k *kafkaEventBus) GetHealthCheckSubscriberStats() HealthCheckSubscriberStats <span class="cov0" title="0">{
        k.mu.RLock()
        defer k.mu.RUnlock()

        if k.healthCheckSubscriber == nil </span><span class="cov0" title="0">{
                return HealthCheckSubscriberStats{}
        }</span>

        <span class="cov0" title="0">return k.healthCheckSubscriber.GetStats()</span>
}

// GetConnectionState 获取连接状态
func (k *kafkaEventBus) GetConnectionState() ConnectionState <span class="cov0" title="0">{
        isConnected := !k.closed &amp;&amp; k.client != nil
        return ConnectionState{
                IsConnected:       isConnected,
                LastConnectedTime: time.Now(),
                ReconnectCount:    0,
                LastError:         "",
        }
}</span>

// GetMetrics 获取监控指标
func (k *kafkaEventBus) GetMetrics() Metrics <span class="cov0" title="0">{
        return Metrics{
                MessagesPublished: k.publishedMessages.Load(),
                MessagesConsumed:  k.consumedMessages.Load(),
                PublishErrors:     k.errorCount.Load(),
                ConsumeErrors:     0,
                ConnectionErrors:  0,
                LastHealthCheck:   time.Now(),
                HealthCheckStatus: "healthy",
                ActiveConnections: 1,
                MessageBacklog:    0,
        }
}</span>

// ========== 方案A：Envelope 支持 ==========

// PublishEnvelope 发布Envelope消息（方案A）
func (k *kafkaEventBus) PublishEnvelope(ctx context.Context, topic string, envelope *Envelope) error <span class="cov0" title="0">{
        k.mu.RLock()
        defer k.mu.RUnlock()

        if k.closed </span><span class="cov0" title="0">{
                return fmt.Errorf("kafka eventbus is closed")
        }</span>

        // 校验Envelope
        <span class="cov0" title="0">if err := envelope.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid envelope: %w", err)
        }</span>

        // 流量控制
        <span class="cov0" title="0">if k.rateLimiter != nil </span><span class="cov0" title="0">{
                if err := k.rateLimiter.Wait(ctx); err != nil </span><span class="cov0" title="0">{
                        k.errorCount.Add(1)
                        return fmt.Errorf("rate limit error: %w", err)
                }</span>
        }

        // 序列化Envelope
        <span class="cov0" title="0">envelopeBytes, err := envelope.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                k.errorCount.Add(1)
                return fmt.Errorf("failed to serialize envelope: %w", err)
        }</span>

        // 创建Kafka消息（方案A + 传输层镜像）
        <span class="cov0" title="0">msg := &amp;sarama.ProducerMessage{
                Topic: topic,
                Key:   sarama.StringEncoder(envelope.AggregateID), // 镜像到Kafka Key
                Value: sarama.ByteEncoder(envelopeBytes),
                Headers: []sarama.RecordHeader{
                        {Key: []byte("X-Aggregate-ID"), Value: []byte(envelope.AggregateID)},
                        {Key: []byte("X-Event-Version"), Value: []byte(fmt.Sprintf("%d", envelope.EventVersion))},
                        {Key: []byte("X-Event-Type"), Value: []byte(envelope.EventType)},
                },
        }

        // 添加可选字段到Header
        if envelope.TraceID != "" </span><span class="cov0" title="0">{
                msg.Headers = append(msg.Headers, sarama.RecordHeader{
                        Key: []byte("X-Trace-ID"), Value: []byte(envelope.TraceID),
                })
        }</span>
        <span class="cov0" title="0">if envelope.CorrelationID != "" </span><span class="cov0" title="0">{
                msg.Headers = append(msg.Headers, sarama.RecordHeader{
                        Key: []byte("X-Correlation-ID"), Value: []byte(envelope.CorrelationID),
                })
        }</span>

        // 发送消息
        <span class="cov0" title="0">partition, offset, err := k.producer.SendMessage(msg)
        if err != nil </span><span class="cov0" title="0">{
                k.errorCount.Add(1)
                k.logger.Error("Failed to publish envelope message",
                        zap.String("topic", topic),
                        zap.String("aggregateID", envelope.AggregateID),
                        zap.String("eventType", envelope.EventType),
                        zap.Int64("eventVersion", envelope.EventVersion),
                        zap.Error(err))
                return fmt.Errorf("failed to publish envelope message: %w", err)
        }</span>

        <span class="cov0" title="0">k.publishedMessages.Add(1)
        k.logger.Debug("Envelope message published successfully",
                zap.String("topic", topic),
                zap.String("aggregateID", envelope.AggregateID),
                zap.String("eventType", envelope.EventType),
                zap.Int64("eventVersion", envelope.EventVersion),
                zap.Int32("partition", partition),
                zap.Int64("offset", offset))

        return nil</span>
}

// SubscribeEnvelope 订阅Envelope消息（自动使用Keyed-Worker池）
//
// 特点：
// - 消息格式：Envelope包装格式（包含聚合ID、事件类型、版本等元数据）
// - 处理模式：按聚合ID路由到Keyed-Worker池，同聚合ID严格顺序处理
// - 性能：顺序保证，毫秒级延迟
// - 聚合ID：从Envelope.AggregateID字段提取
// - Keyed-Worker池：自动使用（基于聚合ID的一致性哈希路由）
//
// 核心机制：
// 1. 消息必须是Envelope格式，包含AggregateID
// 2. ExtractAggregateID成功提取聚合ID
// 3. 使用一致性哈希将相同聚合ID路由到固定Worker
// 4. 确保同一聚合的事件严格按序处理
//
// 适用场景：
// - 领域事件处理（订单状态变更、用户行为）
// - 事件溯源（Event Sourcing）
// - 聚合管理（DDD聚合根）
// - 需要顺序保证的业务场景
//
// 示例：
//
//        bus.SubscribeEnvelope(ctx, "orders.events", func(ctx context.Context, env *Envelope) error {
//            // env.AggregateID = "order-123"
//            // 同一订单的所有事件会路由到同一个Worker，确保顺序处理
//            return processDomainEvent(env)
//        })
func (k *kafkaEventBus) SubscribeEnvelope(ctx context.Context, topic string, handler EnvelopeHandler) error <span class="cov0" title="0">{
        // 包装EnvelopeHandler为MessageHandler
        wrappedHandler := func(ctx context.Context, message []byte) error </span><span class="cov0" title="0">{
                // 尝试解析为Envelope
                envelope, err := FromBytes(message)
                if err != nil </span><span class="cov0" title="0">{
                        k.logger.Error("Failed to parse envelope message",
                                zap.String("topic", topic),
                                zap.Error(err))
                        return fmt.Errorf("failed to parse envelope: %w", err)
                }</span>

                // 调用业务处理器
                <span class="cov0" title="0">return handler(ctx, envelope)</span>
        }

        // 使用现有的Subscribe方法
        <span class="cov0" title="0">return k.Subscribe(ctx, topic, wrappedHandler)</span>
}

// ========== 新的分离式健康检查接口实现 ==========

// StartHealthCheckPublisher 启动健康检查发布器
func (k *kafkaEventBus) StartHealthCheckPublisher(ctx context.Context) error <span class="cov0" title="0">{
        k.mu.Lock()
        defer k.mu.Unlock()

        if k.healthChecker != nil </span><span class="cov0" title="0">{
                return nil // 已经启动
        }</span>

        // 创建健康检查发布器
        <span class="cov0" title="0">config := GetDefaultHealthCheckConfig()
        k.healthChecker = NewHealthChecker(config, k, "kafka-eventbus", "kafka")

        // 启动健康检查发布器
        if err := k.healthChecker.Start(ctx); err != nil </span><span class="cov0" title="0">{
                k.healthChecker = nil
                return fmt.Errorf("failed to start health check publisher: %w", err)
        }</span>

        <span class="cov0" title="0">k.logger.Info("Health check publisher started for kafka eventbus")
        return nil</span>
}

// StopHealthCheckPublisher 停止健康检查发布器
func (k *kafkaEventBus) StopHealthCheckPublisher() error <span class="cov0" title="0">{
        k.mu.Lock()
        defer k.mu.Unlock()

        if k.healthChecker == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if err := k.healthChecker.Stop(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stop health check publisher: %w", err)
        }</span>

        <span class="cov0" title="0">k.healthChecker = nil
        k.logger.Info("Health check publisher stopped for kafka eventbus")
        return nil</span>
}

// GetHealthCheckPublisherStatus 获取健康检查发布器状态
func (k *kafkaEventBus) GetHealthCheckPublisherStatus() HealthCheckStatus <span class="cov0" title="0">{
        k.mu.RLock()
        defer k.mu.RUnlock()

        if k.healthChecker == nil </span><span class="cov0" title="0">{
                return HealthCheckStatus{
                        IsHealthy:           false,
                        ConsecutiveFailures: 0,
                        LastSuccessTime:     time.Time{},
                        LastFailureTime:     time.Now(),
                        IsRunning:           false,
                        EventBusType:        "kafka",
                        Source:              "kafka-eventbus",
                }
        }</span>

        <span class="cov0" title="0">return k.healthChecker.GetStatus()</span>
}

// RegisterHealthCheckPublisherCallback 注册健康检查发布器回调
func (k *kafkaEventBus) RegisterHealthCheckPublisherCallback(callback HealthCheckCallback) error <span class="cov0" title="0">{
        k.mu.RLock()
        defer k.mu.RUnlock()

        if k.healthChecker == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("health check publisher not started")
        }</span>

        <span class="cov0" title="0">return k.healthChecker.RegisterCallback(callback)</span>
}

// RegisterHealthCheckSubscriberCallback 注册健康检查订阅器回调
func (k *kafkaEventBus) RegisterHealthCheckSubscriberCallback(callback HealthCheckAlertCallback) error <span class="cov0" title="0">{
        return k.RegisterHealthCheckAlertCallback(callback)
}</span>

// StartAllHealthCheck 根据配置启动所有健康检查
func (k *kafkaEventBus) StartAllHealthCheck(ctx context.Context) error <span class="cov0" title="0">{
        // 这里可以根据配置决定启动哪些健康检查
        // 为了演示，我们启动发布器和订阅器
        if err := k.StartHealthCheckPublisher(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start health check publisher: %w", err)
        }</span>

        <span class="cov0" title="0">if err := k.StartHealthCheckSubscriber(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start health check subscriber: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// StopAllHealthCheck 停止所有健康检查
func (k *kafkaEventBus) StopAllHealthCheck() error <span class="cov0" title="0">{
        var errs []error

        if err := k.StopHealthCheckPublisher(); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf("failed to stop health check publisher: %w", err))
        }</span>

        <span class="cov0" title="0">if err := k.StopHealthCheckSubscriber(); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf("failed to stop health check subscriber: %w", err))
        }</span>

        <span class="cov0" title="0">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("errors stopping health checks: %v", errs)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ========== 主题持久化管理实现 ==========

// ConfigureTopic 配置主题的持久化策略和其他选项（幂等操作）
func (k *kafkaEventBus) ConfigureTopic(ctx context.Context, topic string, options TopicOptions) error <span class="cov0" title="0">{
        start := time.Now()

        k.topicConfigsMu.Lock()
        // 检查是否已有配置
        _, exists := k.topicConfigs[topic]
        // 缓存配置
        k.topicConfigs[topic] = options
        k.topicConfigsMu.Unlock()

        // 根据策略决定是否需要同步到消息中间件
        shouldCreate, shouldUpdate := shouldCreateOrUpdate(k.topicConfigStrategy, exists)

        var action string
        var err error
        var mismatches []TopicConfigMismatch

        switch </span>{
        case k.topicConfigStrategy == StrategySkip:<span class="cov0" title="0">
                // 跳过模式：不检查
                action = "skipped"</span>

        case k.topicConfigStrategy == StrategyValidateOnly:<span class="cov0" title="0">
                // 验证模式：只验证，不修改
                action = "validated"
                if exists </span><span class="cov0" title="0">{
                        actualConfig, validateErr := k.getActualTopicConfig(ctx, topic)
                        if validateErr == nil </span><span class="cov0" title="0">{
                                mismatches = compareTopicOptions(topic, options, actualConfig)
                                if len(mismatches) &gt; 0 </span><span class="cov0" title="0">{
                                        err = handleConfigMismatches(mismatches, k.topicConfigOnMismatch)
                                }</span>
                        }
                }

        case shouldCreate:<span class="cov0" title="0">
                // 创建模式：创建新配置
                action = "created"
                err = k.ensureKafkaTopicIdempotent(ctx, topic, options, false)</span>

        case shouldUpdate:<span class="cov0" title="0">
                // 更新模式：更新现有配置
                action = "updated"
                // 先验证配置差异
                actualConfig, validateErr := k.getActualTopicConfig(ctx, topic)
                if validateErr == nil </span><span class="cov0" title="0">{
                        mismatches = compareTopicOptions(topic, options, actualConfig)
                }</span>
                // 执行更新
                <span class="cov0" title="0">err = k.ensureKafkaTopicIdempotent(ctx, topic, options, true)</span>

        default:<span class="cov0" title="0">
                // 默认：创建或更新
                action = "configured"
                err = k.ensureKafkaTopicIdempotent(ctx, topic, options, exists)</span>
        }

        <span class="cov0" title="0">duration := time.Since(start)

        // 记录结果
        if err != nil </span><span class="cov0" title="0">{
                k.logger.Error("Topic configuration failed",
                        zap.String("topic", topic),
                        zap.String("action", action),
                        zap.String("strategy", string(k.topicConfigStrategy)),
                        zap.Error(err),
                        zap.Duration("duration", duration))
                return fmt.Errorf("failed to configure topic %s: %w", topic, err)
        }</span>

        <span class="cov0" title="0">k.logger.Info("Topic configured successfully",
                zap.String("topic", topic),
                zap.String("action", action),
                zap.String("strategy", string(k.topicConfigStrategy)),
                zap.String("persistenceMode", string(options.PersistenceMode)),
                zap.Duration("retentionTime", options.RetentionTime),
                zap.Int64("maxSize", options.MaxSize),
                zap.Int("mismatches", len(mismatches)),
                zap.Duration("duration", duration))

        return nil</span>
}

// SetTopicPersistence 设置主题是否持久化（简化接口）
func (k *kafkaEventBus) SetTopicPersistence(ctx context.Context, topic string, persistent bool) error <span class="cov0" title="0">{
        mode := TopicEphemeral
        if persistent </span><span class="cov0" title="0">{
                mode = TopicPersistent
        }</span>

        <span class="cov0" title="0">options := DefaultTopicOptions()
        options.PersistenceMode = mode

        return k.ConfigureTopic(ctx, topic, options)</span>
}

// GetTopicConfig 获取主题的当前配置
func (k *kafkaEventBus) GetTopicConfig(topic string) (TopicOptions, error) <span class="cov0" title="0">{
        k.topicConfigsMu.RLock()
        defer k.topicConfigsMu.RUnlock()

        if config, exists := k.topicConfigs[topic]; exists </span><span class="cov0" title="0">{
                return config, nil
        }</span>

        // 返回默认配置
        <span class="cov0" title="0">return DefaultTopicOptions(), nil</span>
}

// ListConfiguredTopics 列出所有已配置的主题
func (k *kafkaEventBus) ListConfiguredTopics() []string <span class="cov0" title="0">{
        k.topicConfigsMu.RLock()
        defer k.topicConfigsMu.RUnlock()

        topics := make([]string, 0, len(k.topicConfigs))
        for topic := range k.topicConfigs </span><span class="cov0" title="0">{
                topics = append(topics, topic)
        }</span>

        <span class="cov0" title="0">return topics</span>
}

// RemoveTopicConfig 移除主题配置（恢复为默认行为）
func (k *kafkaEventBus) RemoveTopicConfig(topic string) error <span class="cov0" title="0">{
        k.topicConfigsMu.Lock()
        defer k.topicConfigsMu.Unlock()

        delete(k.topicConfigs, topic)

        k.logger.Info("Topic configuration removed", zap.String("topic", topic))
        return nil
}</span>

// ensureKafkaTopic 确保Kafka主题存在并配置正确
func (k *kafkaEventBus) ensureKafkaTopic(topic string, options TopicOptions) error <span class="cov0" title="0">{
        if k.admin == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Kafka admin client not available")
        }</span>

        // 检查主题是否已存在
        <span class="cov0" title="0">metadata, err := k.admin.DescribeTopics([]string{topic})
        if err != nil </span><span class="cov0" title="0">{
                // 主题不存在，创建新主题
                return k.createKafkaTopic(topic, options)
        }</span>

        // 检查是否找到主题
        <span class="cov0" title="0">if len(metadata) == 0 </span><span class="cov0" title="0">{
                return k.createKafkaTopic(topic, options)
        }</span>

        // 主题已存在，可以在这里添加配置更新逻辑
        <span class="cov0" title="0">k.logger.Info("Kafka topic already exists", zap.String("topic", topic))
        return nil</span>
}

// createKafkaTopic 创建新的Kafka主题
func (k *kafkaEventBus) createKafkaTopic(topic string, options TopicOptions) error <span class="cov0" title="0">{
        // 构建主题配置
        topicDetail := &amp;sarama.TopicDetail{
                NumPartitions:     1, // 默认1个分区
                ReplicationFactor: int16(options.Replicas),
                ConfigEntries:     make(map[string]*string),
        }

        // 根据持久化模式设置配置
        if options.IsPersistent(true) </span><span class="cov0" title="0">{ // Kafka默认是持久化的
                // 持久化配置
                if options.RetentionTime &gt; 0 </span><span class="cov0" title="0">{
                        retentionMs := fmt.Sprintf("%d", options.RetentionTime.Milliseconds())
                        topicDetail.ConfigEntries["retention.ms"] = &amp;retentionMs
                }</span>
                <span class="cov0" title="0">if options.MaxSize &gt; 0 </span><span class="cov0" title="0">{
                        retentionBytes := fmt.Sprintf("%d", options.MaxSize)
                        topicDetail.ConfigEntries["retention.bytes"] = &amp;retentionBytes
                }</span>
                // 设置为持久化存储
                <span class="cov0" title="0">cleanupPolicy := "delete"
                topicDetail.ConfigEntries["cleanup.policy"] = &amp;cleanupPolicy</span>
        } else<span class="cov0" title="0"> {
                // 非持久化配置（短期保留）
                shortRetention := "60000" // 1分钟
                topicDetail.ConfigEntries["retention.ms"] = &amp;shortRetention
                cleanupPolicy := "delete"
                topicDetail.ConfigEntries["cleanup.policy"] = &amp;cleanupPolicy
        }</span>

        // 创建主题
        <span class="cov0" title="0">err := k.admin.CreateTopic(topic, topicDetail, false)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create Kafka topic %s: %w", topic, err)
        }</span>

        <span class="cov0" title="0">k.logger.Info("Created Kafka topic",
                zap.String("topic", topic),
                zap.Int("partitions", int(topicDetail.NumPartitions)),
                zap.Int("replicas", int(topicDetail.ReplicationFactor)),
                zap.Bool("persistent", options.IsPersistent(true)))

        return nil</span>
}

// ensureKafkaTopicIdempotent 幂等地确保Kafka主题存在（支持创建和更新）
func (k *kafkaEventBus) ensureKafkaTopicIdempotent(ctx context.Context, topic string, options TopicOptions, allowUpdate bool) error <span class="cov0" title="0">{
        if k.admin == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Kafka admin client not available")
        }</span>

        // 检查主题是否已存在
        <span class="cov0" title="0">metadata, err := k.admin.DescribeTopics([]string{topic})

        if err != nil || len(metadata) == 0 </span><span class="cov0" title="0">{
                // 主题不存在，创建新主题
                k.logger.Info("Creating new Kafka topic", zap.String("topic", topic))
                return k.createKafkaTopic(topic, options)
        }</span>

        // 主题已存在
        <span class="cov0" title="0">k.logger.Info("Kafka topic already exists", zap.String("topic", topic))

        // 如果允许更新，更新主题配置
        if allowUpdate </span><span class="cov0" title="0">{
                configEntries := make(map[string]*string)

                // 构建配置更新
                if options.RetentionTime &gt; 0 </span><span class="cov0" title="0">{
                        retentionMs := fmt.Sprintf("%d", options.RetentionTime.Milliseconds())
                        configEntries["retention.ms"] = &amp;retentionMs
                }</span>
                <span class="cov0" title="0">if options.MaxSize &gt; 0 </span><span class="cov0" title="0">{
                        retentionBytes := fmt.Sprintf("%d", options.MaxSize)
                        configEntries["retention.bytes"] = &amp;retentionBytes
                }</span>

                <span class="cov0" title="0">if len(configEntries) &gt; 0 </span><span class="cov0" title="0">{
                        k.logger.Info("Updating Kafka topic configuration", zap.String("topic", topic))

                        err := k.admin.AlterConfig(sarama.TopicResource, topic, configEntries, false)
                        if err != nil </span><span class="cov0" title="0">{
                                k.logger.Warn("Failed to update topic config, using existing config",
                                        zap.String("topic", topic),
                                        zap.Error(err))
                                // 不返回错误，使用现有配置
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// getActualTopicConfig 获取主题在Kafka中的实际配置
func (k *kafkaEventBus) getActualTopicConfig(ctx context.Context, topic string) (TopicOptions, error) <span class="cov0" title="0">{
        if k.admin == nil </span><span class="cov0" title="0">{
                return TopicOptions{}, fmt.Errorf("Kafka admin client not available")
        }</span>

        // 获取主题配置
        <span class="cov0" title="0">configs, err := k.admin.DescribeConfig(sarama.ConfigResource{
                Type: sarama.TopicResource,
                Name: topic,
        })
        if err != nil </span><span class="cov0" title="0">{
                return TopicOptions{}, fmt.Errorf("failed to describe topic config: %w", err)
        }</span>

        // 解析配置
        <span class="cov0" title="0">actualConfig := TopicOptions{
                PersistenceMode: TopicPersistent, // Kafka默认持久化
        }

        for _, entry := range configs </span><span class="cov0" title="0">{
                switch entry.Name </span>{
                case "retention.ms":<span class="cov0" title="0">
                        if entry.Value != "" </span><span class="cov0" title="0">{
                                if ms, err := time.ParseDuration(entry.Value + "ms"); err == nil </span><span class="cov0" title="0">{
                                        actualConfig.RetentionTime = ms
                                }</span>
                        }
                case "retention.bytes":<span class="cov0" title="0">
                        if entry.Value != "" </span><span class="cov0" title="0">{
                                if bytes, err := fmt.Sscanf(entry.Value, "%d", &amp;actualConfig.MaxSize); err == nil </span><span class="cov0" title="0">{
                                        _ = bytes
                                }</span>
                        }
                }
        }

        // 获取分区和副本信息
        <span class="cov0" title="0">metadata, err := k.admin.DescribeTopics([]string{topic})
        if err == nil &amp;&amp; len(metadata) &gt; 0 </span><span class="cov0" title="0">{
                topicMeta := metadata[0]
                if len(topicMeta.Partitions) &gt; 0 </span><span class="cov0" title="0">{
                        actualConfig.Replicas = len(topicMeta.Partitions[0].Replicas)
                }</span>
        }

        <span class="cov0" title="0">return actualConfig, nil</span>
}

// SetTopicConfigStrategy 设置主题配置策略
func (k *kafkaEventBus) SetTopicConfigStrategy(strategy TopicConfigStrategy) <span class="cov0" title="0">{
        k.topicConfigsMu.Lock()
        defer k.topicConfigsMu.Unlock()
        k.topicConfigStrategy = strategy
        k.logger.Info("Topic config strategy updated", zap.String("strategy", string(strategy)))
}</span>

// GetTopicConfigStrategy 获取当前主题配置策略
func (k *kafkaEventBus) GetTopicConfigStrategy() TopicConfigStrategy <span class="cov0" title="0">{
        k.topicConfigsMu.RLock()
        defer k.topicConfigsMu.RUnlock()
        return k.topicConfigStrategy
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package eventbus

import (
        "context"
        "errors"
        "hash/fnv"
        "sync"
        "time"
)

// AggregateMessage 聚合消息（用于 Keyed-Worker 池）
type AggregateMessage struct {
        Topic       string
        Partition   int32
        Offset      int64
        Key         []byte
        Value       []byte
        Headers     map[string][]byte
        Timestamp   time.Time
        AggregateID string
        Context     context.Context
        Done        chan error
}

// KeyedWorkerPool implements Phase 1: a fixed-size keyed worker pool.
// - Same aggregateID is routed to the same worker via consistent hashing
// - Each worker processes messages sequentially to guarantee per-aggregate ordering
// - Each worker has a bounded queue; enqueue will block up to WaitTimeout
// - If enqueue times out, ProcessMessage returns ErrWorkerQueueFull (caller can apply backpressure)

var ErrWorkerQueueFull = errors.New("keyed worker queue full")

// KeyedWorkerPoolConfig configuration for the pool.
type KeyedWorkerPoolConfig struct {
        WorkerCount int           // number of workers (e.g., 256/1024)
        QueueSize   int           // per-worker queue capacity (bounded)
        WaitTimeout time.Duration // max time to wait when queue is full on enqueue
}

// KeyedWorkerPool routes AggregateMessage by AggregateID to workers.
// The pool is created per subscription/topic so it can call the topic's handler.
type KeyedWorkerPool struct {
        cfg     KeyedWorkerPoolConfig
        handler MessageHandler

        workers []chan *AggregateMessage
        wg      sync.WaitGroup
        stopCh  chan struct{}
}

func NewKeyedWorkerPool(cfg KeyedWorkerPoolConfig, handler MessageHandler) *KeyedWorkerPool <span class="cov4" title="33">{
        // 使用默认值（如果未配置）
        if cfg.WorkerCount &lt;= 0 </span><span class="cov1" title="1">{
                cfg.WorkerCount = DefaultKeyedWorkerCount
        }</span>
        <span class="cov4" title="33">if cfg.QueueSize &lt;= 0 </span><span class="cov1" title="2">{
                cfg.QueueSize = DefaultKeyedQueueSize
        }</span>
        <span class="cov4" title="33">if cfg.WaitTimeout &lt;= 0 </span><span class="cov1" title="2">{
                cfg.WaitTimeout = DefaultKeyedWaitTimeout
        }</span>

        <span class="cov4" title="33">kp := &amp;KeyedWorkerPool{
                cfg:     cfg,
                handler: handler,
                workers: make([]chan *AggregateMessage, cfg.WorkerCount),
                stopCh:  make(chan struct{}),
        }

        for i := 0; i &lt; cfg.WorkerCount; i++ </span><span class="cov9" title="16456">{
                ch := make(chan *AggregateMessage, cfg.QueueSize)
                kp.workers[i] = ch
                kp.wg.Add(1)
                go kp.runWorker(ch)
        }</span>

        <span class="cov4" title="33">return kp</span>
}

func (kp *KeyedWorkerPool) runWorker(ch chan *AggregateMessage) <span class="cov9" title="16456">{
        defer kp.wg.Done()
        for </span><span class="cov10" title="16776">{
                select </span>{
                case msg, ok := &lt;-ch:<span class="cov6" title="338">
                        if !ok </span><span class="cov3" title="18">{
                                return
                        }</span>
                        // Process sequentially; guarantee per-key ordering because routing is stable.
                        <span class="cov6" title="320">err := kp.handler(msg.Context, msg.Value)
                        // return result to caller (non-blocking)
                        select </span>{
                        case msg.Done &lt;- err:<span class="cov6" title="320"></span>
                        default:<span class="cov0" title="0"></span>
                        }
                case &lt;-kp.stopCh:<span class="cov9" title="16438">
                        return</span>
                }
        }
}

// ProcessMessage routes the message to its worker and enqueues it.
func (kp *KeyedWorkerPool) ProcessMessage(ctx context.Context, msg *AggregateMessage) error <span class="cov6" title="345">{
        // Require AggregateID to route; if missing, reject so caller can fallback
        if msg.AggregateID == "" </span><span class="cov1" title="2">{
                return errors.New("aggregateID required for keyed worker pool")
        }</span>

        <span class="cov6" title="343">idx := kp.hashToIndex(msg.AggregateID)
        ch := kp.workers[idx]

        // Try fast-path enqueue.
        select </span>{
        case ch &lt;- msg:<span class="cov6" title="334">
                return nil</span>
        default:<span class="cov3" title="9"></span>
        }

        // Bounded wait to avoid busy-loop; caller can apply backpressure if needed.
        <span class="cov3" title="9">timer := time.NewTimer(kp.cfg.WaitTimeout)
        defer timer.Stop()

        select </span>{
        case ch &lt;- msg:<span class="cov2" title="6">
                return nil</span>
        case &lt;-ctx.Done():<span class="cov1" title="1">
                return ctx.Err()</span>
        case &lt;-timer.C:<span class="cov1" title="2">
                return ErrWorkerQueueFull</span>
        }
}

// Stop stops all workers and drains queues.
func (kp *KeyedWorkerPool) Stop() <span class="cov4" title="33">{
        close(kp.stopCh)
        // close all worker channels to stop goroutines
        for _, ch := range kp.workers </span><span class="cov9" title="16456">{
                close(ch)
        }</span>
        <span class="cov4" title="33">kp.wg.Wait()</span>
}

func (kp *KeyedWorkerPool) hashToIndex(key string) int <span class="cov6" title="495">{
        h := fnv.New32a()
        _, _ = h.Write([]byte(key))
        return int(h.Sum32() % uint32(len(kp.workers)))
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package eventbus

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/ChenBigdata421/jxt-core/sdk/pkg/logger"
)

// memoryEventBus 内存事件总线实现（用于测试和开发）
type memoryEventBus struct {
        subscribers map[string][]MessageHandler
        mu          sync.RWMutex
        closed      bool
        metrics     *Metrics
}

// memoryPublisher 内存发布器
type memoryPublisher struct {
        eventBus *memoryEventBus
}

// memorySubscriber 内存订阅器
type memorySubscriber struct {
        eventBus *memoryEventBus
}

// NewMemoryEventBus 创建内存事件总线
func NewMemoryEventBus() EventBus <span class="cov4" title="22">{
        bus := &amp;memoryEventBus{
                subscribers: make(map[string][]MessageHandler),
                metrics: &amp;Metrics{
                        LastHealthCheck:   time.Now(),
                        HealthCheckStatus: "healthy",
                },
        }

        return &amp;eventBusManager{
                publisher:  &amp;memoryPublisher{eventBus: bus},
                subscriber: &amp;memorySubscriber{eventBus: bus},
                metrics:    bus.metrics,
                healthStatus: &amp;HealthStatus{
                        Overall:   "healthy",
                        Timestamp: time.Now(),
                        Infrastructure: InfrastructureHealth{
                                EventBus: EventBusHealthMetrics{
                                        ConnectionStatus: "connected",
                                },
                        },
                        Details: make(map[string]interface{}),
                },
        }
}</span>

// Publish 发布消息
func (m *memoryEventBus) Publish(ctx context.Context, topic string, message []byte) error <span class="cov10" title="1116">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        if m.closed </span><span class="cov0" title="0">{
                return fmt.Errorf("memory eventbus is closed")
        }</span>

        <span class="cov10" title="1116">handlers, exists := m.subscribers[topic]
        if !exists || len(handlers) == 0 </span><span class="cov7" title="120">{
                logger.Debug("No subscribers for topic", "topic", topic)
                return nil
        }</span>

        // 异步处理消息，避免阻塞发布者
        <span class="cov9" title="996">go func() </span><span class="cov9" title="996">{
                for _, handler := range handlers </span><span class="cov9" title="1001">{
                        go func(h MessageHandler) </span><span class="cov9" title="1001">{
                                defer func() </span><span class="cov9" title="1001">{
                                        if r := recover(); r != nil </span><span class="cov1" title="1">{
                                                logger.Error("Message handler panicked", "topic", topic, "panic", r)
                                                m.metrics.ConsumeErrors++
                                        }</span>
                                }()

                                <span class="cov9" title="1001">if err := h(ctx, message); err != nil </span><span class="cov3" title="10">{
                                        logger.Error("Message handler failed", "topic", topic, "error", err)
                                        m.metrics.ConsumeErrors++
                                }</span> else<span class="cov9" title="990"> {
                                        m.metrics.MessagesConsumed++
                                }</span>
                        }(handler)
                }
        }()

        <span class="cov9" title="996">m.metrics.MessagesPublished++
        logger.Debug("Message published to memory eventbus", "topic", topic, "subscribers", len(handlers))
        return nil</span>
}

// Subscribe 订阅消息
func (m *memoryEventBus) Subscribe(ctx context.Context, topic string, handler MessageHandler) error <span class="cov6" title="68">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if m.closed </span><span class="cov0" title="0">{
                return fmt.Errorf("memory eventbus is closed")
        }</span>

        <span class="cov6" title="68">if handler == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("handler cannot be nil")
        }</span>

        <span class="cov6" title="68">m.subscribers[topic] = append(m.subscribers[topic], handler)
        logger.Info("Subscribed to topic in memory eventbus", "topic", topic, "totalSubscribers", len(m.subscribers[topic]))
        return nil</span>
}

// HealthCheck 健康检查
func (m *memoryEventBus) HealthCheck(ctx context.Context) error <span class="cov1" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        if m.closed </span><span class="cov1" title="1">{
                return fmt.Errorf("memory eventbus is closed")
        }</span>

        <span class="cov0" title="0">m.metrics.LastHealthCheck = time.Now()
        m.metrics.HealthCheckStatus = "healthy"
        m.metrics.ActiveConnections = 1 // 内存实现始终有一个连接

        logger.Debug("Memory eventbus health check passed")
        return nil</span>
}

// Close 关闭
func (m *memoryEventBus) Close() error <span class="cov1" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if m.closed </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov1" title="1">m.closed = true
        m.subscribers = make(map[string][]MessageHandler)
        logger.Info("Memory eventbus closed")
        return nil</span>
}

// RegisterReconnectCallback 注册重连回调（内存实现不需要重连）
func (m *memoryEventBus) RegisterReconnectCallback(callback func(ctx context.Context) error) error <span class="cov1" title="1">{
        logger.Debug("Reconnect callback registered for memory eventbus (no-op)")
        return nil
}</span>

// memoryPublisher 实现

// Publish 发布消息
func (p *memoryPublisher) Publish(ctx context.Context, topic string, message []byte) error <span class="cov10" title="1116">{
        return p.eventBus.Publish(ctx, topic, message)
}</span>

// Close 关闭发布器
func (p *memoryPublisher) Close() error <span class="cov7" title="132">{
        logger.Debug("Memory publisher closed")
        return nil
}</span>

// memorySubscriber 实现

// Subscribe 订阅消息
func (s *memorySubscriber) Subscribe(ctx context.Context, topic string, handler MessageHandler) error <span class="cov6" title="68">{
        return s.eventBus.Subscribe(ctx, topic, handler)
}</span>

// Close 关闭订阅器
func (s *memorySubscriber) Close() error <span class="cov7" title="132">{
        logger.Debug("Memory subscriber closed")
        return nil
}</span>

// 更新 eventBusManager 的 initMemory 方法
func (m *eventBusManager) initMemory() (EventBus, error) <span class="cov7" title="109">{
        bus := &amp;memoryEventBus{
                subscribers: make(map[string][]MessageHandler),
                metrics: &amp;Metrics{
                        LastHealthCheck:   time.Now(),
                        HealthCheckStatus: "healthy",
                },
        }

        m.publisher = &amp;memoryPublisher{eventBus: bus}
        m.subscriber = &amp;memorySubscriber{eventBus: bus}
        m.metrics = bus.metrics
        m.healthStatus = &amp;HealthStatus{
                Overall:   "healthy",
                Timestamp: time.Now(),
                Infrastructure: InfrastructureHealth{
                        EventBus: EventBusHealthMetrics{
                                ConnectionStatus: "connected",
                        },
                },
                Details: map[string]interface{}{"type": "memory"},
        }

        logger.Info("Memory eventbus initialized successfully")
        return m, nil
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package eventbus

import (
        "fmt"
        "strconv"
        "time"
)

// DefaultMessageFormatter 默认消息格式化器
type DefaultMessageFormatter struct{}

// FormatMessage 格式化消息
func (f *DefaultMessageFormatter) FormatMessage(uuid string, aggregateID interface{}, payload []byte) (*Message, error) <span class="cov7" title="11">{
        msg := NewMessage(uuid, payload)
        
        // 提取聚合ID
        aggID := f.ExtractAggregateID(aggregateID)
        if aggID != "" </span><span class="cov7" title="10">{
                msg.Metadata["aggregateID"] = aggID
        }</span>
        
        // 添加时间戳
        <span class="cov7" title="11">msg.Metadata["timestamp"] = time.Now().Format(time.RFC3339)
        
        return msg, nil</span>
}

// ExtractAggregateID 提取聚合ID
func (f *DefaultMessageFormatter) ExtractAggregateID(aggregateID interface{}) string <span class="cov9" title="24">{
        if aggregateID == nil </span><span class="cov3" title="3">{
                return ""
        }</span>
        
        <span class="cov8" title="21">switch id := aggregateID.(type) </span>{
        case string:<span class="cov7" title="14">
                return id</span>
        case int64:<span class="cov1" title="1">
                return strconv.FormatInt(id, 10)</span>
        case int:<span class="cov1" title="1">
                return strconv.Itoa(id)</span>
        case int32:<span class="cov1" title="1">
                return strconv.FormatInt(int64(id), 10)</span>
        case uint64:<span class="cov1" title="1">
                return strconv.FormatUint(id, 10)</span>
        case uint32:<span class="cov1" title="1">
                return strconv.FormatUint(uint64(id), 10)</span>
        case uint:<span class="cov1" title="1">
                return strconv.FormatUint(uint64(id), 10)</span>
        default:<span class="cov1" title="1">
                return fmt.Sprintf("%v", id)</span>
        }
}

// SetMetadata 设置元数据
func (f *DefaultMessageFormatter) SetMetadata(msg *Message, metadata map[string]string) error <span class="cov2" title="2">{
        if msg.Metadata == nil </span><span class="cov0" title="0">{
                msg.Metadata = make(map[string]string)
        }</span>
        
        <span class="cov2" title="2">for k, v := range metadata </span><span class="cov3" title="3">{
                msg.Metadata[k] = v
        }</span>
        
        <span class="cov2" title="2">return nil</span>
}

// EvidenceMessageFormatter 业务特定的消息格式化器（用于 evidence-management）
type EvidenceMessageFormatter struct {
        DefaultMessageFormatter
}

// FormatMessage 格式化消息（evidence-management 特定）
func (f *EvidenceMessageFormatter) FormatMessage(uuid string, aggregateID interface{}, payload []byte) (*Message, error) <span class="cov1" title="1">{
        msg, err := f.DefaultMessageFormatter.FormatMessage(uuid, aggregateID, payload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // 业务特定的元数据字段名（evidence-management 使用 aggregate_id）
        <span class="cov1" title="1">if aggID := f.ExtractAggregateID(aggregateID); aggID != "" </span><span class="cov1" title="1">{
                msg.Metadata["aggregate_id"] = aggID // 保持与现有代码兼容
                // 同时保留标准字段名以便兼容
                msg.Metadata["aggregateID"] = aggID
        }</span>
        
        <span class="cov1" title="1">return msg, nil</span>
}

// JSONMessageFormatter JSON格式的消息格式化器
type JSONMessageFormatter struct {
        DefaultMessageFormatter
        IncludeHeaders bool // 是否包含头部信息
}

// FormatMessage 格式化为JSON消息
func (f *JSONMessageFormatter) FormatMessage(uuid string, aggregateID interface{}, payload []byte) (*Message, error) <span class="cov3" title="3">{
        msg, err := f.DefaultMessageFormatter.FormatMessage(uuid, aggregateID, payload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // 添加JSON特定的元数据
        <span class="cov3" title="3">msg.Metadata["contentType"] = "application/json"
        msg.Metadata["encoding"] = "utf-8"
        
        if f.IncludeHeaders </span><span class="cov2" title="2">{
                msg.Metadata["messageFormat"] = "json"
                msg.Metadata["schemaVersion"] = "1.0"
        }</span>
        
        <span class="cov3" title="3">return msg, nil</span>
}

// ProtobufMessageFormatter Protobuf格式的消息格式化器
type ProtobufMessageFormatter struct {
        DefaultMessageFormatter
        SchemaRegistry string // Schema注册中心地址
}

// FormatMessage 格式化为Protobuf消息
func (f *ProtobufMessageFormatter) FormatMessage(uuid string, aggregateID interface{}, payload []byte) (*Message, error) <span class="cov2" title="2">{
        msg, err := f.DefaultMessageFormatter.FormatMessage(uuid, aggregateID, payload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // 添加Protobuf特定的元数据
        <span class="cov2" title="2">msg.Metadata["contentType"] = "application/x-protobuf"
        msg.Metadata["messageFormat"] = "protobuf"
        
        if f.SchemaRegistry != "" </span><span class="cov1" title="1">{
                msg.Metadata["schemaRegistry"] = f.SchemaRegistry
        }</span>
        
        <span class="cov2" title="2">return msg, nil</span>
}

// AvroMessageFormatter Avro格式的消息格式化器
type AvroMessageFormatter struct {
        DefaultMessageFormatter
        SchemaID       string // Schema ID
        SchemaRegistry string // Schema注册中心地址
}

// FormatMessage 格式化为Avro消息
func (f *AvroMessageFormatter) FormatMessage(uuid string, aggregateID interface{}, payload []byte) (*Message, error) <span class="cov1" title="1">{
        msg, err := f.DefaultMessageFormatter.FormatMessage(uuid, aggregateID, payload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // 添加Avro特定的元数据
        <span class="cov1" title="1">msg.Metadata["contentType"] = "application/avro"
        msg.Metadata["messageFormat"] = "avro"
        
        if f.SchemaID != "" </span><span class="cov1" title="1">{
                msg.Metadata["schemaId"] = f.SchemaID
        }</span>
        
        <span class="cov1" title="1">if f.SchemaRegistry != "" </span><span class="cov1" title="1">{
                msg.Metadata["schemaRegistry"] = f.SchemaRegistry
        }</span>
        
        <span class="cov1" title="1">return msg, nil</span>
}

// CloudEventMessageFormatter CloudEvents格式的消息格式化器
type CloudEventMessageFormatter struct {
        DefaultMessageFormatter
        Source      string // 事件源
        EventType   string // 事件类型
        SpecVersion string // CloudEvents规范版本
}

// FormatMessage 格式化为CloudEvents消息
func (f *CloudEventMessageFormatter) FormatMessage(uuid string, aggregateID interface{}, payload []byte) (*Message, error) <span class="cov2" title="2">{
        msg, err := f.DefaultMessageFormatter.FormatMessage(uuid, aggregateID, payload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // 添加CloudEvents特定的元数据
        <span class="cov2" title="2">msg.Metadata["ce-specversion"] = f.getSpecVersion()
        msg.Metadata["ce-type"] = f.getEventType()
        msg.Metadata["ce-source"] = f.getSource()
        msg.Metadata["ce-id"] = uuid
        msg.Metadata["ce-time"] = time.Now().Format(time.RFC3339)
        msg.Metadata["content-type"] = "application/json"
        
        if aggID := f.ExtractAggregateID(aggregateID); aggID != "" </span><span class="cov1" title="1">{
                msg.Metadata["ce-subject"] = aggID
        }</span>
        
        <span class="cov2" title="2">return msg, nil</span>
}

func (f *CloudEventMessageFormatter) getSpecVersion() string <span class="cov2" title="2">{
        if f.SpecVersion != "" </span><span class="cov1" title="1">{
                return f.SpecVersion
        }</span>
        <span class="cov1" title="1">return "1.0"</span>
}

func (f *CloudEventMessageFormatter) getEventType() string <span class="cov2" title="2">{
        if f.EventType != "" </span><span class="cov1" title="1">{
                return f.EventType
        }</span>
        <span class="cov1" title="1">return "com.jxt.event"</span>
}

func (f *CloudEventMessageFormatter) getSource() string <span class="cov2" title="2">{
        if f.Source != "" </span><span class="cov1" title="1">{
                return f.Source
        }</span>
        <span class="cov1" title="1">return "jxt-core"</span>
}

// MessageFormatterChain 消息格式化器链
type MessageFormatterChain struct {
        formatters []MessageFormatter
}

// NewMessageFormatterChain 创建消息格式化器链
func NewMessageFormatterChain(formatters ...MessageFormatter) *MessageFormatterChain <span class="cov5" title="6">{
        return &amp;MessageFormatterChain{
                formatters: formatters,
        }
}</span>

// FormatMessage 链式格式化消息
func (c *MessageFormatterChain) FormatMessage(uuid string, aggregateID interface{}, payload []byte) (*Message, error) <span class="cov2" title="2">{
        if len(c.formatters) == 0 </span><span class="cov1" title="1">{
                return NewMessage(uuid, payload), nil
        }</span>
        
        // 使用第一个格式化器创建基础消息
        <span class="cov1" title="1">msg, err := c.formatters[0].FormatMessage(uuid, aggregateID, payload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // 依次应用其他格式化器的元数据
        <span class="cov1" title="1">for i := 1; i &lt; len(c.formatters); i++ </span><span class="cov1" title="1">{
                tempMsg, err := c.formatters[i].FormatMessage(uuid, aggregateID, payload)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                
                // 合并元数据
                <span class="cov1" title="1">for k, v := range tempMsg.Metadata </span><span class="cov5" title="6">{
                        msg.Metadata[k] = v
                }</span>
        }
        
        <span class="cov1" title="1">return msg, nil</span>
}

// ExtractAggregateID 提取聚合ID
func (c *MessageFormatterChain) ExtractAggregateID(aggregateID interface{}) string <span class="cov2" title="2">{
        if len(c.formatters) == 0 </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov1" title="1">return c.formatters[0].ExtractAggregateID(aggregateID)</span>
}

// SetMetadata 设置元数据
func (c *MessageFormatterChain) SetMetadata(msg *Message, metadata map[string]string) error <span class="cov2" title="2">{
        if len(c.formatters) == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("no formatters in chain")
        }</span>
        <span class="cov1" title="1">return c.formatters[0].SetMetadata(msg, metadata)</span>
}

// MessageFormatterRegistry 消息格式化器注册表
type MessageFormatterRegistry struct {
        formatters map[string]MessageFormatter
}

// NewMessageFormatterRegistry 创建消息格式化器注册表
func NewMessageFormatterRegistry() *MessageFormatterRegistry <span class="cov5" title="5">{
        registry := &amp;MessageFormatterRegistry{
                formatters: make(map[string]MessageFormatter),
        }
        
        // 注册默认格式化器
        registry.Register("default", &amp;DefaultMessageFormatter{})
        registry.Register("evidence", &amp;EvidenceMessageFormatter{})
        registry.Register("json", &amp;JSONMessageFormatter{IncludeHeaders: true})
        registry.Register("protobuf", &amp;ProtobufMessageFormatter{})
        registry.Register("avro", &amp;AvroMessageFormatter{})
        registry.Register("cloudevents", &amp;CloudEventMessageFormatter{})
        
        return registry
}</span>

// Register 注册格式化器
func (r *MessageFormatterRegistry) Register(name string, formatter MessageFormatter) <span class="cov10" title="31">{
        r.formatters[name] = formatter
}</span>

// Get 获取格式化器
func (r *MessageFormatterRegistry) Get(name string) (MessageFormatter, bool) <span class="cov4" title="4">{
        formatter, exists := r.formatters[name]
        return formatter, exists
}</span>

// GetOrDefault 获取格式化器或返回默认格式化器
func (r *MessageFormatterRegistry) GetOrDefault(name string) MessageFormatter <span class="cov2" title="2">{
        if formatter, exists := r.formatters[name]; exists </span><span class="cov1" title="1">{
                return formatter
        }</span>
        <span class="cov1" title="1">return &amp;DefaultMessageFormatter{}</span>
}

// List 列出所有注册的格式化器
func (r *MessageFormatterRegistry) List() []string <span class="cov1" title="1">{
        names := make([]string, 0, len(r.formatters))
        for name := range r.formatters </span><span class="cov5" title="6">{
                names = append(names, name)
        }</span>
        <span class="cov1" title="1">return names</span>
}

// 全局格式化器注册表
var GlobalFormatterRegistry = NewMessageFormatterRegistry()
</pre>
		
		<pre class="file" id="file13" style="display: none">package eventbus

import (
        "context"
        "fmt"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/nats-io/nats.go"
        "go.uber.org/zap"

        "github.com/ChenBigdata421/jxt-core/sdk/config"
        "github.com/ChenBigdata421/jxt-core/sdk/pkg/logger"
)

// natsEventBus NATS JetStream事件总线实现
// 企业级增强版本，专注于JetStream持久化消息
// 支持方案A（Envelope）消息包络
type natsEventBus struct {
        conn               *nats.Conn
        js                 nats.JetStreamContext
        config             *config.NATSConfig
        subscriptions      map[string]*nats.Subscription
        consumers          map[string]nats.ConsumerInfo
        logger             *zap.Logger
        mu                 sync.RWMutex
        closed             bool
        reconnectCallbacks []func(ctx context.Context) error

        // 企业级特性
        publishedMessages atomic.Int64
        consumedMessages  atomic.Int64
        errorCount        atomic.Int64
        lastHealthCheck   atomic.Value // time.Time
        healthStatus      atomic.Bool

        // 增强的企业级特性
        metricsCollector *time.Ticker
        metrics          *Metrics
        messageFormatter MessageFormatter
        publishCallback  PublishCallback
        errorHandler     ErrorHandler
        messageRouter    MessageRouter

        // 健康检查控制
        healthCheckCancel context.CancelFunc
        healthCheckDone   chan struct{}

        // 自动重连控制
        reconnectConfig   ReconnectConfig
        failureCount      atomic.Int32
        lastReconnectTime atomic.Value // time.Time
        reconnectCallback ReconnectCallback

        // 订阅管理（用于重连后恢复订阅）
        subscriptionHandlers map[string]MessageHandler // topic -&gt; handler
        subscriptionsMu      sync.RWMutex

        // 积压检测器
        backlogDetector          *NATSBacklogDetector      // 订阅端积压检测器
        publisherBacklogDetector *PublisherBacklogDetector // 发送端积压检测器

        // 完整配置（用于访问 Publisher/Subscriber 配置）
        fullConfig *EventBusConfig

        // Keyed-Worker池管理（与Kafka保持一致）
        keyedPools   map[string]*KeyedWorkerPool // topic -&gt; pool
        keyedPoolsMu sync.RWMutex

        // 主题配置管理
        topicConfigs          map[string]TopicOptions
        topicConfigsMu        sync.RWMutex
        topicConfigStrategy   TopicConfigStrategy       // 配置策略
        topicConfigOnMismatch TopicConfigMismatchAction // 配置不一致时的行为

        // 健康检查订阅监控器
        healthCheckSubscriber *HealthCheckSubscriber
        // 健康检查发布器
        healthChecker *HealthChecker
}

// NewNATSEventBus 创建NATS JetStream事件总线
func NewNATSEventBus(config *config.NATSConfig) (EventBus, error) <span class="cov4" title="7">{
        return NewNATSEventBusWithFullConfig(config, nil)
}</span>

// NewNATSEventBusWithFullConfig 创建NATS JetStream事件总线（带完整配置）
func NewNATSEventBusWithFullConfig(config *config.NATSConfig, fullConfig *EventBusConfig) (EventBus, error) <span class="cov4" title="7">{
        // 构建连接选项
        opts := buildNATSOptions(config)

        // 连接到NATS服务器
        var nc *nats.Conn
        var err error

        if len(config.URLs) &gt; 0 </span><span class="cov4" title="7">{
                nc, err = nats.Connect(config.URLs[0], opts...)
        }</span> else<span class="cov0" title="0"> {
                nc, err = nats.Connect(nats.DefaultURL, opts...)
        }</span>

        <span class="cov4" title="7">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to NATS: %w", err)
        }</span>

        // 创建JetStream上下文（如果启用）
        <span class="cov4" title="7">var js nats.JetStreamContext
        if config.JetStream.Enabled </span><span class="cov1" title="1">{
                jsOpts := buildJetStreamOptions(config)
                js, err = nc.JetStream(jsOpts...)
                if err != nil </span><span class="cov0" title="0">{
                        nc.Close()
                        return nil, fmt.Errorf("failed to create JetStream context: %w", err)
                }</span>

                // 确保流存在
                <span class="cov1" title="1">if err := ensureStream(js, config); err != nil </span><span class="cov0" title="0">{
                        nc.Close()
                        return nil, fmt.Errorf("failed to ensure stream: %w", err)
                }</span>
        }

        // 初始化指标收集器（简化版本）

        // 获取配置策略（从环境变量或使用默认值）
        <span class="cov4" title="7">configStrategy := StrategyCreateOrUpdate
        configOnMismatch := TopicConfigMismatchAction{
                LogLevel: "warn",
                FailFast: false,
        }

        eventBus := &amp;natsEventBus{
                conn:                  nc,
                js:                    js,
                config:                config,
                fullConfig:            fullConfig,
                subscriptions:         make(map[string]*nats.Subscription),
                consumers:             make(map[string]nats.ConsumerInfo),
                logger:                logger.Logger,
                metricsCollector:      time.NewTicker(DefaultMetricsCollectInterval),
                reconnectConfig:       DefaultReconnectConfig(),
                subscriptionHandlers:  make(map[string]MessageHandler),
                keyedPools:            make(map[string]*KeyedWorkerPool), // 初始化Keyed-Worker池映射
                topicConfigs:          make(map[string]TopicOptions),     // 初始化主题配置映射
                topicConfigStrategy:   configStrategy,                    // 设置配置策略
                topicConfigOnMismatch: configOnMismatch,                  // 设置不一致处理行为
                metrics: &amp;Metrics{
                        LastHealthCheck:   time.Now(),
                        HealthCheckStatus: "healthy",
                },
        }

        // 设置重连处理器来执行重连回调
        nc.SetReconnectHandler(func(nc *nats.Conn) </span><span class="cov0" title="0">{
                eventBus.logger.Info("NATS reconnected", zap.String("url", nc.ConnectedUrl()))
                // 重置失败计数
                eventBus.failureCount.Store(0)
                // 更新重连时间
                eventBus.lastReconnectTime.Store(time.Now())
                // 恢复订阅
                eventBus.restoreSubscriptions(context.Background())
                // 执行重连回调
                eventBus.executeReconnectCallbacks()
        }</span>)

        // 初始化健康状态
        <span class="cov4" title="7">eventBus.lastHealthCheck.Store(time.Now())
        eventBus.healthStatus.Store(true)

        // 启动指标收集协程
        go eventBus.collectMetrics()

        // 根据配置初始化积压检测器
        if fullConfig != nil </span><span class="cov0" title="0">{
                // 初始化订阅端积压检测器
                if fullConfig.Enterprise.Subscriber.BacklogDetection.Enabled </span><span class="cov0" title="0">{
                        backlogConfig := BacklogDetectionConfig{
                                MaxLagThreshold:  fullConfig.Enterprise.Subscriber.BacklogDetection.MaxLagThreshold,
                                MaxTimeThreshold: fullConfig.Enterprise.Subscriber.BacklogDetection.MaxTimeThreshold,
                                CheckInterval:    fullConfig.Enterprise.Subscriber.BacklogDetection.CheckInterval,
                        }
                        eventBus.backlogDetector = NewNATSBacklogDetector(js, nc, config.JetStream.Stream.Name, backlogConfig)
                        logger.Logger.Info("NATS JetStream subscriber backlog detector initialized",
                                zap.String("stream", config.JetStream.Stream.Name),
                                zap.Int64("maxLagThreshold", backlogConfig.MaxLagThreshold),
                                zap.Duration("maxTimeThreshold", backlogConfig.MaxTimeThreshold),
                                zap.Duration("checkInterval", backlogConfig.CheckInterval))
                }</span>

                // 初始化发送端积压检测器
                <span class="cov0" title="0">if fullConfig.Enterprise.Publisher.BacklogDetection.Enabled </span><span class="cov0" title="0">{
                        // NATS 发送端积压检测器需要特殊的实现，这里暂时使用通用的
                        // 注意：NATS 的发送端积压检测可能需要不同的实现方式
                        eventBus.publisherBacklogDetector = NewPublisherBacklogDetector(nil, nil, fullConfig.Enterprise.Publisher.BacklogDetection)
                        logger.Logger.Info("NATS JetStream publisher backlog detector initialized",
                                zap.Int64("maxQueueDepth", fullConfig.Enterprise.Publisher.BacklogDetection.MaxQueueDepth),
                                zap.Duration("maxPublishLatency", fullConfig.Enterprise.Publisher.BacklogDetection.MaxPublishLatency),
                                zap.Float64("rateThreshold", fullConfig.Enterprise.Publisher.BacklogDetection.RateThreshold),
                                zap.Duration("checkInterval", fullConfig.Enterprise.Publisher.BacklogDetection.CheckInterval))
                }</span>
        } else<span class="cov4" title="7"> {
                // 如果没有完整配置，使用默认的订阅端积压检测器（向后兼容）
                backlogConfig := BacklogDetectionConfig{
                        MaxLagThreshold:  1000,             // 默认最大延迟阈值
                        MaxTimeThreshold: 5 * time.Minute,  // 默认最大时间阈值
                        CheckInterval:    30 * time.Second, // 默认检查间隔
                }
                eventBus.backlogDetector = NewNATSBacklogDetector(js, nc, config.JetStream.Stream.Name, backlogConfig)
                logger.Logger.Info("NATS JetStream backlog detector initialized (default config)",
                        zap.String("stream", config.JetStream.Stream.Name))
        }</span>

        <span class="cov4" title="7">logger.Logger.Info("NATS JetStream EventBus initialized successfully",
                zap.String("client_id", config.ClientID),
                zap.Bool("jetstream_enabled", config.JetStream.Enabled))

        return eventBus, nil</span>
}

// buildNATSOptions 构建NATS连接选项
func buildNATSOptions(config *config.NATSConfig) []nats.Option <span class="cov5" title="9">{
        opts := []nats.Option{
                nats.MaxReconnects(config.MaxReconnects),
                nats.ReconnectWait(config.ReconnectWait),
                nats.Timeout(config.ConnectionTimeout),
                nats.DisconnectErrHandler(func(nc *nats.Conn, err error) </span><span class="cov4" title="7">{
                        logger.Logger.Warn("NATS disconnected", zap.Error(err))
                }</span>),
                nats.ClosedHandler(func(nc *nats.Conn) <span class="cov4" title="7">{
                        logger.Logger.Info("NATS connection closed")
                }</span>),
        }

        // 添加安全配置
        <span class="cov5" title="9">if config.Security.Enabled </span><span class="cov1" title="1">{
                if config.Security.Token != "" </span><span class="cov0" title="0">{
                        opts = append(opts, nats.Token(config.Security.Token))
                }</span>
                <span class="cov1" title="1">if config.Security.Username != "" &amp;&amp; config.Security.Password != "" </span><span class="cov1" title="1">{
                        opts = append(opts, nats.UserInfo(config.Security.Username, config.Security.Password))
                }</span>
                <span class="cov1" title="1">if config.Security.NKeyFile != "" </span><span class="cov0" title="0">{
                        opts = append(opts, nats.UserCredentials(config.Security.NKeyFile))
                }</span>
                <span class="cov1" title="1">if config.Security.CredFile != "" </span><span class="cov0" title="0">{
                        opts = append(opts, nats.UserCredentials(config.Security.CredFile))
                }</span>
                <span class="cov1" title="1">if config.Security.CertFile != "" &amp;&amp; config.Security.KeyFile != "" </span><span class="cov0" title="0">{
                        opts = append(opts, nats.ClientCert(config.Security.CertFile, config.Security.KeyFile))
                }</span>
                <span class="cov1" title="1">if config.Security.CAFile != "" </span><span class="cov0" title="0">{
                        opts = append(opts, nats.RootCAs(config.Security.CAFile))
                }</span>
                <span class="cov1" title="1">if config.Security.SkipVerify </span><span class="cov0" title="0">{
                        opts = append(opts, nats.Secure())
                }</span>
        }

        <span class="cov5" title="9">return opts</span>
}

// buildJetStreamOptions 构建JetStream选项
func buildJetStreamOptions(config *config.NATSConfig) []nats.JSOpt <span class="cov3" title="3">{
        var opts []nats.JSOpt

        if config.JetStream.Domain != "" </span><span class="cov1" title="1">{
                opts = append(opts, nats.Domain(config.JetStream.Domain))
        }</span>
        <span class="cov3" title="3">if config.JetStream.APIPrefix != "" </span><span class="cov0" title="0">{
                opts = append(opts, nats.APIPrefix(config.JetStream.APIPrefix))
        }</span>
        <span class="cov3" title="3">if config.JetStream.PublishTimeout &gt; 0 </span><span class="cov0" title="0">{
                opts = append(opts, nats.PublishAsyncMaxPending(256))
        }</span>

        <span class="cov3" title="3">return opts</span>
}

// ensureStream 确保流存在
func ensureStream(js nats.JetStreamContext, config *config.NATSConfig) error <span class="cov1" title="1">{
        streamConfig := &amp;nats.StreamConfig{
                Name:      config.JetStream.Stream.Name,
                Subjects:  config.JetStream.Stream.Subjects,
                Retention: parseRetentionPolicy(config.JetStream.Stream.Retention),
                Storage:   parseStorageType(config.JetStream.Stream.Storage),
                Replicas:  config.JetStream.Stream.Replicas,
                MaxAge:    config.JetStream.Stream.MaxAge,
                MaxBytes:  config.JetStream.Stream.MaxBytes,
                MaxMsgs:   config.JetStream.Stream.MaxMsgs,
                Discard:   parseDiscardPolicy(config.JetStream.Stream.Discard),
        }

        // 尝试获取流信息
        _, err := js.StreamInfo(streamConfig.Name)
        if err != nil </span><span class="cov0" title="0">{
                // 流不存在，创建新流
                _, err = js.AddStream(streamConfig)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create stream %s: %w", streamConfig.Name, err)
                }</span>
                <span class="cov0" title="0">logger.Logger.Info("Created JetStream stream", zap.String("name", streamConfig.Name))</span>
        } else<span class="cov1" title="1"> {
                // 流已存在，更新配置
                _, err = js.UpdateStream(streamConfig)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update stream %s: %w", streamConfig.Name, err)
                }</span>
                <span class="cov1" title="1">logger.Logger.Info("Updated JetStream stream", zap.String("name", streamConfig.Name))</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// parseRetentionPolicy 解析保留策略
func parseRetentionPolicy(policy string) nats.RetentionPolicy <span class="cov1" title="1">{
        switch policy </span>{
        case "limits":<span class="cov0" title="0">
                return nats.LimitsPolicy</span>
        case "interest":<span class="cov0" title="0">
                return nats.InterestPolicy</span>
        case "workqueue":<span class="cov0" title="0">
                return nats.WorkQueuePolicy</span>
        default:<span class="cov1" title="1">
                return nats.LimitsPolicy</span>
        }
}

// parseStorageType 解析存储类型
func parseStorageType(storage string) nats.StorageType <span class="cov1" title="1">{
        switch storage </span>{
        case "file":<span class="cov0" title="0">
                return nats.FileStorage</span>
        case "memory":<span class="cov1" title="1">
                return nats.MemoryStorage</span>
        default:<span class="cov0" title="0">
                return nats.FileStorage</span>
        }
}

// parseDiscardPolicy 解析丢弃策略
func parseDiscardPolicy(policy string) nats.DiscardPolicy <span class="cov1" title="1">{
        switch policy </span>{
        case "old":<span class="cov0" title="0">
                return nats.DiscardOld</span>
        case "new":<span class="cov0" title="0">
                return nats.DiscardNew</span>
        default:<span class="cov1" title="1">
                return nats.DiscardOld</span>
        }
}

// parseDeliverPolicy 解析投递策略
func parseDeliverPolicy(policy string) nats.DeliverPolicy <span class="cov1" title="1">{
        switch policy </span>{
        case "all":<span class="cov0" title="0">
                return nats.DeliverAllPolicy</span>
        case "last":<span class="cov0" title="0">
                return nats.DeliverLastPolicy</span>
        case "new":<span class="cov0" title="0">
                return nats.DeliverNewPolicy</span>
        case "by_start_sequence":<span class="cov0" title="0">
                return nats.DeliverByStartSequencePolicy</span>
        case "by_start_time":<span class="cov0" title="0">
                return nats.DeliverByStartTimePolicy</span>
        default:<span class="cov1" title="1">
                return nats.DeliverAllPolicy</span>
        }
}

// parseAckPolicy 解析确认策略
func parseAckPolicy(policy string) nats.AckPolicy <span class="cov1" title="1">{
        switch policy </span>{
        case "none":<span class="cov0" title="0">
                return nats.AckNonePolicy</span>
        case "all":<span class="cov0" title="0">
                return nats.AckAllPolicy</span>
        case "explicit":<span class="cov0" title="0">
                return nats.AckExplicitPolicy</span>
        default:<span class="cov1" title="1">
                return nats.AckExplicitPolicy</span>
        }
}

// parseReplayPolicy 解析重放策略
func parseReplayPolicy(policy string) nats.ReplayPolicy <span class="cov1" title="1">{
        switch policy </span>{
        case "instant":<span class="cov0" title="0">
                return nats.ReplayInstantPolicy</span>
        case "original":<span class="cov0" title="0">
                return nats.ReplayOriginalPolicy</span>
        default:<span class="cov1" title="1">
                return nats.ReplayInstantPolicy</span>
        }
}

// Publish 发布消息到指定主题
func (n *natsEventBus) Publish(ctx context.Context, topic string, message []byte) error <span class="cov10" title="104">{
        start := time.Now()

        n.mu.RLock()
        if n.closed </span><span class="cov0" title="0">{
                n.mu.RUnlock()
                return fmt.Errorf("eventbus is closed")
        }</span>
        <span class="cov10" title="104">n.mu.RUnlock()

        // 获取主题配置
        topicConfig, _ := n.GetTopicConfig(topic)

        // 决定发布模式：优先使用主题配置，其次使用全局配置
        shouldUsePersistent := topicConfig.IsPersistent(n.config.JetStream.Enabled)

        var err error

        if shouldUsePersistent &amp;&amp; n.js != nil </span><span class="cov0" title="0">{
                // 确保主题在JetStream中存在（如果需要持久化）
                if err := n.ensureTopicInJetStream(topic, topicConfig); err != nil </span><span class="cov0" title="0">{
                        n.logger.Warn("Failed to ensure topic in JetStream, falling back to Core NATS",
                                zap.String("topic", topic),
                                zap.Error(err))
                        // 降级到Core NATS
                        shouldUsePersistent = false
                }</span>
        }

        <span class="cov10" title="104">if shouldUsePersistent &amp;&amp; n.js != nil </span><span class="cov0" title="0">{
                // 使用JetStream发布（持久化）
                var pubOpts []nats.PubOpt
                if n.config.JetStream.PublishTimeout &gt; 0 </span><span class="cov0" title="0">{
                        pubOpts = append(pubOpts, nats.AckWait(n.config.JetStream.PublishTimeout))
                }</span>

                <span class="cov0" title="0">_, err = n.js.Publish(topic, message, pubOpts...)
                if err != nil </span><span class="cov0" title="0">{
                        n.errorCount.Add(1)
                        n.logger.Error("Failed to publish message to NATS JetStream",
                                zap.String("topic", topic),
                                zap.Bool("persistent", true),
                                zap.String("persistenceMode", string(topicConfig.PersistenceMode)),
                                zap.Error(err))
                        return err
                }</span>
        } else<span class="cov10" title="104"> {
                // 使用Core NATS发布（非持久化）
                err = n.conn.Publish(topic, message)
                if err != nil </span><span class="cov0" title="0">{
                        n.errorCount.Add(1)
                        n.logger.Error("Failed to publish message to NATS Core",
                                zap.String("topic", topic),
                                zap.Bool("persistent", false),
                                zap.String("persistenceMode", string(topicConfig.PersistenceMode)),
                                zap.Error(err))
                        return err
                }</span>
        }

        // 记录指标
        <span class="cov10" title="104">duration := time.Since(start)

        // 记录发布指标
        if n.metrics != nil </span><span class="cov10" title="104">{
                n.metrics.LastHealthCheck = time.Now()
                if err != nil </span><span class="cov0" title="0">{
                        n.metrics.PublishErrors++
                }</span> else<span class="cov10" title="104"> {
                        n.metrics.MessagesPublished++
                }</span>
        }

        <span class="cov10" title="104">if err == nil </span><span class="cov10" title="104">{
                n.publishedMessages.Add(1)
                n.logger.Debug("Message published to NATS",
                        zap.String("topic", topic),
                        zap.Int("message_size", len(message)),
                        zap.Bool("persistent", n.config.JetStream.Enabled),
                        zap.String("mode", func() string </span><span class="cov10" title="104">{
                                if n.config.JetStream.Enabled &amp;&amp; n.js != nil </span><span class="cov0" title="0">{
                                        return "JetStream"
                                }</span>
                                <span class="cov10" title="104">return "Core"</span>
                        }()),
                        zap.Duration("duration", duration))
                <span class="cov10" title="104">return nil</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("failed to publish message: %w", err)</span>
}

// Subscribe 订阅原始消息（不使用Keyed-Worker池）
//
// 特点：
// - 消息格式：原始字节数据
// - 处理模式：直接并发处理，无顺序保证
// - 性能：极致性能，微秒级延迟（NATS Core: 7.86µs - 136µs）
// - 聚合ID：通常无法从原始消息中提取聚合ID
// - Keyed-Worker池：不使用（因为无聚合ID）
//
// 适用场景：
// - 简单消息传递（通知、提醒）
// - 缓存失效消息
// - 系统监控指标
// - 跨Docker容器通信
// - 不需要顺序保证的业务场景
//
// 示例：
//
//        bus.Subscribe(ctx, "notifications", func(ctx context.Context, data []byte) error {
//            var notification Notification
//            json.Unmarshal(data, &amp;notification)
//            return processNotification(notification) // 直接并发处理
//        })
func (n *natsEventBus) Subscribe(ctx context.Context, topic string, handler MessageHandler) error <span class="cov5" title="8">{
        n.mu.Lock()
        defer n.mu.Unlock()

        if n.closed </span><span class="cov0" title="0">{
                return fmt.Errorf("eventbus is closed")
        }</span>

        // 检查是否已经订阅了该主题
        <span class="cov5" title="8">if _, exists := n.subscriptions[topic]; exists </span><span class="cov1" title="1">{
                return fmt.Errorf("already subscribed to topic: %s", topic)
        }</span>

        // 保存订阅处理器（用于重连后恢复）
        <span class="cov4" title="7">n.subscriptionsMu.Lock()
        n.subscriptionHandlers[topic] = handler
        n.subscriptionsMu.Unlock()

        // 根据配置选择订阅模式
        var err error

        if n.config.JetStream.Enabled &amp;&amp; n.js != nil </span><span class="cov1" title="1">{
                // 使用JetStream订阅（持久化）
                err = n.subscribeJetStream(ctx, topic, handler)
        }</span> else<span class="cov4" title="6"> {
                // 使用Core NATS订阅（非持久化）
                msgHandler := func(msg *nats.Msg) </span><span class="cov9" title="103">{
                        n.handleMessage(ctx, topic, msg.Data, handler, func() error </span><span class="cov9" title="102">{
                                return nil // Core NATS不需要手动确认
                        }</span>)
                }

                <span class="cov4" title="6">sub, err := n.conn.Subscribe(topic, msgHandler)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to subscribe to topic %s with Core NATS: %w", topic, err)
                }</span>

                <span class="cov4" title="6">n.subscriptions[topic] = sub</span>
        }

        <span class="cov4" title="7">if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // ⭐ 创建per-topic Keyed-Worker池（与Kafka保持一致）
        <span class="cov4" title="6">n.keyedPoolsMu.Lock()
        if _, ok := n.keyedPools[topic]; !ok </span><span class="cov4" title="6">{
                pool := NewKeyedWorkerPool(KeyedWorkerPoolConfig{
                        WorkerCount: 1024, // 与Kafka保持一致
                        QueueSize:   1000, // 与Kafka保持一致
                        WaitTimeout: 200 * time.Millisecond,
                }, handler)
                n.keyedPools[topic] = pool
        }</span>
        <span class="cov4" title="6">n.keyedPoolsMu.Unlock()

        n.logger.Info("Subscribed to NATS topic",
                zap.String("topic", topic),
                zap.Bool("persistent", n.config.JetStream.Enabled),
                zap.String("mode", func() string </span><span class="cov4" title="6">{
                        if n.config.JetStream.Enabled &amp;&amp; n.js != nil </span><span class="cov0" title="0">{
                                return "JetStream"
                        }</span>
                        <span class="cov4" title="6">return "Core"</span>
                }()))

        <span class="cov4" title="6">return nil</span>
}

// subscribeJetStream 使用JetStream订阅
func (n *natsEventBus) subscribeJetStream(ctx context.Context, topic string, handler MessageHandler) error <span class="cov1" title="1">{
        // 构建消费者配置
        // 为每个主题生成唯一的消费者名称，避免冲突
        topicSafeName := strings.ReplaceAll(topic, ".", "_")
        durableName := fmt.Sprintf("%s-%s", n.config.JetStream.Consumer.DurableName, topicSafeName)

        consumerConfig := &amp;nats.ConsumerConfig{
                Durable:       durableName,
                DeliverPolicy: parseDeliverPolicy(n.config.JetStream.Consumer.DeliverPolicy),
                AckPolicy:     parseAckPolicy(n.config.JetStream.Consumer.AckPolicy),
                ReplayPolicy:  parseReplayPolicy(n.config.JetStream.Consumer.ReplayPolicy),
                MaxAckPending: n.config.JetStream.Consumer.MaxAckPending,
                MaxWaiting:    n.config.JetStream.Consumer.MaxWaiting,
                MaxDeliver:    n.config.JetStream.Consumer.MaxDeliver,
                BackOff:       n.config.JetStream.Consumer.BackOff,
                FilterSubject: topic,
        }

        if n.config.JetStream.AckWait &gt; 0 </span><span class="cov0" title="0">{
                consumerConfig.AckWait = n.config.JetStream.AckWait
        }</span>

        // 创建或获取消费者
        <span class="cov1" title="1">consumer, err := n.js.AddConsumer(n.config.JetStream.Stream.Name, consumerConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create consumer: %w", err)
        }</span>

        <span class="cov1" title="1">n.consumers[topic] = *consumer

        // 创建订阅
        sub, err := n.js.PullSubscribe(topic, consumerConfig.Durable)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to create pull subscription: %w", err)
        }</span>

        <span class="cov0" title="0">n.subscriptions[topic] = sub

        // 注册消费者到积压检测器
        if n.backlogDetector != nil </span><span class="cov0" title="0">{
                consumerName := fmt.Sprintf("%s-%s", topic, consumerConfig.Durable)
                n.backlogDetector.RegisterConsumer(consumerName, consumerConfig.Durable)
                n.logger.Debug("Consumer registered to NATS backlog detector",
                        zap.String("topic", topic),
                        zap.String("consumer", consumerName),
                        zap.String("durable", consumerConfig.Durable))
        }</span>

        // 启动消息处理协程
        <span class="cov0" title="0">go n.processPullMessages(ctx, topic, sub, handler)

        return nil</span>
}

// processPullMessages 处理拉取的消息
func (n *natsEventBus) processPullMessages(ctx context.Context, topic string, sub *nats.Subscription, handler MessageHandler) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0">
                        // 拉取消息
                        msgs, err := sub.Fetch(10, nats.MaxWait(time.Second))
                        if err != nil </span><span class="cov0" title="0">{
                                if err == nats.ErrTimeout </span><span class="cov0" title="0">{
                                        continue</span> // 超时是正常的，继续拉取
                                }
                                <span class="cov0" title="0">n.logger.Error("Failed to fetch messages",
                                        zap.String("topic", topic),
                                        zap.Error(err))
                                time.Sleep(time.Second)
                                continue</span>
                        }

                        // 处理消息
                        <span class="cov0" title="0">for _, msg := range msgs </span><span class="cov0" title="0">{
                                n.handleMessage(ctx, topic, msg.Data, handler, func() error </span><span class="cov0" title="0">{
                                        return msg.Ack()
                                }</span>)
                        }
                }
        }
}

// handleMessage 处理单个消息（支持方案A：Envelope优先级提取）
func (n *natsEventBus) handleMessage(ctx context.Context, topic string, data []byte, handler MessageHandler, ackFunc func() error) <span class="cov9" title="103">{
        defer func() </span><span class="cov9" title="103">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        n.errorCount.Add(1)
                        n.logger.Error("Panic in NATS message handler",
                                zap.String("topic", topic),
                                zap.Any("panic", r))
                }</span>
        }()

        // 创建带超时的上下文
        <span class="cov9" title="103">handlerCtx, cancel := context.WithTimeout(ctx, 5*time.Minute)
        defer cancel()

        // ⭐ 智能路由决策：根据聚合ID提取结果决定处理模式
        // 优先级：Envelope &gt; Header &gt; NATS Subject
        aggregateID, _ := ExtractAggregateID(data, nil, nil, topic)

        if aggregateID != "" </span><span class="cov9" title="103">{
                // ✅ 有聚合ID：使用Keyed-Worker池进行顺序处理
                // 这种情况通常发生在：
                // 1. SubscribeEnvelope订阅的Envelope消息
                // 2. NATS Subject中包含有效聚合ID的情况
                // 获取该topic的Keyed-Worker池
                n.keyedPoolsMu.RLock()
                pool := n.keyedPools[topic]
                n.keyedPoolsMu.RUnlock()

                if pool != nil </span><span class="cov9" title="103">{
                        // ⭐ 使用Keyed-Worker池处理（与Kafka保持一致）
                        aggMsg := &amp;AggregateMessage{
                                Topic:       topic,
                                Partition:   0, // NATS没有分区概念
                                Offset:      0, // NATS没有偏移量概念
                                Key:         []byte(aggregateID),
                                Value:       data,
                                Headers:     make(map[string][]byte),
                                Timestamp:   time.Now(),
                                AggregateID: aggregateID,
                                Context:     handlerCtx,
                                Done:        make(chan error, 1),
                        }

                        // 路由到Keyed-Worker池处理
                        if err := pool.ProcessMessage(handlerCtx, aggMsg); err != nil </span><span class="cov0" title="0">{
                                n.errorCount.Add(1)
                                n.logger.Error("Failed to process message with Keyed-Worker pool",
                                        zap.String("topic", topic),
                                        zap.String("aggregateID", aggregateID),
                                        zap.Error(err))
                                // 不确认消息，让它重新投递
                                return
                        }</span>

                        // 等待Worker处理完成
                        <span class="cov9" title="103">if err := &lt;-aggMsg.Done; err != nil </span><span class="cov1" title="1">{
                                n.errorCount.Add(1)
                                n.logger.Error("Failed to handle NATS message in Keyed-Worker",
                                        zap.String("topic", topic),
                                        zap.String("aggregateID", aggregateID),
                                        zap.Error(err))
                                // 不确认消息，让它重新投递
                                return
                        }</span>

                        // Worker处理成功，确认消息
                        <span class="cov9" title="102">if err := ackFunc(); err != nil </span><span class="cov0" title="0">{
                                n.logger.Error("Failed to ack NATS message",
                                        zap.String("topic", topic),
                                        zap.String("aggregateID", aggregateID),
                                        zap.Error(err))
                        }</span> else<span class="cov9" title="102"> {
                                n.consumedMessages.Add(1)
                        }</span>
                        <span class="cov9" title="102">return</span>
                }
        }

        // ❌ 无聚合ID：直接并发处理（不使用Keyed-Worker池）
        // 这种情况通常发生在：
        // 1. Subscribe订阅的原始消息（如JSON、文本等）
        // 2. 无法从消息中提取有效聚合ID的情况
        // 3. 简单消息传递场景（通知、缓存失效等）
        <span class="cov0" title="0">if err := handler(handlerCtx, data); err != nil </span><span class="cov0" title="0">{
                n.errorCount.Add(1)
                n.logger.Error("Failed to handle NATS message",
                        zap.String("topic", topic),
                        zap.Error(err))
                // 不确认消息，让它重新投递
                return
        }</span>

        // 确认消息
        <span class="cov0" title="0">if err := ackFunc(); err != nil </span><span class="cov0" title="0">{
                n.logger.Error("Failed to ack NATS message",
                        zap.String("topic", topic),
                        zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                n.consumedMessages.Add(1)
        }</span>
}

// healthCheck 内部健康检查（不对外暴露）
func (n *natsEventBus) healthCheck(ctx context.Context) error <span class="cov0" title="0">{
        n.mu.RLock()
        defer n.mu.RUnlock()

        if n.closed </span><span class="cov0" title="0">{
                n.healthStatus.Store(false)
                return fmt.Errorf("eventbus is closed")
        }</span>

        // 检查NATS连接状态
        <span class="cov0" title="0">if !n.conn.IsConnected() </span><span class="cov0" title="0">{
                n.healthStatus.Store(false)
                return fmt.Errorf("NATS connection is not active")
        }</span>

        // 检查JetStream连接状态（如果启用）
        <span class="cov0" title="0">if n.config.JetStream.Enabled &amp;&amp; n.js != nil </span><span class="cov0" title="0">{
                // 尝试获取账户信息来验证JetStream连接
                _, err := n.js.AccountInfo()
                if err != nil </span><span class="cov0" title="0">{
                        n.healthStatus.Store(false)
                        return fmt.Errorf("JetStream connection is not active: %w", err)
                }</span>
        }

        // 发送ping测试连接
        <span class="cov0" title="0">if err := n.conn.Flush(); err != nil </span><span class="cov0" title="0">{
                n.healthStatus.Store(false)
                return fmt.Errorf("NATS flush failed: %w", err)
        }</span>

        // 更新健康状态
        <span class="cov0" title="0">n.healthStatus.Store(true)
        n.lastHealthCheck.Store(time.Now())

        n.logger.Debug("NATS eventbus health check passed",
                zap.Bool("jetstream_enabled", n.config.JetStream.Enabled),
                zap.Int64("published_messages", n.publishedMessages.Load()),
                zap.Int64("consumed_messages", n.consumedMessages.Load()),
                zap.Int64("error_count", n.errorCount.Load()))

        return nil</span>
}

// Close 关闭连接
func (n *natsEventBus) Close() error <span class="cov4" title="7">{
        n.mu.Lock()
        defer n.mu.Unlock()

        if n.closed </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov4" title="7">var errs []error

        // 关闭所有订阅
        for topic, sub := range n.subscriptions </span><span class="cov4" title="6">{
                if err := sub.Unsubscribe(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("failed to unsubscribe from topic %s: %w", topic, err))
                }</span>
        }

        // 停止积压检测器
        <span class="cov4" title="7">if n.backlogDetector != nil </span><span class="cov4" title="7">{
                if err := n.backlogDetector.Stop(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("failed to stop backlog detector: %w", err))
                }</span>
        }

        // ⭐ 停止所有Keyed-Worker池
        <span class="cov4" title="7">n.keyedPoolsMu.Lock()
        for topic, pool := range n.keyedPools </span><span class="cov4" title="6">{
                pool.Stop()
                n.logger.Debug("Stopped keyed worker pool", zap.String("topic", topic))
        }</span>
        <span class="cov4" title="7">n.keyedPools = make(map[string]*KeyedWorkerPool)
        n.keyedPoolsMu.Unlock()

        // 清空订阅和消费者映射
        n.subscriptions = make(map[string]*nats.Subscription)
        n.consumers = make(map[string]nats.ConsumerInfo)

        // 关闭NATS连接
        if n.conn != nil </span><span class="cov4" title="7">{
                n.conn.Close()
        }</span>

        <span class="cov4" title="7">n.closed = true
        n.healthStatus.Store(false)

        if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                n.logger.Warn("Some errors occurred during NATS EventBus close", zap.Errors("errors", errs))
                return fmt.Errorf("errors during close: %v", errs)
        }</span>

        <span class="cov4" title="7">n.logger.Info("NATS EventBus closed successfully")
        return nil</span>
}

// RegisterReconnectCallback 注册重连回调
func (n *natsEventBus) RegisterReconnectCallback(callback ReconnectCallback) error <span class="cov0" title="0">{
        n.mu.Lock()
        defer n.mu.Unlock()

        if n.closed </span><span class="cov0" title="0">{
                return fmt.Errorf("eventbus is closed")
        }</span>

        // 保存新的回调类型
        <span class="cov0" title="0">n.reconnectCallback = callback
        // 同时保持对旧的回调列表的兼容性
        n.reconnectCallbacks = append(n.reconnectCallbacks, callback)
        n.logger.Info("NATS reconnect callback registered")
        return nil</span>
}

// executeReconnectCallbacks 执行重连回调
// 注意：这个函数在 NATS 重连回调中调用，没有父 context
// 因此使用 Background context 是合理的
func (n *natsEventBus) executeReconnectCallbacks() <span class="cov0" title="0">{
        n.mu.RLock()
        callbacks := make([]func(ctx context.Context) error, len(n.reconnectCallbacks))
        copy(callbacks, n.reconnectCallbacks)
        n.mu.RUnlock()

        // 使用 Background context，因为这是在 NATS 重连回调中调用的
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        for _, callback := range callbacks </span><span class="cov0" title="0">{
                if err := callback(ctx); err != nil </span><span class="cov0" title="0">{
                        n.logger.Error("Reconnect callback failed", zap.Error(err))
                }</span>
        }
}

// collectMetrics 收集JetStream指标
func (n *natsEventBus) collectMetrics() <span class="cov4" title="7">{
        defer n.metricsCollector.Stop()

        for </span><span class="cov6" title="14">{
                select </span>{
                case &lt;-n.metricsCollector.C:<span class="cov4" title="7">
                        n.updateJetStreamMetrics()</span>
                case &lt;-time.After(time.Minute):<span class="cov0" title="0">
                        // 防止协程泄漏，定期检查是否已关闭
                        n.mu.RLock()
                        if n.closed </span><span class="cov0" title="0">{
                                n.mu.RUnlock()
                                return
                        }</span>
                        <span class="cov0" title="0">n.mu.RUnlock()</span>
                }
        }
}

// updateJetStreamMetrics 更新JetStream指标
func (n *natsEventBus) updateJetStreamMetrics() <span class="cov4" title="7">{
        if n.js == nil </span><span class="cov4" title="6">{
                return
        }</span>

        // 获取流信息
        <span class="cov1" title="1">streamName := n.config.JetStream.Stream.Name
        if streamName != "" </span><span class="cov1" title="1">{
                if streamInfo, err := n.js.StreamInfo(streamName); err == nil </span><span class="cov0" title="0">{
                        // 更新JetStream指标
                        if n.metrics != nil </span><span class="cov0" title="0">{
                                n.metrics.MessageBacklog = int64(streamInfo.State.Msgs)
                                n.metrics.ActiveConnections = int(streamInfo.State.Consumers)
                        }</span>
                }
        }

        // 获取消费者信息
        <span class="cov1" title="1">n.mu.RLock()
        for consumerName := range n.consumers </span><span class="cov0" title="0">{
                if consumerInfo, err := n.js.ConsumerInfo(streamName, consumerName); err == nil </span><span class="cov0" title="0">{
                        // 更新消费者指标
                        if n.metrics != nil </span><span class="cov0" title="0">{
                                n.metrics.MessagesConsumed += int64(consumerInfo.Delivered.Consumer)
                        }</span>
                }
        }
        <span class="cov1" title="1">n.mu.RUnlock()</span>
}

// ========== 生命周期管理 ==========

// Start 启动事件总线
func (n *natsEventBus) Start(ctx context.Context) error <span class="cov0" title="0">{
        n.mu.Lock()
        defer n.mu.Unlock()

        if n.closed </span><span class="cov0" title="0">{
                return fmt.Errorf("nats eventbus is closed")
        }</span>

        <span class="cov0" title="0">logger.Info("NATS eventbus started successfully")
        return nil</span>
}

// Stop 停止事件总线
func (n *natsEventBus) Stop() error <span class="cov0" title="0">{
        return n.Close()
}</span>

// ========== 高级发布功能 ==========

// PublishWithOptions 使用选项发布消息
func (n *natsEventBus) PublishWithOptions(ctx context.Context, topic string, message []byte, opts PublishOptions) error <span class="cov0" title="0">{
        // 基础实现，直接调用 Publish
        return n.Publish(ctx, topic, message)
}</span>

// SetMessageFormatter 设置消息格式化器
func (n *natsEventBus) SetMessageFormatter(formatter MessageFormatter) error <span class="cov0" title="0">{
        n.mu.Lock()
        defer n.mu.Unlock()

        n.messageFormatter = formatter
        logger.Debug("Message formatter set for nats eventbus")
        return nil
}</span>

// RegisterPublishCallback 注册发布回调
func (n *natsEventBus) RegisterPublishCallback(callback PublishCallback) error <span class="cov0" title="0">{
        n.mu.Lock()
        defer n.mu.Unlock()

        n.publishCallback = callback
        logger.Debug("Publish callback registered for nats eventbus")
        return nil
}</span>

// ========== 高级订阅功能 ==========

// SubscribeWithOptions 使用选项订阅消息
func (n *natsEventBus) SubscribeWithOptions(ctx context.Context, topic string, handler MessageHandler, opts SubscribeOptions) error <span class="cov0" title="0">{
        // 基础实现，直接调用 Subscribe
        return n.Subscribe(ctx, topic, handler)
}</span>

// RegisterSubscriberBacklogCallback 注册订阅端积压回调
func (n *natsEventBus) RegisterSubscriberBacklogCallback(callback BacklogStateCallback) error <span class="cov0" title="0">{
        if n.backlogDetector != nil </span><span class="cov0" title="0">{
                return n.backlogDetector.RegisterCallback(callback)
        }</span>
        <span class="cov0" title="0">n.logger.Info("Subscriber backlog callback registered for NATS eventbus (detector not available)")
        return nil</span>
}

// StartSubscriberBacklogMonitoring 启动订阅端积压监控
func (n *natsEventBus) StartSubscriberBacklogMonitoring(ctx context.Context) error <span class="cov0" title="0">{
        if n.backlogDetector != nil </span><span class="cov0" title="0">{
                return n.backlogDetector.Start(ctx)
        }</span>
        <span class="cov0" title="0">n.logger.Info("Subscriber backlog monitoring not available for NATS eventbus")
        return nil</span>
}

// StopSubscriberBacklogMonitoring 停止订阅端积压监控
func (n *natsEventBus) StopSubscriberBacklogMonitoring() error <span class="cov0" title="0">{
        if n.backlogDetector != nil </span><span class="cov0" title="0">{
                return n.backlogDetector.Stop()
        }</span>
        <span class="cov0" title="0">n.logger.Info("Subscriber backlog monitoring not available for NATS eventbus")
        return nil</span>
}

// RegisterBacklogCallback 注册订阅端积压回调（已废弃，向后兼容）
func (n *natsEventBus) RegisterBacklogCallback(callback BacklogStateCallback) error <span class="cov0" title="0">{
        n.logger.Warn("RegisterBacklogCallback is deprecated, use RegisterSubscriberBacklogCallback instead")
        return n.RegisterSubscriberBacklogCallback(callback)
}</span>

// StartBacklogMonitoring 启动订阅端积压监控（已废弃，向后兼容）
func (n *natsEventBus) StartBacklogMonitoring(ctx context.Context) error <span class="cov0" title="0">{
        n.logger.Warn("StartBacklogMonitoring is deprecated, use StartSubscriberBacklogMonitoring instead")
        return n.StartSubscriberBacklogMonitoring(ctx)
}</span>

// StopBacklogMonitoring 停止订阅端积压监控（已废弃，向后兼容）
func (n *natsEventBus) StopBacklogMonitoring() error <span class="cov0" title="0">{
        n.logger.Warn("StopBacklogMonitoring is deprecated, use StopSubscriberBacklogMonitoring instead")
        return n.StopSubscriberBacklogMonitoring()
}</span>

// RegisterPublisherBacklogCallback 注册发送端积压回调
func (n *natsEventBus) RegisterPublisherBacklogCallback(callback PublisherBacklogCallback) error <span class="cov0" title="0">{
        if n.publisherBacklogDetector != nil </span><span class="cov0" title="0">{
                return n.publisherBacklogDetector.RegisterCallback(callback)
        }</span>
        <span class="cov0" title="0">n.logger.Debug("Publisher backlog callback registered for NATS eventbus (detector not available)")
        return nil</span>
}

// StartPublisherBacklogMonitoring 启动发送端积压监控
func (n *natsEventBus) StartPublisherBacklogMonitoring(ctx context.Context) error <span class="cov0" title="0">{
        if n.publisherBacklogDetector != nil </span><span class="cov0" title="0">{
                return n.publisherBacklogDetector.Start(ctx)
        }</span>
        <span class="cov0" title="0">n.logger.Debug("Publisher backlog monitoring not available for NATS eventbus (not configured)")
        return nil</span>
}

// StopPublisherBacklogMonitoring 停止发送端积压监控
func (n *natsEventBus) StopPublisherBacklogMonitoring() error <span class="cov0" title="0">{
        if n.publisherBacklogDetector != nil </span><span class="cov0" title="0">{
                return n.publisherBacklogDetector.Stop()
        }</span>
        <span class="cov0" title="0">n.logger.Debug("Publisher backlog monitoring not available for NATS eventbus (not configured)")
        return nil</span>
}

// StartAllBacklogMonitoring 根据配置启动所有积压监控
func (n *natsEventBus) StartAllBacklogMonitoring(ctx context.Context) error <span class="cov0" title="0">{
        var errs []error

        // 启动订阅端积压监控
        if err := n.StartSubscriberBacklogMonitoring(ctx); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf("failed to start subscriber backlog monitoring: %w", err))
        }</span>

        // 启动发送端积压监控
        <span class="cov0" title="0">if err := n.StartPublisherBacklogMonitoring(ctx); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf("failed to start publisher backlog monitoring: %w", err))
        }</span>

        <span class="cov0" title="0">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start some backlog monitoring: %v", errs)
        }</span>

        <span class="cov0" title="0">n.logger.Info("All backlog monitoring started successfully for NATS eventbus")
        return nil</span>
}

// StopAllBacklogMonitoring 停止所有积压监控
func (n *natsEventBus) StopAllBacklogMonitoring() error <span class="cov0" title="0">{
        var errs []error

        // 停止订阅端积压监控
        if err := n.StopSubscriberBacklogMonitoring(); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf("failed to stop subscriber backlog monitoring: %w", err))
        }</span>

        // 停止发送端积压监控
        <span class="cov0" title="0">if err := n.StopPublisherBacklogMonitoring(); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf("failed to stop publisher backlog monitoring: %w", err))
        }</span>

        <span class="cov0" title="0">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stop some backlog monitoring: %v", errs)
        }</span>

        <span class="cov0" title="0">n.logger.Info("All backlog monitoring stopped successfully for NATS eventbus")
        return nil</span>
}

// SetMessageRouter 设置消息路由器
func (n *natsEventBus) SetMessageRouter(router MessageRouter) error <span class="cov0" title="0">{
        n.mu.Lock()
        defer n.mu.Unlock()

        n.messageRouter = router
        logger.Debug("Message router set for nats eventbus")
        return nil
}</span>

// SetErrorHandler 设置错误处理器
func (n *natsEventBus) SetErrorHandler(handler ErrorHandler) error <span class="cov0" title="0">{
        n.mu.Lock()
        defer n.mu.Unlock()

        n.errorHandler = handler
        logger.Info("Error handler set for nats eventbus")
        return nil
}</span>

// RegisterSubscriptionCallback 注册订阅回调
func (n *natsEventBus) RegisterSubscriptionCallback(callback SubscriptionCallback) error <span class="cov0" title="0">{
        logger.Info("Subscription callback registered for nats eventbus")
        return nil
}</span>

// ========== 统一健康检查和监控 ==========

// StartHealthCheck 启动健康检查
func (n *natsEventBus) StartHealthCheck(ctx context.Context) error <span class="cov0" title="0">{
        n.mu.Lock()
        defer n.mu.Unlock()

        // 如果已经启动，先停止之前的
        if n.healthCheckCancel != nil </span><span class="cov0" title="0">{
                n.healthCheckCancel()
                if n.healthCheckDone != nil </span><span class="cov0" title="0">{
                        &lt;-n.healthCheckDone // 等待之前的健康检查完全停止
                }</span>
        }

        // 创建新的控制 context
        <span class="cov0" title="0">healthCtx, cancel := context.WithCancel(ctx)
        n.healthCheckCancel = cancel
        n.healthCheckDone = make(chan struct{})

        // 启动健康检查协程
        go func() </span><span class="cov0" title="0">{
                defer close(n.healthCheckDone)

                ticker := time.NewTicker(30 * time.Second) // 默认30秒检查一次
                defer ticker.Stop()

                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-healthCtx.Done():<span class="cov0" title="0">
                                n.logger.Info("Health check stopped for nats eventbus")
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                if err := n.healthCheck(healthCtx); err != nil </span><span class="cov0" title="0">{
                                        n.logger.Error("Health check failed", zap.Error(err))

                                        // 增加失败计数
                                        failureCount := n.failureCount.Add(1)

                                        // 检查是否达到重连阈值
                                        if failureCount &gt;= int32(n.reconnectConfig.FailureThreshold) </span><span class="cov0" title="0">{
                                                n.logger.Warn("Health check failure threshold reached, attempting reconnect",
                                                        zap.Int32("failureCount", failureCount),
                                                        zap.Int("threshold", n.reconnectConfig.FailureThreshold))

                                                // 触发自动重连
                                                if reconnectErr := n.reconnect(healthCtx); reconnectErr != nil </span><span class="cov0" title="0">{
                                                        n.logger.Error("Auto-reconnect failed", zap.Error(reconnectErr))
                                                }</span> else<span class="cov0" title="0"> {
                                                        n.logger.Info("Auto-reconnect successful")
                                                        n.failureCount.Store(0) // 重置失败计数
                                                }</span>
                                        }
                                } else<span class="cov0" title="0"> {
                                        // 健康检查成功，重置失败计数
                                        n.failureCount.Store(0)
                                }</span>
                        }
                }
        }()

        <span class="cov0" title="0">n.logger.Info("Health check started for nats eventbus")
        return nil</span>
}

// StopHealthCheck 停止健康检查
func (n *natsEventBus) StopHealthCheck() error <span class="cov0" title="0">{
        n.mu.Lock()
        defer n.mu.Unlock()

        if n.healthCheckCancel != nil </span><span class="cov0" title="0">{
                // 取消健康检查 context
                n.healthCheckCancel()

                // 等待健康检查 goroutine 完全停止
                if n.healthCheckDone != nil </span><span class="cov0" title="0">{
                        &lt;-n.healthCheckDone
                }</span>

                // 清理资源
                <span class="cov0" title="0">n.healthCheckCancel = nil
                n.healthCheckDone = nil

                n.logger.Info("Health check stopped for nats eventbus")</span>
        } else<span class="cov0" title="0"> {
                n.logger.Debug("Health check was not running")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetHealthStatus 获取健康状态
func (n *natsEventBus) GetHealthStatus() HealthCheckStatus <span class="cov0" title="0">{
        n.mu.RLock()
        defer n.mu.RUnlock()

        isHealthy := !n.closed &amp;&amp; n.conn != nil &amp;&amp; n.conn.IsConnected()
        return HealthCheckStatus{
                IsHealthy:           isHealthy,
                ConsecutiveFailures: 0,
                LastSuccessTime:     time.Now(),
                LastFailureTime:     time.Time{},
                IsRunning:           !n.closed,
                EventBusType:        "nats",
                Source:              "nats-eventbus",
        }
}</span>

// RegisterHealthCheckCallback 注册健康检查回调
func (n *natsEventBus) RegisterHealthCheckCallback(callback HealthCheckCallback) error <span class="cov0" title="0">{
        logger.Info("Health check callback registered for nats eventbus")
        return nil
}</span>

// StartHealthCheckSubscriber 启动健康检查消息订阅监控
func (n *natsEventBus) StartHealthCheckSubscriber(ctx context.Context) error <span class="cov0" title="0">{
        n.mu.Lock()
        defer n.mu.Unlock()

        if n.healthCheckSubscriber != nil </span><span class="cov0" title="0">{
                return nil // 已经启动
        }</span>

        // 创建健康检查订阅监控器
        <span class="cov0" title="0">config := GetDefaultHealthCheckConfig()
        n.healthCheckSubscriber = NewHealthCheckSubscriber(config, n, "nats-eventbus", "nats")

        // 启动监控器
        if err := n.healthCheckSubscriber.Start(ctx); err != nil </span><span class="cov0" title="0">{
                n.healthCheckSubscriber = nil
                return fmt.Errorf("failed to start health check subscriber: %w", err)
        }</span>

        <span class="cov0" title="0">n.logger.Info("Health check subscriber started for nats eventbus")
        return nil</span>
}

// StopHealthCheckSubscriber 停止健康检查消息订阅监控
func (n *natsEventBus) StopHealthCheckSubscriber() error <span class="cov0" title="0">{
        n.mu.Lock()
        defer n.mu.Unlock()

        if n.healthCheckSubscriber == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if err := n.healthCheckSubscriber.Stop(); err != nil </span><span class="cov0" title="0">{
                n.logger.Error("Failed to stop health check subscriber", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">n.healthCheckSubscriber = nil
        n.logger.Info("Health check subscriber stopped for nats eventbus")
        return nil</span>
}

// RegisterHealthCheckAlertCallback 注册健康检查告警回调
func (n *natsEventBus) RegisterHealthCheckAlertCallback(callback HealthCheckAlertCallback) error <span class="cov0" title="0">{
        n.mu.RLock()
        defer n.mu.RUnlock()

        if n.healthCheckSubscriber == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("health check subscriber not started")
        }</span>

        <span class="cov0" title="0">return n.healthCheckSubscriber.RegisterAlertCallback(callback)</span>
}

// GetHealthCheckSubscriberStats 获取健康检查订阅监控统计信息
func (n *natsEventBus) GetHealthCheckSubscriberStats() HealthCheckSubscriberStats <span class="cov0" title="0">{
        n.mu.RLock()
        defer n.mu.RUnlock()

        if n.healthCheckSubscriber == nil </span><span class="cov0" title="0">{
                return HealthCheckSubscriberStats{}
        }</span>

        <span class="cov0" title="0">return n.healthCheckSubscriber.GetStats()</span>
}

// GetConnectionState 获取连接状态
func (n *natsEventBus) GetConnectionState() ConnectionState <span class="cov0" title="0">{
        n.mu.RLock()
        defer n.mu.RUnlock()

        isConnected := !n.closed &amp;&amp; n.conn != nil &amp;&amp; n.conn.IsConnected()
        return ConnectionState{
                IsConnected:       isConnected,
                LastConnectedTime: time.Now(),
                ReconnectCount:    0,
                LastError:         "",
        }
}</span>

// GetMetrics 获取监控指标
func (n *natsEventBus) GetMetrics() Metrics <span class="cov0" title="0">{
        n.mu.RLock()
        defer n.mu.RUnlock()

        return Metrics{
                MessagesPublished: n.publishedMessages.Load(),
                MessagesConsumed:  n.consumedMessages.Load(),
                PublishErrors:     n.errorCount.Load(),
                ConsumeErrors:     0,
                ConnectionErrors:  0,
                LastHealthCheck:   time.Now(),
                HealthCheckStatus: "healthy",
                ActiveConnections: 1,
                MessageBacklog:    0,
        }
}</span>

// CheckConnection 检查 NATS 连接状态
func (n *natsEventBus) CheckConnection(ctx context.Context) error <span class="cov0" title="0">{
        n.mu.RLock()
        defer n.mu.RUnlock()

        if n.closed </span><span class="cov0" title="0">{
                return fmt.Errorf("nats eventbus is closed")
        }</span>

        <span class="cov0" title="0">if n.conn == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("nats connection is nil")
        }</span>

        <span class="cov0" title="0">if !n.conn.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("nats connection is not connected")
        }</span>

        // 检查服务器信息
        <span class="cov0" title="0">if !n.conn.IsReconnecting() &amp;&amp; n.conn.ConnectedUrl() != "" </span><span class="cov0" title="0">{
                n.logger.Debug("NATS connection check passed",
                        zap.String("connectedUrl", n.conn.ConnectedUrl()),
                        zap.String("status", n.conn.Status().String()))
                return nil
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("nats connection is in invalid state")</span>
}

// CheckMessageTransport 检查端到端消息传输
func (n *natsEventBus) CheckMessageTransport(ctx context.Context) error <span class="cov0" title="0">{
        testSubject := "health.check"
        testMessage := fmt.Sprintf("health-check-%d", time.Now().UnixNano())

        // 创建带超时的上下文
        ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
        defer cancel()

        // 如果连接支持订阅，进行端到端测试
        if n.conn != nil &amp;&amp; n.conn.IsConnected() </span><span class="cov0" title="0">{
                return n.performNATSEndToEndTest(ctx, testSubject, testMessage)
        }</span>

        // 如果没有连接，只测试发布能力
        <span class="cov0" title="0">start := time.Now()
        err := n.Publish(ctx, testSubject, []byte(testMessage))
        publishLatency := time.Since(start)

        if err != nil </span><span class="cov0" title="0">{
                n.logger.Error("NATS health check message transport failed",
                        zap.Error(err),
                        zap.Duration("publishLatency", publishLatency))
                return fmt.Errorf("failed to publish health check message: %w", err)
        }</span>

        <span class="cov0" title="0">n.logger.Debug("NATS health check message transport successful",
                zap.Duration("publishLatency", publishLatency))

        return nil</span>
}

// performNATSEndToEndTest 执行 NATS 端到端测试
func (n *natsEventBus) performNATSEndToEndTest(ctx context.Context, testSubject, testMessage string) error <span class="cov0" title="0">{
        // 创建接收通道
        receiveChan := make(chan string, 1)

        // 创建临时订阅来接收健康检查消息
        sub, err := n.conn.Subscribe(testSubject, func(msg *nats.Msg) </span><span class="cov0" title="0">{
                receivedMsg := string(msg.Data)
                if receivedMsg == testMessage </span><span class="cov0" title="0">{
                        select </span>{
                        case receiveChan &lt;- receivedMsg:<span class="cov0" title="0"></span>
                        default:<span class="cov0" title="0"></span>
                        }
                }
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                n.logger.Warn("Failed to create subscription for health check, falling back to publish-only test",
                        zap.Error(err))
                // 回退到只测试发布
                start := time.Now()
                if err := n.Publish(ctx, testSubject, []byte(testMessage)); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to publish health check message: %w", err)
                }</span>
                <span class="cov0" title="0">publishLatency := time.Since(start)
                n.logger.Debug("NATS health check message published (no subscription test)",
                        zap.Duration("publishLatency", publishLatency))
                return nil</span>
        }
        <span class="cov0" title="0">defer sub.Unsubscribe()

        // 等待一小段时间确保订阅生效
        time.Sleep(100 * time.Millisecond)

        // 发布健康检查消息
        start := time.Now()
        if err := n.Publish(ctx, testSubject, []byte(testMessage)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to publish health check message: %w", err)
        }</span>
        <span class="cov0" title="0">publishLatency := time.Since(start)

        // 等待接收消息或超时
        select </span>{
        case receivedMsg := &lt;-receiveChan:<span class="cov0" title="0">
                totalLatency := time.Since(start)
                n.logger.Debug("NATS end-to-end health check successful",
                        zap.Duration("publishLatency", publishLatency),
                        zap.Duration("totalLatency", totalLatency),
                        zap.String("message", receivedMsg))
                return nil</span>

        case &lt;-ctx.Done():<span class="cov0" title="0">
                return fmt.Errorf("nats health check timeout: message not received within timeout period")</span>

        case &lt;-time.After(8 * time.Second):<span class="cov0" title="0">
                return fmt.Errorf("nats health check timeout: message not received within 8 seconds")</span>
        }
}

// GetEventBusMetrics 获取 NATS EventBus 性能指标
func (n *natsEventBus) GetEventBusMetrics() EventBusHealthMetrics <span class="cov0" title="0">{
        n.mu.RLock()
        defer n.mu.RUnlock()

        connectionStatus := "disconnected"
        if !n.closed &amp;&amp; n.conn != nil &amp;&amp; n.conn.IsConnected() </span><span class="cov0" title="0">{
                connectionStatus = "connected"
        }</span>

        <span class="cov0" title="0">return EventBusHealthMetrics{
                ConnectionStatus:    connectionStatus,
                PublishLatency:      0,                          // TODO: 实际测量并缓存
                SubscribeLatency:    0,                          // TODO: 实际测量并缓存
                LastSuccessTime:     time.Now(),                 // TODO: 实际跟踪
                LastFailureTime:     time.Time{},                // TODO: 实际跟踪
                ConsecutiveFailures: 0,                          // TODO: 实际统计
                ThroughputPerSecond: n.publishedMessages.Load(), // 简化实现
                MessageBacklog:      0,                          // TODO: 实际计算
                ReconnectCount:      0,                          // TODO: 实际统计
                BrokerCount:         1,                          // NATS 通常是单个服务器或集群
                TopicCount:          len(n.subscriptions),       // 当前订阅的主题数量
        }</span>
}

// ========== 自动重连功能 ==========

// SetReconnectConfig 设置重连配置
func (n *natsEventBus) SetReconnectConfig(config ReconnectConfig) error <span class="cov0" title="0">{
        n.mu.Lock()
        defer n.mu.Unlock()

        n.reconnectConfig = config
        n.logger.Info("NATS reconnect config updated",
                zap.Int("maxAttempts", config.MaxAttempts),
                zap.Duration("initialBackoff", config.InitialBackoff),
                zap.Duration("maxBackoff", config.MaxBackoff),
                zap.Float64("backoffFactor", config.BackoffFactor),
                zap.Int("failureThreshold", config.FailureThreshold))
        return nil
}</span>

// GetReconnectStatus 获取重连状态
func (n *natsEventBus) GetReconnectStatus() ReconnectStatus <span class="cov0" title="0">{
        failureCount := n.failureCount.Load()

        var lastReconnectTime time.Time
        if t := n.lastReconnectTime.Load(); t != nil </span><span class="cov0" title="0">{
                lastReconnectTime = t.(time.Time)
        }</span>

        <span class="cov0" title="0">return ReconnectStatus{
                FailureCount:      int(failureCount),
                LastReconnectTime: lastReconnectTime,
                IsReconnecting:    false, // NATS 客户端内部处理重连状态
                Config:            n.reconnectConfig,
        }</span>
}

// reconnect 执行重连逻辑
func (n *natsEventBus) reconnect(ctx context.Context) error <span class="cov0" title="0">{
        n.mu.Lock()
        defer n.mu.Unlock()

        if n.closed </span><span class="cov0" title="0">{
                return fmt.Errorf("nats eventbus is closed")
        }</span>

        <span class="cov0" title="0">n.logger.Info("Starting NATS reconnection process")

        // 使用指数退避算法进行重连尝试
        for attempt := 1; attempt &lt;= n.reconnectConfig.MaxAttempts; attempt++ </span><span class="cov0" title="0">{
                // 计算退避时间
                backoff := n.calculateBackoff(attempt)

                n.logger.Info("Attempting NATS reconnection",
                        zap.Int("attempt", attempt),
                        zap.Int("maxAttempts", n.reconnectConfig.MaxAttempts),
                        zap.Duration("backoff", backoff))

                // 等待退避时间
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return fmt.Errorf("reconnect cancelled: %w", ctx.Err())</span>
                case &lt;-time.After(backoff):<span class="cov0" title="0"></span>
                }

                // 尝试重新初始化连接
                <span class="cov0" title="0">if err := n.reinitializeConnection(); err != nil </span><span class="cov0" title="0">{
                        n.logger.Warn("NATS reconnection attempt failed",
                                zap.Int("attempt", attempt),
                                zap.Error(err))

                        if attempt == n.reconnectConfig.MaxAttempts </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to reconnect after %d attempts: %w", attempt, err)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // 重连成功，恢复订阅
                <span class="cov0" title="0">if err := n.restoreSubscriptions(ctx); err != nil </span><span class="cov0" title="0">{
                        n.logger.Error("Failed to restore subscriptions after reconnect", zap.Error(err))
                        // 不返回错误，因为连接已经成功，订阅可以稍后重试
                }</span>

                // 更新重连时间
                <span class="cov0" title="0">n.lastReconnectTime.Store(time.Now())

                // 调用重连回调
                if n.reconnectCallback != nil </span><span class="cov0" title="0">{
                        go func() </span><span class="cov0" title="0">{
                                // 从父 context 派生，支持取消传播
                                callbackCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
                                defer cancel()

                                if err := n.reconnectCallback(callbackCtx); err != nil </span><span class="cov0" title="0">{
                                        n.logger.Error("Reconnect callback failed", zap.Error(err))
                                }</span>
                        }()
                }

                <span class="cov0" title="0">n.logger.Info("NATS reconnection successful", zap.Int("attempt", attempt))
                return nil</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("failed to reconnect after %d attempts", n.reconnectConfig.MaxAttempts)</span>
}

// calculateBackoff 计算指数退避时间
func (n *natsEventBus) calculateBackoff(attempt int) time.Duration <span class="cov0" title="0">{
        backoff := float64(n.reconnectConfig.InitialBackoff)

        // 指数退避算法
        for i := 1; i &lt; attempt; i++ </span><span class="cov0" title="0">{
                backoff *= n.reconnectConfig.BackoffFactor
        }</span>

        // 限制最大退避时间
        <span class="cov0" title="0">if backoff &gt; float64(n.reconnectConfig.MaxBackoff) </span><span class="cov0" title="0">{
                backoff = float64(n.reconnectConfig.MaxBackoff)
        }</span>

        <span class="cov0" title="0">return time.Duration(backoff)</span>
}

// reinitializeConnection 重新初始化 NATS 连接
func (n *natsEventBus) reinitializeConnection() error <span class="cov0" title="0">{
        // 关闭现有连接
        if n.conn != nil </span><span class="cov0" title="0">{
                n.conn.Close()
        }</span>

        // 构建连接选项
        <span class="cov0" title="0">opts := buildNATSOptions(n.config)

        // 重新连接到NATS服务器
        var nc *nats.Conn
        var err error

        if len(n.config.URLs) &gt; 0 </span><span class="cov0" title="0">{
                nc, err = nats.Connect(n.config.URLs[0], opts...)
        }</span> else<span class="cov0" title="0"> {
                nc, err = nats.Connect(nats.DefaultURL, opts...)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to reconnect to NATS: %w", err)
        }</span>

        // 更新连接
        <span class="cov0" title="0">n.conn = nc

        // 重新创建JetStream上下文（如果启用）
        if n.config.JetStream.Enabled </span><span class="cov0" title="0">{
                jsOpts := buildJetStreamOptions(n.config)
                js, err := nc.JetStream(jsOpts...)
                if err != nil </span><span class="cov0" title="0">{
                        nc.Close()
                        return fmt.Errorf("failed to recreate JetStream context: %w", err)
                }</span>
                <span class="cov0" title="0">n.js = js

                // 确保流存在
                if err := ensureStream(js, n.config); err != nil </span><span class="cov0" title="0">{
                        nc.Close()
                        return fmt.Errorf("failed to ensure stream after reconnect: %w", err)
                }</span>
        }

        // 设置重连处理器
        <span class="cov0" title="0">nc.SetReconnectHandler(func(nc *nats.Conn) </span><span class="cov0" title="0">{
                n.logger.Info("NATS reconnected", zap.String("url", nc.ConnectedUrl()))
                // 重置失败计数
                n.failureCount.Store(0)
                // 更新重连时间
                n.lastReconnectTime.Store(time.Now())
                // 恢复订阅
                n.restoreSubscriptions(context.Background())
                // 执行重连回调
                n.executeReconnectCallbacks()
        }</span>)

        <span class="cov0" title="0">n.logger.Info("NATS connection reinitialized successfully")
        return nil</span>
}

// restoreSubscriptions 恢复所有订阅
func (n *natsEventBus) restoreSubscriptions(ctx context.Context) error <span class="cov0" title="0">{
        n.subscriptionsMu.RLock()
        handlers := make(map[string]MessageHandler)
        for topic, handler := range n.subscriptionHandlers </span><span class="cov0" title="0">{
                handlers[topic] = handler
        }</span>
        <span class="cov0" title="0">n.subscriptionsMu.RUnlock()

        if len(handlers) == 0 </span><span class="cov0" title="0">{
                n.logger.Debug("No subscriptions to restore")
                return nil
        }</span>

        <span class="cov0" title="0">n.logger.Info("Restoring NATS subscriptions", zap.Int("count", len(handlers)))

        // 清空现有订阅映射
        n.subscriptions = make(map[string]*nats.Subscription)
        n.consumers = make(map[string]nats.ConsumerInfo)

        var errors []error
        restoredCount := 0

        // 重新建立每个订阅（只使用JetStream）
        for topic, handler := range handlers </span><span class="cov0" title="0">{
                err := n.subscribeJetStream(ctx, topic, handler)

                if err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("failed to restore subscription for topic %s: %w", topic, err))
                        n.logger.Error("Failed to restore JetStream subscription",
                                zap.String("topic", topic),
                                zap.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        restoredCount++
                        n.logger.Debug("JetStream subscription restored",
                                zap.String("topic", topic),
                                zap.Bool("jetstream", true))
                }</span>
        }

        <span class="cov0" title="0">n.logger.Info("NATS subscriptions restoration completed",
                zap.Int("total", len(handlers)),
                zap.Int("restored", restoredCount),
                zap.Int("failed", len(errors)))

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to restore %d subscriptions: %v", len(errors), errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ========== 方案A：Envelope 支持 ==========

// PublishEnvelope 发布Envelope消息（方案A）
func (n *natsEventBus) PublishEnvelope(ctx context.Context, topic string, envelope *Envelope) error <span class="cov0" title="0">{
        n.mu.RLock()
        defer n.mu.RUnlock()

        if n.closed </span><span class="cov0" title="0">{
                return fmt.Errorf("nats eventbus is closed")
        }</span>

        // 校验Envelope
        <span class="cov0" title="0">if err := envelope.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid envelope: %w", err)
        }</span>

        // 序列化Envelope
        <span class="cov0" title="0">envelopeBytes, err := envelope.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                n.errorCount.Add(1)
                return fmt.Errorf("failed to serialize envelope: %w", err)
        }</span>

        // 创建NATS消息（方案A + 传输层镜像）
        <span class="cov0" title="0">msg := &amp;nats.Msg{
                Subject: topic,
                Data:    envelopeBytes,
                Header: nats.Header{
                        "X-Aggregate-ID":  []string{envelope.AggregateID},
                        "X-Event-Version": []string{fmt.Sprintf("%d", envelope.EventVersion)},
                        "X-Event-Type":    []string{envelope.EventType},
                        "X-Timestamp":     []string{envelope.Timestamp.Format(time.RFC3339)},
                },
        }

        // 添加可选字段到Header
        if envelope.TraceID != "" </span><span class="cov0" title="0">{
                msg.Header.Set("X-Trace-ID", envelope.TraceID)
        }</span>
        <span class="cov0" title="0">if envelope.CorrelationID != "" </span><span class="cov0" title="0">{
                msg.Header.Set("X-Correlation-ID", envelope.CorrelationID)
        }</span>

        // 发送消息
        <span class="cov0" title="0">_, err = n.js.PublishMsg(msg)
        if err != nil </span><span class="cov0" title="0">{
                n.errorCount.Add(1)
                n.logger.Error("Failed to publish envelope message",
                        zap.String("subject", topic),
                        zap.String("aggregateID", envelope.AggregateID),
                        zap.String("eventType", envelope.EventType),
                        zap.Int64("eventVersion", envelope.EventVersion),
                        zap.Error(err))
                return fmt.Errorf("failed to publish envelope message: %w", err)
        }</span>

        <span class="cov0" title="0">n.publishedMessages.Add(1)
        n.logger.Debug("Envelope message published successfully",
                zap.String("subject", topic),
                zap.String("aggregateID", envelope.AggregateID),
                zap.String("eventType", envelope.EventType),
                zap.Int64("eventVersion", envelope.EventVersion))

        return nil</span>
}

// SubscribeEnvelope 订阅Envelope消息（自动使用Keyed-Worker池）
//
// 特点：
// - 消息格式：Envelope包装格式（包含聚合ID、事件类型、版本等元数据）
// - 处理模式：按聚合ID路由到Keyed-Worker池，同聚合ID严格顺序处理
// - 性能：顺序保证，毫秒级延迟（NATS JetStream持久化）
// - 聚合ID：从Envelope.AggregateID字段提取
// - Keyed-Worker池：自动使用（基于聚合ID的一致性哈希路由）
//
// 核心机制：
// 1. 消息必须是Envelope格式，包含AggregateID
// 2. ExtractAggregateID成功提取聚合ID
// 3. 使用一致性哈希将相同聚合ID路由到固定Worker
// 4. 确保同一聚合的事件严格按序处理
//
// 适用场景：
// - 领域事件处理（订单状态变更、用户行为）
// - 事件溯源（Event Sourcing）
// - 聚合管理（DDD聚合根）
// - 跨Docker容器的有序事件处理
// - 需要顺序保证的业务场景
//
// 示例：
//
//        bus.SubscribeEnvelope(ctx, "orders.events", func(ctx context.Context, env *Envelope) error {
//            // env.AggregateID = "order-123"
//            // 同一订单的所有事件会路由到同一个Worker，确保顺序处理
//            return processDomainEvent(env)
//        })
func (n *natsEventBus) SubscribeEnvelope(ctx context.Context, topic string, handler EnvelopeHandler) error <span class="cov0" title="0">{
        // 包装EnvelopeHandler为MessageHandler
        wrappedHandler := func(ctx context.Context, message []byte) error </span><span class="cov0" title="0">{
                // 尝试解析为Envelope
                envelope, err := FromBytes(message)
                if err != nil </span><span class="cov0" title="0">{
                        n.logger.Error("Failed to parse envelope message",
                                zap.String("subject", topic),
                                zap.Error(err))
                        return fmt.Errorf("failed to parse envelope: %w", err)
                }</span>

                // 调用业务处理器
                <span class="cov0" title="0">return handler(ctx, envelope)</span>
        }

        // 使用现有的Subscribe方法
        <span class="cov0" title="0">return n.Subscribe(ctx, topic, wrappedHandler)</span>
}

// ========== 新的分离式健康检查接口实现 ==========

// StartHealthCheckPublisher 启动健康检查发布器
func (n *natsEventBus) StartHealthCheckPublisher(ctx context.Context) error <span class="cov0" title="0">{
        n.mu.Lock()
        defer n.mu.Unlock()

        if n.healthChecker != nil </span><span class="cov0" title="0">{
                return nil // 已经启动
        }</span>

        // 创建健康检查发布器
        <span class="cov0" title="0">config := GetDefaultHealthCheckConfig()
        n.healthChecker = NewHealthChecker(config, n, "nats-eventbus", "nats")

        // 启动健康检查发布器
        if err := n.healthChecker.Start(ctx); err != nil </span><span class="cov0" title="0">{
                n.healthChecker = nil
                return fmt.Errorf("failed to start health check publisher: %w", err)
        }</span>

        <span class="cov0" title="0">n.logger.Info("Health check publisher started for nats eventbus")
        return nil</span>
}

// StopHealthCheckPublisher 停止健康检查发布器
func (n *natsEventBus) StopHealthCheckPublisher() error <span class="cov0" title="0">{
        n.mu.Lock()
        defer n.mu.Unlock()

        if n.healthChecker == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if err := n.healthChecker.Stop(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stop health check publisher: %w", err)
        }</span>

        <span class="cov0" title="0">n.healthChecker = nil
        n.logger.Info("Health check publisher stopped for nats eventbus")
        return nil</span>
}

// GetHealthCheckPublisherStatus 获取健康检查发布器状态
func (n *natsEventBus) GetHealthCheckPublisherStatus() HealthCheckStatus <span class="cov0" title="0">{
        n.mu.RLock()
        defer n.mu.RUnlock()

        if n.healthChecker == nil </span><span class="cov0" title="0">{
                return HealthCheckStatus{
                        IsHealthy:           false,
                        ConsecutiveFailures: 0,
                        LastSuccessTime:     time.Time{},
                        LastFailureTime:     time.Now(),
                        IsRunning:           false,
                        EventBusType:        "nats",
                        Source:              "nats-eventbus",
                }
        }</span>

        <span class="cov0" title="0">return n.healthChecker.GetStatus()</span>
}

// RegisterHealthCheckPublisherCallback 注册健康检查发布器回调
func (n *natsEventBus) RegisterHealthCheckPublisherCallback(callback HealthCheckCallback) error <span class="cov0" title="0">{
        n.mu.RLock()
        defer n.mu.RUnlock()

        if n.healthChecker == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("health check publisher not started")
        }</span>

        <span class="cov0" title="0">return n.healthChecker.RegisterCallback(callback)</span>
}

// RegisterHealthCheckSubscriberCallback 注册健康检查订阅器回调
func (n *natsEventBus) RegisterHealthCheckSubscriberCallback(callback HealthCheckAlertCallback) error <span class="cov0" title="0">{
        return n.RegisterHealthCheckAlertCallback(callback)
}</span>

// StartAllHealthCheck 根据配置启动所有健康检查
func (n *natsEventBus) StartAllHealthCheck(ctx context.Context) error <span class="cov0" title="0">{
        // 这里可以根据配置决定启动哪些健康检查
        // 为了演示，我们启动发布器和订阅器
        if err := n.StartHealthCheckPublisher(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start health check publisher: %w", err)
        }</span>

        <span class="cov0" title="0">if err := n.StartHealthCheckSubscriber(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start health check subscriber: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// StopAllHealthCheck 停止所有健康检查
func (n *natsEventBus) StopAllHealthCheck() error <span class="cov0" title="0">{
        var errs []error

        if err := n.StopHealthCheckPublisher(); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf("failed to stop health check publisher: %w", err))
        }</span>

        <span class="cov0" title="0">if err := n.StopHealthCheckSubscriber(); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf("failed to stop health check subscriber: %w", err))
        }</span>

        <span class="cov0" title="0">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("errors stopping health checks: %v", errs)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ========== 主题持久化管理实现 ==========

// ConfigureTopic 配置主题的持久化策略和其他选项（幂等操作）
func (n *natsEventBus) ConfigureTopic(ctx context.Context, topic string, options TopicOptions) error <span class="cov0" title="0">{
        start := time.Now()

        n.topicConfigsMu.Lock()
        // 检查是否已有配置
        _, exists := n.topicConfigs[topic]
        // 缓存配置
        n.topicConfigs[topic] = options
        n.topicConfigsMu.Unlock()

        // 根据策略决定是否需要同步到消息中间件
        shouldCreate, shouldUpdate := shouldCreateOrUpdate(n.topicConfigStrategy, exists)

        var action string
        var err error
        var mismatches []TopicConfigMismatch

        // 如果是持久化模式且JetStream可用
        if options.IsPersistent(n.config.JetStream.Enabled) &amp;&amp; n.js != nil </span><span class="cov0" title="0">{
                switch </span>{
                case n.topicConfigStrategy == StrategySkip:<span class="cov0" title="0">
                        // 跳过模式：不检查
                        action = "skipped"</span>

                case n.topicConfigStrategy == StrategyValidateOnly:<span class="cov0" title="0">
                        // 验证模式：只验证，不修改
                        action = "validated"
                        if exists </span><span class="cov0" title="0">{
                                actualConfig, validateErr := n.getActualTopicConfig(ctx, topic)
                                if validateErr == nil </span><span class="cov0" title="0">{
                                        mismatches = compareTopicOptions(topic, options, actualConfig)
                                        if len(mismatches) &gt; 0 </span><span class="cov0" title="0">{
                                                err = handleConfigMismatches(mismatches, n.topicConfigOnMismatch)
                                        }</span>
                                }
                        }

                case shouldCreate:<span class="cov0" title="0">
                        // 创建模式：创建新配置
                        action = "created"
                        err = n.ensureTopicInJetStreamIdempotent(ctx, topic, options, false)</span>

                case shouldUpdate:<span class="cov0" title="0">
                        // 更新模式：更新现有配置
                        action = "updated"
                        // 先验证配置差异
                        actualConfig, validateErr := n.getActualTopicConfig(ctx, topic)
                        if validateErr == nil </span><span class="cov0" title="0">{
                                mismatches = compareTopicOptions(topic, options, actualConfig)
                        }</span>
                        // 执行更新
                        <span class="cov0" title="0">err = n.ensureTopicInJetStreamIdempotent(ctx, topic, options, true)</span>

                default:<span class="cov0" title="0">
                        // 默认：创建或更新
                        action = "configured"
                        err = n.ensureTopicInJetStreamIdempotent(ctx, topic, options, exists)</span>
                }
        } else<span class="cov0" title="0"> {
                // 非持久化模式或JetStream不可用
                action = "configured_ephemeral"
        }</span>

        <span class="cov0" title="0">duration := time.Since(start)

        // 记录结果
        if err != nil </span><span class="cov0" title="0">{
                n.logger.Error("Topic configuration failed",
                        zap.String("topic", topic),
                        zap.String("action", action),
                        zap.String("strategy", string(n.topicConfigStrategy)),
                        zap.Error(err),
                        zap.Duration("duration", duration))
                return fmt.Errorf("failed to configure topic %s: %w", topic, err)
        }</span>

        <span class="cov0" title="0">n.logger.Info("Topic configured successfully",
                zap.String("topic", topic),
                zap.String("action", action),
                zap.String("strategy", string(n.topicConfigStrategy)),
                zap.String("persistenceMode", string(options.PersistenceMode)),
                zap.Duration("retentionTime", options.RetentionTime),
                zap.Int64("maxSize", options.MaxSize),
                zap.Int("mismatches", len(mismatches)),
                zap.Duration("duration", duration))

        return nil</span>
}

// SetTopicPersistence 设置主题是否持久化（简化接口）
func (n *natsEventBus) SetTopicPersistence(ctx context.Context, topic string, persistent bool) error <span class="cov0" title="0">{
        mode := TopicEphemeral
        if persistent </span><span class="cov0" title="0">{
                mode = TopicPersistent
        }</span>

        <span class="cov0" title="0">options := DefaultTopicOptions()
        options.PersistenceMode = mode

        return n.ConfigureTopic(ctx, topic, options)</span>
}

// GetTopicConfig 获取主题的当前配置
func (n *natsEventBus) GetTopicConfig(topic string) (TopicOptions, error) <span class="cov10" title="104">{
        n.topicConfigsMu.RLock()
        defer n.topicConfigsMu.RUnlock()

        if config, exists := n.topicConfigs[topic]; exists </span><span class="cov0" title="0">{
                return config, nil
        }</span>

        // 返回默认配置
        <span class="cov10" title="104">return DefaultTopicOptions(), nil</span>
}

// ListConfiguredTopics 列出所有已配置的主题
func (n *natsEventBus) ListConfiguredTopics() []string <span class="cov0" title="0">{
        n.topicConfigsMu.RLock()
        defer n.topicConfigsMu.RUnlock()

        topics := make([]string, 0, len(n.topicConfigs))
        for topic := range n.topicConfigs </span><span class="cov0" title="0">{
                topics = append(topics, topic)
        }</span>

        <span class="cov0" title="0">return topics</span>
}

// RemoveTopicConfig 移除主题配置（恢复为默认行为）
func (n *natsEventBus) RemoveTopicConfig(topic string) error <span class="cov0" title="0">{
        n.topicConfigsMu.Lock()
        defer n.topicConfigsMu.Unlock()

        delete(n.topicConfigs, topic)

        n.logger.Info("Topic configuration removed", zap.String("topic", topic))
        return nil
}</span>

// ensureTopicInJetStream 确保主题在JetStream中存在
func (n *natsEventBus) ensureTopicInJetStream(topic string, options TopicOptions) error <span class="cov0" title="0">{
        if n.js == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("JetStream not enabled")
        }</span>

        // 获取或创建适合该主题的Stream名称
        <span class="cov0" title="0">streamName := n.getStreamNameForTopic(topic)

        // 尝试获取Stream信息
        streamInfo, err := n.js.StreamInfo(streamName)
        if err != nil </span><span class="cov0" title="0">{
                // Stream不存在，创建新的
                return n.createStreamForTopic(topic, options)
        }</span>

        // 检查主题是否已在Stream的subjects中
        <span class="cov0" title="0">for _, subject := range streamInfo.Config.Subjects </span><span class="cov0" title="0">{
                if subject == topic || subject == topic+".*" </span><span class="cov0" title="0">{
                        return nil // 已存在
                }</span>
        }

        // 添加主题到现有Stream
        <span class="cov0" title="0">return n.addTopicToStream(streamName, topic, options)</span>
}

// getStreamNameForTopic 为主题生成Stream名称
func (n *natsEventBus) getStreamNameForTopic(topic string) string <span class="cov0" title="0">{
        // 使用配置的Stream名称，或者基于主题生成
        if n.config.JetStream.Stream.Name != "" </span><span class="cov0" title="0">{
                return n.config.JetStream.Stream.Name
        }</span>
        // 生成基于主题的Stream名称
        <span class="cov0" title="0">return fmt.Sprintf("STREAM_%s", strings.ReplaceAll(topic, ".", "_"))</span>
}

// createStreamForTopic 为主题创建新的Stream
func (n *natsEventBus) createStreamForTopic(topic string, options TopicOptions) error <span class="cov0" title="0">{
        streamConfig := &amp;nats.StreamConfig{
                Name:      n.getStreamNameForTopic(topic),
                Subjects:  []string{topic},
                Storage:   nats.FileStorage, // 持久化存储
                Retention: nats.LimitsPolicy,
                Replicas:  1,
        }

        // 根据选项设置配置
        if options.RetentionTime &gt; 0 </span><span class="cov0" title="0">{
                streamConfig.MaxAge = options.RetentionTime
        }</span>
        <span class="cov0" title="0">if options.MaxSize &gt; 0 </span><span class="cov0" title="0">{
                streamConfig.MaxBytes = options.MaxSize
        }</span>
        <span class="cov0" title="0">if options.MaxMessages &gt; 0 </span><span class="cov0" title="0">{
                streamConfig.MaxMsgs = options.MaxMessages
        }</span>
        <span class="cov0" title="0">if options.Replicas &gt; 0 </span><span class="cov0" title="0">{
                streamConfig.Replicas = options.Replicas
        }</span>

        <span class="cov0" title="0">_, err := n.js.AddStream(streamConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create stream for topic %s: %w", topic, err)
        }</span>

        <span class="cov0" title="0">n.logger.Info("Created JetStream stream for topic",
                zap.String("topic", topic),
                zap.String("stream", streamConfig.Name))

        return nil</span>
}

// addTopicToStream 将主题添加到现有Stream
func (n *natsEventBus) addTopicToStream(streamName, topic string, options TopicOptions) error <span class="cov0" title="0">{
        // 获取现有Stream配置
        streamInfo, err := n.js.StreamInfo(streamName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get stream info: %w", err)
        }</span>

        // 添加新主题到subjects列表
        <span class="cov0" title="0">newSubjects := append(streamInfo.Config.Subjects, topic)
        streamInfo.Config.Subjects = newSubjects

        // 更新Stream配置
        _, err = n.js.UpdateStream(&amp;streamInfo.Config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update stream with new topic: %w", err)
        }</span>

        <span class="cov0" title="0">n.logger.Info("Added topic to existing stream",
                zap.String("topic", topic),
                zap.String("stream", streamName))

        return nil</span>
}

// ensureTopicInJetStreamIdempotent 幂等地确保主题在JetStream中存在（支持创建和更新）
func (n *natsEventBus) ensureTopicInJetStreamIdempotent(ctx context.Context, topic string, options TopicOptions, allowUpdate bool) error <span class="cov0" title="0">{
        if n.js == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("JetStream not enabled")
        }</span>

        <span class="cov0" title="0">streamName := n.getStreamNameForTopic(topic)

        // 构建期望的Stream配置
        expectedConfig := &amp;nats.StreamConfig{
                Name:      streamName,
                Subjects:  []string{topic},
                Storage:   nats.FileStorage,
                Retention: nats.LimitsPolicy,
                Replicas:  1,
        }

        // 应用选项
        if options.RetentionTime &gt; 0 </span><span class="cov0" title="0">{
                expectedConfig.MaxAge = options.RetentionTime
        }</span>
        <span class="cov0" title="0">if options.MaxSize &gt; 0 </span><span class="cov0" title="0">{
                expectedConfig.MaxBytes = options.MaxSize
        }</span>
        <span class="cov0" title="0">if options.MaxMessages &gt; 0 </span><span class="cov0" title="0">{
                expectedConfig.MaxMsgs = options.MaxMessages
        }</span>
        <span class="cov0" title="0">if options.Replicas &gt; 0 </span><span class="cov0" title="0">{
                expectedConfig.Replicas = options.Replicas
        }</span>

        // 检查Stream是否存在
        <span class="cov0" title="0">streamInfo, err := n.js.StreamInfo(streamName)

        if err != nil </span><span class="cov0" title="0">{
                if err == nats.ErrStreamNotFound </span><span class="cov0" title="0">{
                        // Stream不存在，创建新的
                        n.logger.Info("Creating new JetStream stream",
                                zap.String("stream", streamName),
                                zap.String("topic", topic))

                        _, err := n.js.AddStream(expectedConfig)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create stream: %w", err)
                        }</span>

                        <span class="cov0" title="0">n.logger.Info("Created JetStream stream",
                                zap.String("stream", streamName),
                                zap.String("topic", topic))
                        return nil</span>
                }
                <span class="cov0" title="0">return fmt.Errorf("failed to get stream info: %w", err)</span>
        }

        // Stream已存在
        // 检查主题是否已在Stream的subjects中
        <span class="cov0" title="0">topicExists := false
        for _, subject := range streamInfo.Config.Subjects </span><span class="cov0" title="0">{
                if subject == topic || subject == topic+".*" </span><span class="cov0" title="0">{
                        topicExists = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !topicExists </span><span class="cov0" title="0">{
                // 主题不在Stream中，添加主题
                n.logger.Info("Adding topic to existing stream",
                        zap.String("stream", streamName),
                        zap.String("topic", topic))

                streamInfo.Config.Subjects = append(streamInfo.Config.Subjects, topic)
                _, err = n.js.UpdateStream(&amp;streamInfo.Config)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to add topic to stream: %w", err)
                }</span>
        }

        // 如果允许更新，检查配置是否需要更新
        <span class="cov0" title="0">if allowUpdate </span><span class="cov0" title="0">{
                needsUpdate := false

                // 比较配置
                if expectedConfig.MaxAge != streamInfo.Config.MaxAge </span><span class="cov0" title="0">{
                        streamInfo.Config.MaxAge = expectedConfig.MaxAge
                        needsUpdate = true
                }</span>
                <span class="cov0" title="0">if expectedConfig.MaxBytes != streamInfo.Config.MaxBytes </span><span class="cov0" title="0">{
                        streamInfo.Config.MaxBytes = expectedConfig.MaxBytes
                        needsUpdate = true
                }</span>
                <span class="cov0" title="0">if expectedConfig.MaxMsgs != streamInfo.Config.MaxMsgs </span><span class="cov0" title="0">{
                        streamInfo.Config.MaxMsgs = expectedConfig.MaxMsgs
                        needsUpdate = true
                }</span>

                <span class="cov0" title="0">if needsUpdate </span><span class="cov0" title="0">{
                        n.logger.Info("Updating stream configuration",
                                zap.String("stream", streamName),
                                zap.String("topic", topic))

                        _, err = n.js.UpdateStream(&amp;streamInfo.Config)
                        if err != nil </span><span class="cov0" title="0">{
                                n.logger.Warn("Failed to update stream config, using existing config",
                                        zap.String("stream", streamName),
                                        zap.Error(err))
                                // 不返回错误，使用现有配置
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// getActualTopicConfig 获取主题在JetStream中的实际配置
func (n *natsEventBus) getActualTopicConfig(ctx context.Context, topic string) (TopicOptions, error) <span class="cov0" title="0">{
        if n.js == nil </span><span class="cov0" title="0">{
                return TopicOptions{}, fmt.Errorf("JetStream not enabled")
        }</span>

        <span class="cov0" title="0">streamName := n.getStreamNameForTopic(topic)

        // 获取Stream信息
        streamInfo, err := n.js.StreamInfo(streamName)
        if err != nil </span><span class="cov0" title="0">{
                return TopicOptions{}, fmt.Errorf("failed to get stream info: %w", err)
        }</span>

        // 转换为TopicOptions
        <span class="cov0" title="0">actualConfig := TopicOptions{
                PersistenceMode: TopicPersistent,
                RetentionTime:   streamInfo.Config.MaxAge,
                MaxSize:         streamInfo.Config.MaxBytes,
                MaxMessages:     streamInfo.Config.MaxMsgs,
                Replicas:        streamInfo.Config.Replicas,
        }

        return actualConfig, nil</span>
}

// SetTopicConfigStrategy 设置主题配置策略
func (n *natsEventBus) SetTopicConfigStrategy(strategy TopicConfigStrategy) <span class="cov0" title="0">{
        n.topicConfigsMu.Lock()
        defer n.topicConfigsMu.Unlock()
        n.topicConfigStrategy = strategy
        n.logger.Info("Topic config strategy updated", zap.String("strategy", string(strategy)))
}</span>

// GetTopicConfigStrategy 获取当前主题配置策略
func (n *natsEventBus) GetTopicConfigStrategy() TopicConfigStrategy <span class="cov0" title="0">{
        n.topicConfigsMu.RLock()
        defer n.topicConfigsMu.RUnlock()
        return n.topicConfigStrategy
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package eventbus

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/ChenBigdata421/jxt-core/sdk/pkg/logger"
        "github.com/nats-io/nats.go"
        "go.uber.org/zap"
)

// NATSBacklogDetector NATS JetStream 积压检测器
// 专门针对 JetStream 的积压检测实现
type NATSBacklogDetector struct {
        js               nats.JetStreamContext
        conn             *nats.Conn
        streamName       string
        consumers        map[string]string // consumerName -&gt; durableName
        maxLagThreshold  int64
        maxTimeThreshold time.Duration
        checkInterval    time.Duration
        lastCheckTime    time.Time
        lastCheckResult  bool
        mu               sync.RWMutex
        logger           *zap.Logger

        // 回调和生命周期管理
        callbacks  []BacklogStateCallback
        callbackMu sync.RWMutex
        ctx        context.Context
        cancel     context.CancelFunc
        wg         sync.WaitGroup
        isRunning  bool
        ticker     *time.Ticker
}

// NewNATSBacklogDetector 创建 NATS 积压检测器
func NewNATSBacklogDetector(js nats.JetStreamContext, conn *nats.Conn, streamName string, config BacklogDetectionConfig) *NATSBacklogDetector <span class="cov10" title="7">{
        // 确保 logger 不为 nil
        var log *zap.Logger
        if logger.Logger != nil </span><span class="cov10" title="7">{
                log = logger.Logger
        }</span> else<span class="cov0" title="0"> {
                // 如果全局 logger 未初始化，创建一个简单的 logger
                log, _ = zap.NewDevelopment()
        }</span>

        <span class="cov10" title="7">return &amp;NATSBacklogDetector{
                js:               js,
                conn:             conn,
                streamName:       streamName,
                consumers:        make(map[string]string),
                maxLagThreshold:  config.MaxLagThreshold,
                maxTimeThreshold: config.MaxTimeThreshold,
                checkInterval:    config.CheckInterval,
                logger:           log,
                callbacks:        make([]BacklogStateCallback, 0),
        }</span>
}

// RegisterConsumer 注册消费者
func (nbd *NATSBacklogDetector) RegisterConsumer(consumerName, durableName string) <span class="cov0" title="0">{
        nbd.mu.Lock()
        defer nbd.mu.Unlock()
        nbd.consumers[consumerName] = durableName
        nbd.logger.Debug("NATS consumer registered for backlog detection",
                zap.String("consumer", consumerName),
                zap.String("durable", durableName))
}</span>

// UnregisterConsumer 注销消费者
func (nbd *NATSBacklogDetector) UnregisterConsumer(consumerName string) <span class="cov0" title="0">{
        nbd.mu.Lock()
        defer nbd.mu.Unlock()
        delete(nbd.consumers, consumerName)
        nbd.logger.Debug("NATS consumer unregistered from backlog detection",
                zap.String("consumer", consumerName))
}</span>

// IsNoBacklog 检测是否无积压
func (nbd *NATSBacklogDetector) IsNoBacklog(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        nbd.mu.Lock()
        defer nbd.mu.Unlock()

        // 检查是否需要重新检测
        if time.Since(nbd.lastCheckTime) &lt; nbd.checkInterval </span><span class="cov0" title="0">{
                return nbd.lastCheckResult, nil
        }</span>

        // 检查 JetStream 连接状态
        <span class="cov0" title="0">if nbd.js == nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("JetStream context is not available")
        }</span>

        // 获取流信息
        <span class="cov0" title="0">streamInfo, err := nbd.js.StreamInfo(nbd.streamName)
        if err != nil </span><span class="cov0" title="0">{
                nbd.logger.Error("Failed to get stream info",
                        zap.String("stream", nbd.streamName),
                        zap.Error(err))
                return false, fmt.Errorf("failed to get stream info: %w", err)
        }</span>

        // 检查是否有消费者
        <span class="cov0" title="0">if len(nbd.consumers) == 0 </span><span class="cov0" title="0">{
                nbd.logger.Debug("No consumers registered, considering no backlog")
                nbd.lastCheckTime = time.Now()
                nbd.lastCheckResult = true
                return true, nil
        }</span>

        // 并发检测所有消费者的积压情况
        <span class="cov0" title="0">lagChan := make(chan consumerLag, len(nbd.consumers))
        errChan := make(chan error, len(nbd.consumers))
        var wg sync.WaitGroup

        // 并发检测每个消费者
        for consumerName, durableName := range nbd.consumers </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(cName, dName string) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        if err := nbd.checkConsumerBacklog(ctx, cName, dName, streamInfo, lagChan); err != nil </span><span class="cov0" title="0">{
                                errChan &lt;- err
                        }</span>
                }(consumerName, durableName)
        }

        // 等待所有检测完成
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(lagChan)
                close(errChan)
        }</span>()

        // 收集结果
        <span class="cov0" title="0">var totalLag int64
        var maxLagTime time.Time
        hasBacklog := false

        for lag := range lagChan </span><span class="cov0" title="0">{
                totalLag += lag.lag
                if lag.lag &gt; nbd.maxLagThreshold </span><span class="cov0" title="0">{
                        hasBacklog = true
                }</span>
                <span class="cov0" title="0">if lag.timestamp.After(maxLagTime) </span><span class="cov0" title="0">{
                        maxLagTime = lag.timestamp
                }</span>
        }

        // 检查是否有错误
        <span class="cov0" title="0">select </span>{
        case err := &lt;-errChan:<span class="cov0" title="0">
                if err != nil </span><span class="cov0" title="0">{
                        nbd.logger.Error("Error during NATS backlog detection", zap.Error(err))
                        return false, err
                }</span>
        default:<span class="cov0" title="0"></span>
        }

        // 检查时间维度的积压
        <span class="cov0" title="0">if !maxLagTime.IsZero() &amp;&amp; time.Since(maxLagTime) &gt; nbd.maxTimeThreshold </span><span class="cov0" title="0">{
                hasBacklog = true
        }</span>

        // 更新检测结果
        <span class="cov0" title="0">nbd.lastCheckTime = time.Now()
        nbd.lastCheckResult = !hasBacklog

        if hasBacklog </span><span class="cov0" title="0">{
                nbd.logger.Warn("NATS message backlog detected",
                        zap.Int64("totalLag", totalLag),
                        zap.Time("maxLagTime", maxLagTime),
                        zap.String("stream", nbd.streamName))
        }</span> else<span class="cov0" title="0"> {
                nbd.logger.Debug("No NATS message backlog detected",
                        zap.Int64("totalLag", totalLag),
                        zap.String("stream", nbd.streamName))
        }</span>

        <span class="cov0" title="0">return !hasBacklog, nil</span>
}

// consumerLag 消费者积压信息
type consumerLag struct {
        consumer  string
        lag       int64
        timestamp time.Time
}

// checkConsumerBacklog 检测单个消费者的积压情况
func (nbd *NATSBacklogDetector) checkConsumerBacklog(ctx context.Context, consumerName, durableName string, streamInfo *nats.StreamInfo, lagChan chan&lt;- consumerLag) error <span class="cov0" title="0">{
        // 获取消费者信息
        consumerInfo, err := nbd.js.ConsumerInfo(nbd.streamName, durableName)
        if err != nil </span><span class="cov0" title="0">{
                nbd.logger.Error("Failed to get consumer info",
                        zap.String("stream", nbd.streamName),
                        zap.String("consumer", consumerName),
                        zap.String("durable", durableName),
                        zap.Error(err))
                return fmt.Errorf("failed to get consumer info for %s: %w", consumerName, err)
        }</span>

        // 计算积压
        // JetStream 中的积压 = 流中的总消息数 - 消费者已确认的消息数
        <span class="cov0" title="0">streamMsgs := int64(streamInfo.State.Msgs)
        consumerAcked := int64(consumerInfo.AckFloor.Consumer)
        lag := streamMsgs - consumerAcked

        if lag &lt; 0 </span><span class="cov0" title="0">{
                lag = 0 // 避免负数
        }</span>

        // 获取最后消费时间（使用消费者的最后活动时间）
        <span class="cov0" title="0">var timestamp time.Time
        if consumerInfo.Delivered.Last != nil </span><span class="cov0" title="0">{
                timestamp = *consumerInfo.Delivered.Last
        }</span> else<span class="cov0" title="0"> {
                timestamp = time.Now() // 如果没有消费记录，使用当前时间
        }</span>

        <span class="cov0" title="0">lagChan &lt;- consumerLag{
                consumer:  consumerName,
                lag:       lag,
                timestamp: timestamp,
        }

        return nil</span>
}

// GetBacklogInfo 获取详细积压信息
func (nbd *NATSBacklogDetector) GetBacklogInfo(ctx context.Context) (*NATSBacklogInfo, error) <span class="cov0" title="0">{
        nbd.mu.RLock()
        defer nbd.mu.RUnlock()

        // 检查 JetStream 连接状态
        if nbd.js == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("JetStream context is not available")
        }</span>

        // 获取流信息
        <span class="cov0" title="0">streamInfo, err := nbd.js.StreamInfo(nbd.streamName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get stream info: %w", err)
        }</span>

        <span class="cov0" title="0">info := &amp;NATSBacklogInfo{
                StreamName: nbd.streamName,
                CheckTime:  time.Now(),
                TotalLag:   0,
                Consumers:  make(map[string]*NATSConsumerBacklogInfo),
                StreamInfo: NATSStreamInfo{
                        Messages: int64(streamInfo.State.Msgs),
                        Bytes:    int64(streamInfo.State.Bytes),
                        FirstSeq: int64(streamInfo.State.FirstSeq),
                        LastSeq:  int64(streamInfo.State.LastSeq),
                },
        }

        // 获取每个消费者的详细信息
        for consumerName, durableName := range nbd.consumers </span><span class="cov0" title="0">{
                consumerInfo, err := nbd.js.ConsumerInfo(nbd.streamName, durableName)
                if err != nil </span><span class="cov0" title="0">{
                        nbd.logger.Error("Failed to get consumer info for backlog info",
                                zap.String("consumer", consumerName),
                                zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">lag := int64(streamInfo.State.Msgs) - int64(consumerInfo.AckFloor.Consumer)
                if lag &lt; 0 </span><span class="cov0" title="0">{
                        lag = 0
                }</span>

                <span class="cov0" title="0">var lastDelivered time.Time
                if consumerInfo.Delivered.Last != nil </span><span class="cov0" title="0">{
                        lastDelivered = *consumerInfo.Delivered.Last
                }</span>

                <span class="cov0" title="0">info.Consumers[consumerName] = &amp;NATSConsumerBacklogInfo{
                        ConsumerName:    consumerName,
                        DurableName:     durableName,
                        AckedMessages:   int64(consumerInfo.AckFloor.Consumer),
                        PendingMessages: int64(consumerInfo.NumPending),
                        Lag:             lag,
                        LastDelivered:   lastDelivered,
                        NumRedelivered:  int64(consumerInfo.NumRedelivered),
                }

                info.TotalLag += lag</span>
        }

        <span class="cov0" title="0">return info, nil</span>
}

// NATSBacklogInfo NATS 积压信息
type NATSBacklogInfo struct {
        StreamName string                              `json:"streamName"`
        CheckTime  time.Time                           `json:"checkTime"`
        TotalLag   int64                               `json:"totalLag"`
        Consumers  map[string]*NATSConsumerBacklogInfo `json:"consumers"`
        StreamInfo NATSStreamInfo                      `json:"streamInfo"`
}

// NATSConsumerBacklogInfo NATS 消费者积压信息
type NATSConsumerBacklogInfo struct {
        ConsumerName    string    `json:"consumerName"`
        DurableName     string    `json:"durableName"`
        AckedMessages   int64     `json:"ackedMessages"`
        PendingMessages int64     `json:"pendingMessages"`
        Lag             int64     `json:"lag"`
        LastDelivered   time.Time `json:"lastDelivered"`
        NumRedelivered  int64     `json:"numRedelivered"`
}

// NATSStreamInfo NATS 流信息
type NATSStreamInfo struct {
        Messages int64 `json:"messages"`
        Bytes    int64 `json:"bytes"`
        FirstSeq int64 `json:"firstSeq"`
        LastSeq  int64 `json:"lastSeq"`
}

// RegisterCallback 注册积压状态回调
func (nbd *NATSBacklogDetector) RegisterCallback(callback BacklogStateCallback) error <span class="cov0" title="0">{
        nbd.callbackMu.Lock()
        defer nbd.callbackMu.Unlock()
        nbd.callbacks = append(nbd.callbacks, callback)
        nbd.logger.Debug("NATS backlog callback registered")
        return nil
}</span>

// Start 启动积压监控
func (nbd *NATSBacklogDetector) Start(ctx context.Context) error <span class="cov0" title="0">{
        nbd.mu.Lock()
        defer nbd.mu.Unlock()

        if nbd.isRunning </span><span class="cov0" title="0">{
                nbd.logger.Warn("NATS backlog detector is already running")
                return nil
        }</span>

        // 创建子 context
        <span class="cov0" title="0">nbd.ctx, nbd.cancel = context.WithCancel(ctx)
        nbd.ticker = time.NewTicker(nbd.checkInterval)
        nbd.isRunning = true

        // 启动监控 goroutine
        nbd.wg.Add(1)
        go nbd.monitorLoop()

        nbd.logger.Info("NATS backlog monitoring started",
                zap.String("stream", nbd.streamName),
                zap.Duration("interval", nbd.checkInterval))
        return nil</span>
}

// Stop 停止积压监控
func (nbd *NATSBacklogDetector) Stop() error <span class="cov10" title="7">{
        nbd.mu.Lock()
        defer nbd.mu.Unlock()

        if !nbd.isRunning </span><span class="cov10" title="7">{
                nbd.logger.Debug("NATS backlog detector is not running")
                return nil
        }</span>

        // 停止监控
        <span class="cov0" title="0">if nbd.cancel != nil </span><span class="cov0" title="0">{
                nbd.cancel()
        }</span>

        <span class="cov0" title="0">if nbd.ticker != nil </span><span class="cov0" title="0">{
                nbd.ticker.Stop()
        }</span>

        <span class="cov0" title="0">nbd.isRunning = false

        // 等待 goroutine 结束
        nbd.mu.Unlock()
        nbd.wg.Wait()
        nbd.mu.Lock()

        nbd.logger.Info("NATS backlog monitoring stopped",
                zap.String("stream", nbd.streamName))
        return nil</span>
}

// monitorLoop 监控循环
func (nbd *NATSBacklogDetector) monitorLoop() <span class="cov0" title="0">{
        defer nbd.wg.Done()
        defer nbd.ticker.Stop()

        nbd.logger.Debug("NATS backlog monitor loop started")

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-nbd.ctx.Done():<span class="cov0" title="0">
                        nbd.logger.Debug("NATS backlog monitor loop stopped")
                        return</span>
                case &lt;-nbd.ticker.C:<span class="cov0" title="0">
                        nbd.performBacklogCheck()</span>
                }
        }
}

// performBacklogCheck 执行积压检查
func (nbd *NATSBacklogDetector) performBacklogCheck() <span class="cov0" title="0">{
        hasBacklog, err := nbd.IsNoBacklog(nbd.ctx)
        if err != nil </span><span class="cov0" title="0">{
                nbd.logger.Error("NATS backlog check failed", zap.Error(err))
                return
        }</span>

        // 获取详细积压信息
        <span class="cov0" title="0">backlogInfo, err := nbd.GetBacklogInfo(nbd.ctx)
        if err != nil </span><span class="cov0" title="0">{
                nbd.logger.Error("Failed to get NATS backlog info", zap.Error(err))
                return
        }</span>

        // 构造状态
        <span class="cov0" title="0">state := BacklogState{
                HasBacklog:    !hasBacklog,
                LagCount:      backlogInfo.TotalLag,
                Timestamp:     time.Now(),
                Topic:         nbd.streamName, // 对于 NATS，使用 stream 名称作为 topic
                ConsumerGroup: nbd.streamName, // 对于 NATS，使用 stream 名称作为消费者组
        }

        // 计算最大积压时间（简化实现）
        if state.HasBacklog </span><span class="cov0" title="0">{
                state.LagTime = time.Since(nbd.lastCheckTime)
        }</span>

        // 通知回调
        <span class="cov0" title="0">nbd.notifyCallbacks(state)</span>
}

// notifyCallbacks 通知回调
func (nbd *NATSBacklogDetector) notifyCallbacks(state BacklogState) <span class="cov0" title="0">{
        nbd.callbackMu.RLock()
        callbacks := make([]BacklogStateCallback, len(nbd.callbacks))
        copy(callbacks, nbd.callbacks)
        nbd.callbackMu.RUnlock()

        // 从当前 context 派生，而不是使用 Background
        // 如果 ctx 为 nil，则使用 Background 作为后备
        nbd.mu.RLock()
        parentCtx := nbd.ctx
        nbd.mu.RUnlock()
        if parentCtx == nil </span><span class="cov0" title="0">{
                parentCtx = context.Background()
        }</span>

        <span class="cov0" title="0">for _, callback := range callbacks </span><span class="cov0" title="0">{
                go func(cb BacklogStateCallback) </span><span class="cov0" title="0">{
                        // 使用父 context 派生，支持取消传播
                        ctx, cancel := context.WithTimeout(parentCtx, 10*time.Second)
                        defer cancel()

                        if err := cb(ctx, state); err != nil </span><span class="cov0" title="0">{
                                nbd.logger.Error("NATS backlog callback failed",
                                        zap.Error(err),
                                        zap.Bool("hasBacklog", state.HasBacklog))
                        }</span>
                }(callback)
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package eventbus

import (
        "sync"
        "time"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
        "go.uber.org/zap"
)

// NATSMetrics NATS EventBus详细指标
type NATSMetrics struct {
        // 消息指标
        MessagesPublished   *prometheus.CounterVec
        MessagesConsumed    *prometheus.CounterVec
        MessageProcessingTime *prometheus.HistogramVec
        MessageSize         *prometheus.HistogramVec
        
        // JetStream特定指标
        StreamMessages      *prometheus.GaugeVec
        StreamBytes         *prometheus.GaugeVec
        ConsumerPending     *prometheus.GaugeVec
        ConsumerDelivered   *prometheus.CounterVec
        ConsumerAckPending  *prometheus.GaugeVec
        
        // 连接指标
        ConnectionStatus    prometheus.Gauge
        ReconnectCount      prometheus.Counter
        HealthCheckDuration *prometheus.HistogramVec
        
        // 错误指标
        PublishErrors       *prometheus.CounterVec
        ConsumeErrors       *prometheus.CounterVec
        ConnectionErrors    prometheus.Counter
        JetStreamErrors     *prometheus.CounterVec
        
        // 性能指标
        PublishDuration     *prometheus.HistogramVec
        SubscribeDuration   *prometheus.HistogramVec
        
        logger *zap.Logger
        mu     sync.RWMutex
}

// NewNATSMetrics 创建NATS指标收集器
func NewNATSMetrics(namespace, subsystem string) *NATSMetrics <span class="cov0" title="0">{
        return &amp;NATSMetrics{
                // 消息指标
                MessagesPublished: promauto.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: namespace,
                                Subsystem: subsystem,
                                Name:      "messages_published_total",
                                Help:      "Total number of messages published to NATS",
                        },
                        []string{"topic", "jetstream"},
                ),
                
                MessagesConsumed: promauto.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: namespace,
                                Subsystem: subsystem,
                                Name:      "messages_consumed_total",
                                Help:      "Total number of messages consumed from NATS",
                        },
                        []string{"topic", "jetstream", "consumer"},
                ),
                
                MessageProcessingTime: promauto.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Namespace: namespace,
                                Subsystem: subsystem,
                                Name:      "message_processing_duration_seconds",
                                Help:      "Time spent processing messages",
                                Buckets:   prometheus.DefBuckets,
                        },
                        []string{"topic", "status"},
                ),
                
                MessageSize: promauto.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Namespace: namespace,
                                Subsystem: subsystem,
                                Name:      "message_size_bytes",
                                Help:      "Size of messages in bytes",
                                Buckets:   prometheus.ExponentialBuckets(64, 2, 10),
                        },
                        []string{"topic", "direction"},
                ),
                
                // JetStream特定指标
                StreamMessages: promauto.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Namespace: namespace,
                                Subsystem: subsystem,
                                Name:      "jetstream_stream_messages",
                                Help:      "Number of messages in JetStream stream",
                        },
                        []string{"stream"},
                ),
                
                StreamBytes: promauto.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Namespace: namespace,
                                Subsystem: subsystem,
                                Name:      "jetstream_stream_bytes",
                                Help:      "Number of bytes in JetStream stream",
                        },
                        []string{"stream"},
                ),
                
                ConsumerPending: promauto.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Namespace: namespace,
                                Subsystem: subsystem,
                                Name:      "jetstream_consumer_pending",
                                Help:      "Number of pending messages for JetStream consumer",
                        },
                        []string{"stream", "consumer"},
                ),
                
                ConsumerDelivered: promauto.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: namespace,
                                Subsystem: subsystem,
                                Name:      "jetstream_consumer_delivered_total",
                                Help:      "Total number of messages delivered to JetStream consumer",
                        },
                        []string{"stream", "consumer"},
                ),
                
                ConsumerAckPending: promauto.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Namespace: namespace,
                                Subsystem: subsystem,
                                Name:      "jetstream_consumer_ack_pending",
                                Help:      "Number of messages pending acknowledgment for JetStream consumer",
                        },
                        []string{"stream", "consumer"},
                ),
                
                // 连接指标
                ConnectionStatus: promauto.NewGauge(
                        prometheus.GaugeOpts{
                                Namespace: namespace,
                                Subsystem: subsystem,
                                Name:      "connection_status",
                                Help:      "NATS connection status (1=connected, 0=disconnected)",
                        },
                ),
                
                ReconnectCount: promauto.NewCounter(
                        prometheus.CounterOpts{
                                Namespace: namespace,
                                Subsystem: subsystem,
                                Name:      "reconnect_total",
                                Help:      "Total number of NATS reconnections",
                        },
                ),
                
                HealthCheckDuration: promauto.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Namespace: namespace,
                                Subsystem: subsystem,
                                Name:      "health_check_duration_seconds",
                                Help:      "Time spent on health checks",
                                Buckets:   prometheus.DefBuckets,
                        },
                        []string{"status"},
                ),
                
                // 错误指标
                PublishErrors: promauto.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: namespace,
                                Subsystem: subsystem,
                                Name:      "publish_errors_total",
                                Help:      "Total number of publish errors",
                        },
                        []string{"topic", "error_type"},
                ),
                
                ConsumeErrors: promauto.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: namespace,
                                Subsystem: subsystem,
                                Name:      "consume_errors_total",
                                Help:      "Total number of consume errors",
                        },
                        []string{"topic", "error_type"},
                ),
                
                ConnectionErrors: promauto.NewCounter(
                        prometheus.CounterOpts{
                                Namespace: namespace,
                                Subsystem: subsystem,
                                Name:      "connection_errors_total",
                                Help:      "Total number of connection errors",
                        },
                ),
                
                JetStreamErrors: promauto.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: namespace,
                                Subsystem: subsystem,
                                Name:      "jetstream_errors_total",
                                Help:      "Total number of JetStream errors",
                        },
                        []string{"operation", "error_type"},
                ),
                
                // 性能指标
                PublishDuration: promauto.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Namespace: namespace,
                                Subsystem: subsystem,
                                Name:      "publish_duration_seconds",
                                Help:      "Time spent publishing messages",
                                Buckets:   prometheus.DefBuckets,
                        },
                        []string{"topic", "jetstream"},
                ),
                
                SubscribeDuration: promauto.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Namespace: namespace,
                                Subsystem: subsystem,
                                Name:      "subscribe_duration_seconds",
                                Help:      "Time spent on subscription operations",
                                Buckets:   prometheus.DefBuckets,
                        },
                        []string{"topic", "operation"},
                ),
                
                logger: nil, // 将在初始化时设置
        }
}</span>

// RecordPublish 记录消息发布指标
func (m *NATSMetrics) RecordPublish(topic string, jetstream bool, size int, duration time.Duration, err error) <span class="cov0" title="0">{
        jetstreamStr := "false"
        if jetstream </span><span class="cov0" title="0">{
                jetstreamStr = "true"
        }</span>
        
        <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                m.MessagesPublished.WithLabelValues(topic, jetstreamStr).Inc()
                m.MessageSize.WithLabelValues(topic, "publish").Observe(float64(size))
                m.PublishDuration.WithLabelValues(topic, jetstreamStr).Observe(duration.Seconds())
        }</span> else<span class="cov0" title="0"> {
                errorType := classifyError(err)
                m.PublishErrors.WithLabelValues(topic, errorType).Inc()
                if jetstream </span><span class="cov0" title="0">{
                        m.JetStreamErrors.WithLabelValues("publish", errorType).Inc()
                }</span>
        }
}

// RecordConsume 记录消息消费指标
func (m *NATSMetrics) RecordConsume(topic, consumer string, jetstream bool, size int, processingTime time.Duration, err error) <span class="cov0" title="0">{
        jetstreamStr := "false"
        if jetstream </span><span class="cov0" title="0">{
                jetstreamStr = "true"
        }</span>
        
        <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                m.MessagesConsumed.WithLabelValues(topic, jetstreamStr, consumer).Inc()
                m.MessageSize.WithLabelValues(topic, "consume").Observe(float64(size))
                m.MessageProcessingTime.WithLabelValues(topic, "success").Observe(processingTime.Seconds())
        }</span> else<span class="cov0" title="0"> {
                errorType := classifyError(err)
                m.ConsumeErrors.WithLabelValues(topic, errorType).Inc()
                m.MessageProcessingTime.WithLabelValues(topic, "error").Observe(processingTime.Seconds())
                if jetstream </span><span class="cov0" title="0">{
                        m.JetStreamErrors.WithLabelValues("consume", errorType).Inc()
                }</span>
        }
}

// RecordHealthCheck 记录健康检查指标
func (m *NATSMetrics) RecordHealthCheck(duration time.Duration, err error) <span class="cov0" title="0">{
        status := "success"
        if err != nil </span><span class="cov0" title="0">{
                status = "error"
        }</span>
        <span class="cov0" title="0">m.HealthCheckDuration.WithLabelValues(status).Observe(duration.Seconds())</span>
}

// UpdateConnectionStatus 更新连接状态
func (m *NATSMetrics) UpdateConnectionStatus(connected bool) <span class="cov0" title="0">{
        if connected </span><span class="cov0" title="0">{
                m.ConnectionStatus.Set(1)
        }</span> else<span class="cov0" title="0"> {
                m.ConnectionStatus.Set(0)
        }</span>
}

// RecordReconnect 记录重连事件
func (m *NATSMetrics) RecordReconnect() <span class="cov0" title="0">{
        m.ReconnectCount.Inc()
}</span>

// UpdateJetStreamMetrics 更新JetStream指标
func (m *NATSMetrics) UpdateJetStreamMetrics(streamName string, messages, bytes uint64) <span class="cov0" title="0">{
        m.StreamMessages.WithLabelValues(streamName).Set(float64(messages))
        m.StreamBytes.WithLabelValues(streamName).Set(float64(bytes))
}</span>

// UpdateConsumerMetrics 更新消费者指标
func (m *NATSMetrics) UpdateConsumerMetrics(streamName, consumerName string, pending, delivered, ackPending uint64) <span class="cov0" title="0">{
        m.ConsumerPending.WithLabelValues(streamName, consumerName).Set(float64(pending))
        m.ConsumerDelivered.WithLabelValues(streamName, consumerName).Add(float64(delivered))
        m.ConsumerAckPending.WithLabelValues(streamName, consumerName).Set(float64(ackPending))
}</span>

// classifyError 分类错误类型
func classifyError(err error) string <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return "none"
        }</span>
        
        <span class="cov0" title="0">errStr := err.Error()
        switch </span>{
        case contains(errStr, "timeout"):<span class="cov0" title="0">
                return "timeout"</span>
        case contains(errStr, "connection"):<span class="cov0" title="0">
                return "connection"</span>
        case contains(errStr, "permission"):<span class="cov0" title="0">
                return "permission"</span>
        case contains(errStr, "not found"):<span class="cov0" title="0">
                return "not_found"</span>
        case contains(errStr, "invalid"):<span class="cov0" title="0">
                return "invalid"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// contains 检查字符串是否包含子字符串
func contains(s, substr string) bool <span class="cov0" title="0">{
        return len(s) &gt;= len(substr) &amp;&amp; (s == substr || (len(s) &gt; len(substr) &amp;&amp; 
                (s[:len(substr)] == substr || s[len(s)-len(substr):] == substr || 
                 indexOf(s, substr) &gt;= 0)))
}</span>

// indexOf 查找子字符串位置
func indexOf(s, substr string) int <span class="cov0" title="0">{
        for i := 0; i &lt;= len(s)-len(substr); i++ </span><span class="cov0" title="0">{
                if s[i:i+len(substr)] == substr </span><span class="cov0" title="0">{
                        return i
                }</span>
        }
        <span class="cov0" title="0">return -1</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package eventbus

import (
        "context"
        "sync"
        "sync/atomic"
        "time"

        "github.com/ChenBigdata421/jxt-core/sdk/config"
        "github.com/ChenBigdata421/jxt-core/sdk/pkg/logger"
        "github.com/IBM/sarama"
        "go.uber.org/zap"
)

// PublisherBacklogDetector 发送端积压检测器
type PublisherBacklogDetector struct {
        client            sarama.Client
        admin             sarama.ClusterAdmin
        maxQueueDepth     int64
        maxPublishLatency time.Duration
        rateThreshold     float64
        checkInterval     time.Duration

        // 监控指标
        publishCount   atomic.Int64
        publishLatency atomic.Int64 // 纳秒
        lastCheckTime  time.Time
        publishRate    float64
        queueDepth     atomic.Int64

        // 状态管理
        mu     sync.RWMutex
        logger *zap.Logger

        // 回调和生命周期管理
        callbacks  []PublisherBacklogCallback
        callbackMu sync.RWMutex
        ctx        context.Context
        cancel     context.CancelFunc
        wg         sync.WaitGroup
        isRunning  bool
        ticker     *time.Ticker
}

// NewPublisherBacklogDetector 创建发送端积压检测器
func NewPublisherBacklogDetector(client sarama.Client, admin sarama.ClusterAdmin, cfg config.PublisherBacklogDetectionConfig) *PublisherBacklogDetector <span class="cov3" title="19">{
        return &amp;PublisherBacklogDetector{
                client:            client,
                admin:             admin,
                maxQueueDepth:     cfg.MaxQueueDepth,
                maxPublishLatency: cfg.MaxPublishLatency,
                rateThreshold:     cfg.RateThreshold,
                checkInterval:     cfg.CheckInterval,
                lastCheckTime:     time.Now(),
                logger:            logger.Logger,
        }
}</span>

// RecordPublish 记录发送操作
func (pbd *PublisherBacklogDetector) RecordPublish(latency time.Duration) <span class="cov10" title="10006">{
        pbd.publishCount.Add(1)
        pbd.publishLatency.Add(int64(latency))
}</span>

// UpdateQueueDepth 更新队列深度
func (pbd *PublisherBacklogDetector) UpdateQueueDepth(depth int64) <span class="cov5" title="104">{
        pbd.queueDepth.Store(depth)
}</span>

// RegisterCallback 注册积压回调
func (pbd *PublisherBacklogDetector) RegisterCallback(callback PublisherBacklogCallback) error <span class="cov2" title="5">{
        pbd.callbackMu.Lock()
        defer pbd.callbackMu.Unlock()

        pbd.callbacks = append(pbd.callbacks, callback)
        pbd.logger.Info("Publisher backlog callback registered")
        return nil
}</span>

// Start 启动发送端积压检测器
func (pbd *PublisherBacklogDetector) Start(ctx context.Context) error <span class="cov2" title="5">{
        pbd.mu.Lock()
        defer pbd.mu.Unlock()

        if pbd.isRunning </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov2" title="4">pbd.ctx, pbd.cancel = context.WithCancel(ctx)
        pbd.ticker = time.NewTicker(pbd.checkInterval)
        pbd.isRunning = true

        pbd.wg.Add(1)
        go pbd.monitoringLoop()

        pbd.logger.Info("Publisher backlog detector started",
                zap.Duration("checkInterval", pbd.checkInterval),
                zap.Int64("maxQueueDepth", pbd.maxQueueDepth),
                zap.Float64("rateThreshold", pbd.rateThreshold))

        return nil</span>
}

// Stop 停止发送端积压检测器
func (pbd *PublisherBacklogDetector) Stop() error <span class="cov2" title="5">{
        pbd.mu.Lock()
        defer pbd.mu.Unlock()

        if !pbd.isRunning </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov2" title="4">pbd.isRunning = false
        if pbd.cancel != nil </span><span class="cov2" title="4">{
                pbd.cancel()
        }</span>
        <span class="cov2" title="4">if pbd.ticker != nil </span><span class="cov2" title="4">{
                pbd.ticker.Stop()
        }</span>

        <span class="cov2" title="4">pbd.wg.Wait()

        pbd.logger.Info("Publisher backlog detector stopped")
        return nil</span>
}

// monitoringLoop 监控循环
func (pbd *PublisherBacklogDetector) monitoringLoop() <span class="cov2" title="4">{
        defer pbd.wg.Done()

        for </span><span class="cov3" title="12">{
                select </span>{
                case &lt;-pbd.ctx.Done():<span class="cov2" title="4">
                        return</span>
                case &lt;-pbd.ticker.C:<span class="cov3" title="8">
                        pbd.performBacklogCheck()</span>
                }
        }
}

// performBacklogCheck 执行积压检查
func (pbd *PublisherBacklogDetector) performBacklogCheck() <span class="cov3" title="8">{
        now := time.Now()

        // 计算发送速率
        publishCount := pbd.publishCount.Load()
        timeDiff := now.Sub(pbd.lastCheckTime).Seconds()
        if timeDiff &gt; 0 </span><span class="cov3" title="8">{
                pbd.publishRate = float64(publishCount) / timeDiff
        }</span>

        // 计算平均延迟
        <span class="cov3" title="8">totalLatency := pbd.publishLatency.Load()
        var avgLatency time.Duration
        if publishCount &gt; 0 </span><span class="cov1" title="1">{
                avgLatency = time.Duration(totalLatency / publishCount)
        }</span>

        // 获取当前队列深度
        <span class="cov3" title="8">currentQueueDepth := pbd.queueDepth.Load()

        // 判断是否有积压
        hasBacklog := pbd.isBacklogged(currentQueueDepth, avgLatency, pbd.publishRate)

        // 计算积压比例和严重程度
        backlogRatio := pbd.calculateBacklogRatio(currentQueueDepth, avgLatency, pbd.publishRate)
        severity := pbd.calculateSeverity(backlogRatio)

        // 构造状态
        state := PublisherBacklogState{
                HasBacklog:        hasBacklog,
                QueueDepth:        currentQueueDepth,
                PublishRate:       pbd.publishRate,
                AvgPublishLatency: avgLatency,
                BacklogRatio:      backlogRatio,
                Timestamp:         now,
                Severity:          severity,
        }

        // 通知回调
        pbd.notifyCallbacks(state)

        // 重置计数器
        pbd.publishCount.Store(0)
        pbd.publishLatency.Store(0)
        pbd.lastCheckTime = now</span>
}

// isBacklogged 判断是否积压
func (pbd *PublisherBacklogDetector) isBacklogged(queueDepth int64, avgLatency time.Duration, publishRate float64) bool <span class="cov3" title="13">{
        // 队列深度检查
        if pbd.maxQueueDepth &gt; 0 &amp;&amp; queueDepth &gt; pbd.maxQueueDepth </span><span class="cov1" title="1">{
                return true
        }</span>

        // 发送延迟检查
        <span class="cov3" title="12">if pbd.maxPublishLatency &gt; 0 &amp;&amp; avgLatency &gt; pbd.maxPublishLatency </span><span class="cov1" title="1">{
                return true
        }</span>

        // 发送速率检查（速率过高也可能导致积压）
        <span class="cov3" title="11">if pbd.rateThreshold &gt; 0 &amp;&amp; publishRate &gt; pbd.rateThreshold </span><span class="cov1" title="1">{
                return true
        }</span>

        <span class="cov3" title="10">return false</span>
}

// calculateBacklogRatio 计算积压比例
func (pbd *PublisherBacklogDetector) calculateBacklogRatio(queueDepth int64, avgLatency time.Duration, publishRate float64) float64 <span class="cov3" title="12">{
        var ratios []float64

        // 队列深度比例
        if pbd.maxQueueDepth &gt; 0 </span><span class="cov3" title="12">{
                ratios = append(ratios, float64(queueDepth)/float64(pbd.maxQueueDepth))
        }</span>

        // 延迟比例
        <span class="cov3" title="12">if pbd.maxPublishLatency &gt; 0 </span><span class="cov3" title="12">{
                ratios = append(ratios, float64(avgLatency)/float64(pbd.maxPublishLatency))
        }</span>

        // 速率比例
        <span class="cov3" title="12">if pbd.rateThreshold &gt; 0 </span><span class="cov3" title="12">{
                ratios = append(ratios, publishRate/pbd.rateThreshold)
        }</span>

        // 返回最大比例
        <span class="cov3" title="12">maxRatio := 0.0
        for _, ratio := range ratios </span><span class="cov4" title="36">{
                if ratio &gt; maxRatio </span><span class="cov3" title="9">{
                        maxRatio = ratio
                }</span>
        }

        // 限制在 0.0-1.0 范围内
        <span class="cov3" title="12">if maxRatio &gt; 1.0 </span><span class="cov1" title="1">{
                maxRatio = 1.0
        }</span>

        <span class="cov3" title="12">return maxRatio</span>
}

// calculateSeverity 计算严重程度
func (pbd *PublisherBacklogDetector) calculateSeverity(backlogRatio float64) string <span class="cov3" title="14">{
        switch </span>{
        case backlogRatio &gt;= 0.9:<span class="cov1" title="1">
                return "CRITICAL"</span>
        case backlogRatio &gt;= 0.7:<span class="cov1" title="1">
                return "HIGH"</span>
        case backlogRatio &gt;= 0.5:<span class="cov2" title="6">
                return "MEDIUM"</span>
        case backlogRatio &gt;= 0.3:<span class="cov1" title="1">
                return "LOW"</span>
        default:<span class="cov2" title="5">
                return "NORMAL"</span>
        }
}

// notifyCallbacks 通知回调
func (pbd *PublisherBacklogDetector) notifyCallbacks(state PublisherBacklogState) <span class="cov3" title="8">{
        pbd.callbackMu.RLock()
        callbacks := make([]PublisherBacklogCallback, len(pbd.callbacks))
        copy(callbacks, pbd.callbacks)
        pbd.callbackMu.RUnlock()

        for _, callback := range callbacks </span><span class="cov3" title="16">{
                go func(cb PublisherBacklogCallback) </span><span class="cov3" title="16">{
                        defer func() </span><span class="cov3" title="16">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        pbd.logger.Error("Publisher backlog callback panic", zap.Any("panic", r))
                                }</span>
                        }()

                        <span class="cov3" title="16">if err := cb(pbd.ctx, state); err != nil </span><span class="cov0" title="0">{
                                pbd.logger.Error("Publisher backlog callback error", zap.Error(err))
                        }</span>
                }(callback)
        }
}

// GetBacklogState 获取当前积压状态
func (pbd *PublisherBacklogDetector) GetBacklogState() PublisherBacklogState <span class="cov1" title="1">{
        now := time.Now()
        publishCount := pbd.publishCount.Load()
        totalLatency := pbd.publishLatency.Load()
        currentQueueDepth := pbd.queueDepth.Load()

        var avgLatency time.Duration
        if publishCount &gt; 0 </span><span class="cov1" title="1">{
                avgLatency = time.Duration(totalLatency / publishCount)
        }</span>

        <span class="cov1" title="1">timeDiff := now.Sub(pbd.lastCheckTime).Seconds()
        publishRate := 0.0
        if timeDiff &gt; 0 </span><span class="cov1" title="1">{
                publishRate = float64(publishCount) / timeDiff
        }</span>

        <span class="cov1" title="1">hasBacklog := pbd.isBacklogged(currentQueueDepth, avgLatency, publishRate)
        backlogRatio := pbd.calculateBacklogRatio(currentQueueDepth, avgLatency, publishRate)
        severity := pbd.calculateSeverity(backlogRatio)

        return PublisherBacklogState{
                HasBacklog:        hasBacklog,
                QueueDepth:        currentQueueDepth,
                PublishRate:       publishRate,
                AvgPublishLatency: avgLatency,
                BacklogRatio:      backlogRatio,
                Timestamp:         now,
                Severity:          severity,
        }</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package eventbus

import (
        "context"
        "time"

        "github.com/ChenBigdata421/jxt-core/sdk/pkg/logger"
        "go.uber.org/zap"
        "golang.org/x/time/rate"
)

// RateLimiter 流量控制器
// 实现比evidence-management更灵活的流量控制
type RateLimiter struct {
        limiter   *rate.Limiter
        burstSize int
        rateLimit rate.Limit
        enabled   bool
        logger    *zap.Logger
}

// NewRateLimiter 创建流量控制器
func NewRateLimiter(config RateLimitConfig) *RateLimiter <span class="cov4" title="14">{
        if !config.Enabled </span><span class="cov1" title="2">{
                return &amp;RateLimiter{
                        enabled: false,
                        logger:  logger.Logger,
                }
        }</span>

        <span class="cov4" title="12">rateLimit := rate.Limit(config.RatePerSecond)
        limiter := rate.NewLimiter(rateLimit, config.BurstSize)

        return &amp;RateLimiter{
                limiter:   limiter,
                burstSize: config.BurstSize,
                rateLimit: rateLimit,
                enabled:   true,
                logger:    logger.Logger,
        }</span>
}

// RateLimitConfig 流量控制配置
type RateLimitConfig struct {
        Enabled       bool    // 是否启用流量控制
        RatePerSecond float64 // 每秒允许的请求数
        BurstSize     int     // 突发容量
}

// Wait 等待令牌，实现背压机制
func (rl *RateLimiter) Wait(ctx context.Context) error <span class="cov10" title="601">{
        if !rl.enabled </span><span class="cov7" title="100">{
                return nil // 未启用流量控制，直接通过
        }</span>

        <span class="cov9" title="501">start := time.Now()
        err := rl.limiter.Wait(ctx)
        if err != nil </span><span class="cov0" title="0">{
                rl.logger.Error("Rate limiter wait failed", zap.Error(err))
                return err
        }</span>

        <span class="cov9" title="501">waitTime := time.Since(start)
        if waitTime &gt; 100*time.Millisecond </span><span class="cov9" title="481">{
                rl.logger.Warn("Rate limiter caused significant delay",
                        zap.Duration("waitTime", waitTime),
                        zap.Float64("rateLimit", float64(rl.rateLimit)),
                        zap.Int("burstSize", rl.burstSize))
        }</span>

        <span class="cov9" title="501">return nil</span>
}

// Allow 检查是否允许立即处理（非阻塞）
func (rl *RateLimiter) Allow() bool <span class="cov2" title="3">{
        if !rl.enabled </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov2" title="3">return rl.limiter.Allow()</span>
}

// Reserve 预留令牌
func (rl *RateLimiter) Reserve() *rate.Reservation <span class="cov1" title="1">{
        if !rl.enabled </span><span class="cov0" title="0">{
                // 返回一个立即可用的预留
                return &amp;rate.Reservation{}
        }</span>
        <span class="cov1" title="1">return rl.limiter.Reserve()</span>
}

// SetLimit 动态调整限流参数
func (rl *RateLimiter) SetLimit(ratePerSecond float64) <span class="cov1" title="1">{
        if !rl.enabled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="1">newLimit := rate.Limit(ratePerSecond)
        rl.limiter.SetLimit(newLimit)
        rl.rateLimit = newLimit

        rl.logger.Info("Rate limit updated",
                zap.Float64("newRateLimit", float64(newLimit)),
                zap.Int("burstSize", rl.burstSize))</span>
}

// SetBurst 动态调整突发容量
func (rl *RateLimiter) SetBurst(burstSize int) <span class="cov1" title="1">{
        if !rl.enabled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="1">rl.limiter.SetBurst(burstSize)
        rl.burstSize = burstSize

        rl.logger.Info("Burst size updated",
                zap.Float64("rateLimit", float64(rl.rateLimit)),
                zap.Int("newBurstSize", burstSize))</span>
}

// GetStats 获取流量控制统计信息
func (rl *RateLimiter) GetStats() *RateLimiterStats <span class="cov3" title="6">{
        if !rl.enabled </span><span class="cov0" title="0">{
                return &amp;RateLimiterStats{
                        Enabled: false,
                }
        }</span>

        <span class="cov3" title="6">return &amp;RateLimiterStats{
                Enabled:         true,
                RateLimit:       float64(rl.rateLimit),
                BurstSize:       rl.burstSize,
                TokensAvailable: rl.limiter.Tokens(),
        }</span>
}

// RateLimiterStats 流量控制统计信息
type RateLimiterStats struct {
        Enabled         bool    `json:"enabled"`
        RateLimit       float64 `json:"rateLimit"`
        BurstSize       int     `json:"burstSize"`
        TokensAvailable float64 `json:"tokensAvailable"`
}

// AdaptiveRateLimiter 自适应流量控制器
// 根据系统负载自动调整限流参数
type AdaptiveRateLimiter struct {
        *RateLimiter
        baseRate          rate.Limit
        maxRate           rate.Limit
        minRate           rate.Limit
        adaptInterval     time.Duration
        lastAdaptTime     time.Time
        errorRate         float64
        successRate       float64
        adaptationEnabled bool
}

// NewAdaptiveRateLimiter 创建自适应流量控制器
func NewAdaptiveRateLimiter(config RateLimitConfig, adaptConfig AdaptiveRateLimitConfig) *AdaptiveRateLimiter <span class="cov2" title="4">{
        baseLimiter := NewRateLimiter(config)

        return &amp;AdaptiveRateLimiter{
                RateLimiter:       baseLimiter,
                baseRate:          rate.Limit(config.RatePerSecond),
                maxRate:           rate.Limit(adaptConfig.MaxRatePerSecond),
                minRate:           rate.Limit(adaptConfig.MinRatePerSecond),
                adaptInterval:     adaptConfig.AdaptInterval,
                adaptationEnabled: adaptConfig.Enabled,
        }
}</span>

// AdaptiveRateLimitConfig 自适应流量控制配置
type AdaptiveRateLimitConfig struct {
        Enabled          bool          `mapstructure:"enabled"`
        MaxRatePerSecond float64       `mapstructure:"maxRatePerSecond"`
        MinRatePerSecond float64       `mapstructure:"minRatePerSecond"`
        AdaptInterval    time.Duration `mapstructure:"adaptInterval"`
        ErrorThreshold   float64       `mapstructure:"errorThreshold"`
        SuccessThreshold float64       `mapstructure:"successThreshold"`
}

// RecordSuccess 记录成功处理
func (arl *AdaptiveRateLimiter) RecordSuccess() <span class="cov4" title="11">{
        if !arl.adaptationEnabled </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov4" title="11">arl.successRate = arl.successRate*0.9 + 0.1 // 指数移动平均
        arl.tryAdapt()</span>
}

// RecordError 记录处理错误
func (arl *AdaptiveRateLimiter) RecordError() <span class="cov3" title="6">{
        if !arl.adaptationEnabled </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov3" title="6">arl.errorRate = arl.errorRate*0.9 + 0.1 // 指数移动平均
        arl.tryAdapt()</span>
}

// tryAdapt 尝试自适应调整
func (arl *AdaptiveRateLimiter) tryAdapt() <span class="cov4" title="17">{
        if time.Since(arl.lastAdaptTime) &lt; arl.adaptInterval </span><span class="cov4" title="14">{
                return
        }</span>

        <span class="cov2" title="3">currentRate := arl.rateLimit
        newRate := currentRate

        // 根据错误率和成功率调整
        if arl.errorRate &gt; 0.1 </span><span class="cov0" title="0">{ // 错误率过高，降低速率
                newRate = rate.Limit(float64(currentRate) * 0.8)
                if newRate &lt; arl.minRate </span><span class="cov0" title="0">{
                        newRate = arl.minRate
                }</span>
        } else<span class="cov2" title="3"> if arl.successRate &gt; 0.9 </span><span class="cov0" title="0">{ // 成功率很高，可以提高速率
                newRate = rate.Limit(float64(currentRate) * 1.2)
                if newRate &gt; arl.maxRate </span><span class="cov0" title="0">{
                        newRate = arl.maxRate
                }</span>
        }

        <span class="cov2" title="3">if newRate != currentRate </span><span class="cov0" title="0">{
                arl.SetLimit(float64(newRate))
                arl.logger.Info("Adaptive rate limit adjusted",
                        zap.Float64("oldRate", float64(currentRate)),
                        zap.Float64("newRate", float64(newRate)),
                        zap.Float64("errorRate", arl.errorRate),
                        zap.Float64("successRate", arl.successRate))
        }</span>

        <span class="cov2" title="3">arl.lastAdaptTime = time.Now()</span>
}

// GetAdaptiveStats 获取自适应流量控制统计信息
func (arl *AdaptiveRateLimiter) GetAdaptiveStats() *AdaptiveRateLimiterStats <span class="cov2" title="3">{
        baseStats := arl.GetStats()
        return &amp;AdaptiveRateLimiterStats{
                RateLimiterStats:  *baseStats,
                AdaptationEnabled: arl.adaptationEnabled,
                BaseRate:          float64(arl.baseRate),
                MaxRate:           float64(arl.maxRate),
                MinRate:           float64(arl.minRate),
                ErrorRate:         arl.errorRate,
                SuccessRate:       arl.successRate,
                LastAdaptTime:     arl.lastAdaptTime,
        }
}</span>

// AdaptiveRateLimiterStats 自适应流量控制统计信息
type AdaptiveRateLimiterStats struct {
        RateLimiterStats
        AdaptationEnabled bool      `json:"adaptationEnabled"`
        BaseRate          float64   `json:"baseRate"`
        MaxRate           float64   `json:"maxRate"`
        MinRate           float64   `json:"minRate"`
        ErrorRate         float64   `json:"errorRate"`
        SuccessRate       float64   `json:"successRate"`
        LastAdaptTime     time.Time `json:"lastAdaptTime"`
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package eventbus

import (
        "context"
        "fmt"
        "time"

        "github.com/ChenBigdata421/jxt-core/sdk/pkg/logger"
)

// TopicConfigStrategy 主题配置策略
type TopicConfigStrategy string

const (
        // StrategyCreateOnly 创建模式：只创建，不更新（生产环境推荐）
        StrategyCreateOnly TopicConfigStrategy = "create_only"

        // StrategyCreateOrUpdate 更新模式：创建或更新（开发环境推荐）
        StrategyCreateOrUpdate TopicConfigStrategy = "create_or_update"

        // StrategyValidateOnly 验证模式：只验证，不修改（严格模式）
        StrategyValidateOnly TopicConfigStrategy = "validate_only"

        // StrategySkip 跳过模式：不检查（性能优先）
        StrategySkip TopicConfigStrategy = "skip"
)

// TopicConfigMismatchAction 配置不一致时的行为
type TopicConfigMismatchAction struct {
        LogLevel string // debug, info, warn, error
        FailFast bool   // 是否立即失败
}

// TopicConfigManagerConfig 主题配置管理器配置
type TopicConfigManagerConfig struct {
        // 配置策略
        Strategy TopicConfigStrategy

        // 配置不一致时的行为
        OnMismatch TopicConfigMismatchAction

        // 是否启用配置验证
        EnableValidation bool

        // 配置同步超时
        SyncTimeout time.Duration
}

// DefaultTopicConfigManagerConfig 返回默认配置
func DefaultTopicConfigManagerConfig() TopicConfigManagerConfig <span class="cov1" title="1">{
        return TopicConfigManagerConfig{
                Strategy: StrategyCreateOrUpdate,
                OnMismatch: TopicConfigMismatchAction{
                        LogLevel: "warn",
                        FailFast: false,
                },
                EnableValidation: true,
                SyncTimeout:      30 * time.Second,
        }
}</span>

// ProductionTopicConfigManagerConfig 返回生产环境推荐配置
func ProductionTopicConfigManagerConfig() TopicConfigManagerConfig <span class="cov1" title="1">{
        return TopicConfigManagerConfig{
                Strategy: StrategyCreateOnly,
                OnMismatch: TopicConfigMismatchAction{
                        LogLevel: "warn",
                        FailFast: false,
                },
                EnableValidation: true,
                SyncTimeout:      30 * time.Second,
        }
}</span>

// StrictTopicConfigManagerConfig 返回严格模式配置
func StrictTopicConfigManagerConfig() TopicConfigManagerConfig <span class="cov1" title="1">{
        return TopicConfigManagerConfig{
                Strategy: StrategyValidateOnly,
                OnMismatch: TopicConfigMismatchAction{
                        LogLevel: "error",
                        FailFast: true,
                },
                EnableValidation: true,
                SyncTimeout:      30 * time.Second,
        }
}</span>

// TopicConfigMismatch 配置不一致信息
type TopicConfigMismatch struct {
        Topic          string
        Field          string
        ExpectedValue  interface{}
        ActualValue    interface{}
        CanAutoFix     bool
        Recommendation string
}

// TopicConfigSyncResult 配置同步结果
type TopicConfigSyncResult struct {
        Topic      string
        Action     string // created, updated, validated, skipped
        Success    bool
        Error      error
        Mismatches []TopicConfigMismatch
        Duration   time.Duration
}

// TopicConfigManager 主题配置管理器接口
type TopicConfigManager interface {
        // ConfigureTopic 配置主题（幂等操作）
        ConfigureTopic(ctx context.Context, topic string, options TopicOptions) (*TopicConfigSyncResult, error)

        // ValidateTopicConfig 验证主题配置
        ValidateTopicConfig(ctx context.Context, topic string, options TopicOptions) ([]TopicConfigMismatch, error)

        // GetTopicConfig 获取主题配置
        GetTopicConfig(topic string) (TopicOptions, error)

        // ListConfiguredTopics 列出所有已配置的主题
        ListConfiguredTopics() []string

        // RemoveTopicConfig 移除主题配置
        RemoveTopicConfig(topic string) error

        // SetStrategy 设置配置策略
        SetStrategy(strategy TopicConfigStrategy)

        // GetStrategy 获取当前策略
        GetStrategy() TopicConfigStrategy
}

// logConfigMismatch 记录配置不一致
func logConfigMismatch(mismatch TopicConfigMismatch, action TopicConfigMismatchAction) <span class="cov4" title="2">{
        msg := fmt.Sprintf("Topic config mismatch: topic=%s, field=%s, expected=%v, actual=%v",
                mismatch.Topic, mismatch.Field, mismatch.ExpectedValue, mismatch.ActualValue)

        switch action.LogLevel </span>{
        case "debug":<span class="cov0" title="0">
                logger.Debug(msg)</span>
        case "info":<span class="cov0" title="0">
                logger.Info(msg)</span>
        case "warn":<span class="cov1" title="1">
                logger.Warn(msg, "recommendation", mismatch.Recommendation)</span>
        case "error":<span class="cov1" title="1">
                logger.Error(msg, "recommendation", mismatch.Recommendation)</span>
        default:<span class="cov0" title="0">
                logger.Warn(msg)</span>
        }
}

// handleConfigMismatches 处理配置不一致
func handleConfigMismatches(mismatches []TopicConfigMismatch, action TopicConfigMismatchAction) error <span class="cov5" title="3">{
        if len(mismatches) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>

        // 记录所有不一致
        <span class="cov4" title="2">for _, mismatch := range mismatches </span><span class="cov4" title="2">{
                logConfigMismatch(mismatch, action)
        }</span>

        // 如果配置为立即失败，返回错误
        <span class="cov4" title="2">if action.FailFast </span><span class="cov1" title="1">{
                return fmt.Errorf("topic config validation failed: found %d mismatches", len(mismatches))
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// compareTopicOptions 比较两个主题配置
func compareTopicOptions(topic string, expected, actual TopicOptions) []TopicConfigMismatch <span class="cov7" title="4">{
        var mismatches []TopicConfigMismatch

        // 比较持久化模式
        if expected.PersistenceMode != actual.PersistenceMode </span><span class="cov4" title="2">{
                mismatches = append(mismatches, TopicConfigMismatch{
                        Topic:          topic,
                        Field:          "PersistenceMode",
                        ExpectedValue:  expected.PersistenceMode,
                        ActualValue:    actual.PersistenceMode,
                        CanAutoFix:     false,
                        Recommendation: "Persistence mode cannot be changed after creation. Consider creating a new topic.",
                })
        }</span>

        // 比较保留时间（允许一定误差）
        <span class="cov7" title="4">if expected.RetentionTime &gt; 0 &amp;&amp; actual.RetentionTime &gt; 0 </span><span class="cov5" title="3">{
                diff := expected.RetentionTime - actual.RetentionTime
                if diff &lt; 0 </span><span class="cov4" title="2">{
                        diff = -diff
                }</span>
                // 允许1秒的误差
                <span class="cov5" title="3">if diff &gt; time.Second </span><span class="cov4" title="2">{
                        mismatches = append(mismatches, TopicConfigMismatch{
                                Topic:          topic,
                                Field:          "RetentionTime",
                                ExpectedValue:  expected.RetentionTime,
                                ActualValue:    actual.RetentionTime,
                                CanAutoFix:     true,
                                Recommendation: "Retention time can be updated. Set strategy to 'create_or_update' to auto-fix.",
                        })
                }</span>
        }

        // 比较最大大小
        <span class="cov7" title="4">if expected.MaxSize &gt; 0 &amp;&amp; actual.MaxSize &gt; 0 &amp;&amp; expected.MaxSize != actual.MaxSize </span><span class="cov1" title="1">{
                mismatches = append(mismatches, TopicConfigMismatch{
                        Topic:          topic,
                        Field:          "MaxSize",
                        ExpectedValue:  expected.MaxSize,
                        ActualValue:    actual.MaxSize,
                        CanAutoFix:     true,
                        Recommendation: "Max size can be updated. Set strategy to 'create_or_update' to auto-fix.",
                })
        }</span>

        // 比较最大消息数
        <span class="cov7" title="4">if expected.MaxMessages &gt; 0 &amp;&amp; actual.MaxMessages &gt; 0 &amp;&amp; expected.MaxMessages != actual.MaxMessages </span><span class="cov1" title="1">{
                mismatches = append(mismatches, TopicConfigMismatch{
                        Topic:          topic,
                        Field:          "MaxMessages",
                        ExpectedValue:  expected.MaxMessages,
                        ActualValue:    actual.MaxMessages,
                        CanAutoFix:     true,
                        Recommendation: "Max messages can be updated. Set strategy to 'create_or_update' to auto-fix.",
                })
        }</span>

        // 比较副本数
        <span class="cov7" title="4">if expected.Replicas &gt; 0 &amp;&amp; actual.Replicas &gt; 0 &amp;&amp; expected.Replicas != actual.Replicas </span><span class="cov1" title="1">{
                mismatches = append(mismatches, TopicConfigMismatch{
                        Topic:          topic,
                        Field:          "Replicas",
                        ExpectedValue:  expected.Replicas,
                        ActualValue:    actual.Replicas,
                        CanAutoFix:     false,
                        Recommendation: "Replicas cannot be changed after creation. Consider creating a new topic.",
                })
        }</span>

        <span class="cov7" title="4">return mismatches</span>
}

// shouldCreateOrUpdate 判断是否应该创建或更新
func shouldCreateOrUpdate(strategy TopicConfigStrategy, exists bool) (shouldCreate, shouldUpdate bool) <span class="cov10" title="8">{
        switch strategy </span>{
        case StrategyCreateOnly:<span class="cov4" title="2">
                return !exists, false</span>
        case StrategyCreateOrUpdate:<span class="cov4" title="2">
                return !exists, exists</span>
        case StrategyValidateOnly:<span class="cov4" title="2">
                return false, false</span>
        case StrategySkip:<span class="cov4" title="2">
                return false, false</span>
        default:<span class="cov0" title="0">
                return !exists, exists</span>
        }
}

// formatSyncResult 格式化同步结果日志
func formatSyncResult(result *TopicConfigSyncResult) <span class="cov0" title="0">{
        if result.Success </span><span class="cov0" title="0">{
                logger.Info("Topic config sync completed",
                        "topic", result.Topic,
                        "action", result.Action,
                        "duration", result.Duration)
        }</span> else<span class="cov0" title="0"> {
                logger.Error("Topic config sync failed",
                        "topic", result.Topic,
                        "action", result.Action,
                        "error", result.Error,
                        "duration", result.Duration)
        }</span>

        // 记录配置不一致
        <span class="cov0" title="0">if len(result.Mismatches) &gt; 0 </span><span class="cov0" title="0">{
                logger.Warn("Topic config mismatches detected",
                        "topic", result.Topic,
                        "count", len(result.Mismatches))
        }</span>
}

</pre>
		
		<pre class="file" id="file19" style="display: none">package eventbus

import (
        "context"
        "time"

        "github.com/ChenBigdata421/jxt-core/sdk/config"
)

// Topic常量定义 - 只定义技术基础设施相关的Topic
const (
        // 技术基础设施相关的Topic常量
        HealthCheckTopic = "health_check_topic" // 用于监控eventbus组件健康状态（已废弃，使用统一主题）

        // 可能的其他技术性Topic（根据需要添加）
        // DeadLetterTopic = "dead_letter_topic"  // 死信队列
        // MetricsTopic    = "metrics_topic"      // 指标收集
        // TracingTopic    = "tracing_topic"      // 链路追踪
)

// MessageHandler 消息处理器函数类型
type MessageHandler func(ctx context.Context, message []byte) error

// EventBus 统一事件总线接口（合并基础功能和企业特性）
type EventBus interface {
        // ========== 基础功能 ==========
        // 发布消息到指定主题
        Publish(ctx context.Context, topic string, message []byte) error
        // Subscribe 订阅原始消息（不使用Keyed-Worker池）
        // 特点：直接并发处理，极致性能，无顺序保证
        // 适用：简单消息、通知、缓存失效等不需要顺序的场景
        Subscribe(ctx context.Context, topic string, handler MessageHandler) error
        // 关闭连接
        Close() error
        // 注册重连回调
        RegisterReconnectCallback(callback ReconnectCallback) error

        // ========== 生命周期管理 ==========
        // 启动事件总线（根据配置启用相应功能）
        Start(ctx context.Context) error
        // 停止事件总线
        Stop() error

        // ========== 高级发布功能（可选启用） ==========
        // 使用选项发布消息
        PublishWithOptions(ctx context.Context, topic string, message []byte, opts PublishOptions) error
        // 设置消息格式化器
        SetMessageFormatter(formatter MessageFormatter) error
        // 注册发布回调
        RegisterPublishCallback(callback PublishCallback) error

        // ========== 高级订阅功能（可选启用） ==========
        // 使用选项订阅消息
        SubscribeWithOptions(ctx context.Context, topic string, handler MessageHandler, opts SubscribeOptions) error

        // ========== 积压检测功能 ==========
        // 注册订阅端积压回调
        RegisterSubscriberBacklogCallback(callback BacklogStateCallback) error
        // 启动订阅端积压监控
        StartSubscriberBacklogMonitoring(ctx context.Context) error
        // 停止订阅端积压监控
        StopSubscriberBacklogMonitoring() error

        // 注册发送端积压回调
        RegisterPublisherBacklogCallback(callback PublisherBacklogCallback) error
        // 启动发送端积压监控
        StartPublisherBacklogMonitoring(ctx context.Context) error
        // 停止发送端积压监控
        StopPublisherBacklogMonitoring() error

        // 根据配置启动所有积压监控（发送端和/或订阅端）
        StartAllBacklogMonitoring(ctx context.Context) error
        // 停止所有积压监控
        StopAllBacklogMonitoring() error

        // ========== 向后兼容接口（已废弃） ==========
        // 注册订阅端积压回调（已废弃，请使用RegisterSubscriberBacklogCallback）
        RegisterBacklogCallback(callback BacklogStateCallback) error
        // 启动订阅端积压监控（已废弃，请使用StartSubscriberBacklogMonitoring）
        StartBacklogMonitoring(ctx context.Context) error
        // 停止订阅端积压监控（已废弃，请使用StopSubscriberBacklogMonitoring）
        StopBacklogMonitoring() error
        // 设置消息路由器
        SetMessageRouter(router MessageRouter) error
        // 设置错误处理器
        SetErrorHandler(handler ErrorHandler) error
        // 注册订阅回调
        RegisterSubscriptionCallback(callback SubscriptionCallback) error

        // ========== 健康检查功能（分离发布端和订阅端） ==========
        // 发布端健康检查（发送健康检查消息）
        StartHealthCheckPublisher(ctx context.Context) error
        StopHealthCheckPublisher() error
        GetHealthCheckPublisherStatus() HealthCheckStatus
        RegisterHealthCheckPublisherCallback(callback HealthCheckCallback) error

        // 订阅端健康检查（监控健康检查消息）
        StartHealthCheckSubscriber(ctx context.Context) error
        StopHealthCheckSubscriber() error
        GetHealthCheckSubscriberStats() HealthCheckSubscriberStats
        RegisterHealthCheckSubscriberCallback(callback HealthCheckAlertCallback) error

        // 根据配置启动所有健康检查（发布端和/或订阅端）
        StartAllHealthCheck(ctx context.Context) error
        // 停止所有健康检查
        StopAllHealthCheck() error

        // 向后兼容的统一接口（已废弃，建议使用分离的接口）
        StartHealthCheck(ctx context.Context) error // 已废弃，使用StartHealthCheckPublisher
        StopHealthCheck() error                     // 已废弃，使用StopHealthCheckPublisher
        GetHealthStatus() HealthCheckStatus         // 已废弃，使用GetHealthCheckPublisherStatus
        // 获取连接状态
        GetConnectionState() ConnectionState
        // 获取监控指标
        GetMetrics() Metrics

        // ========== 主题持久化管理 ==========
        // ConfigureTopic 配置主题的持久化策略和其他选项
        // 必须在首次使用主题前调用，用于设置主题的持久化行为
        ConfigureTopic(ctx context.Context, topic string, options TopicOptions) error

        // SetTopicPersistence 设置主题是否持久化（简化接口）
        // persistent: true=持久化存储, false=内存存储（非持久化）
        SetTopicPersistence(ctx context.Context, topic string, persistent bool) error

        // GetTopicConfig 获取主题的当前配置
        GetTopicConfig(topic string) (TopicOptions, error)

        // ListConfiguredTopics 列出所有已配置的主题
        ListConfiguredTopics() []string

        // RemoveTopicConfig 移除主题配置（恢复为默认行为）
        RemoveTopicConfig(topic string) error

        // ========== 主题配置策略管理 ==========
        // SetTopicConfigStrategy 设置主题配置策略
        // 策略类型：
        //   - StrategyCreateOnly: 只创建，不更新（生产环境推荐）
        //   - StrategyCreateOrUpdate: 创建或更新（开发环境推荐）
        //   - StrategyValidateOnly: 只验证，不修改（严格模式）
        //   - StrategySkip: 跳过检查（性能优先）
        SetTopicConfigStrategy(strategy TopicConfigStrategy)

        // GetTopicConfigStrategy 获取当前主题配置策略
        GetTopicConfigStrategy() TopicConfigStrategy

        // ========== Envelope 支持（可选使用） ==========
        // 发布Envelope消息
        PublishEnvelope(ctx context.Context, topic string, envelope *Envelope) error
        // SubscribeEnvelope 订阅Envelope消息（自动使用Keyed-Worker池）
        // 特点：按聚合ID顺序处理，事件溯源支持，毫秒级延迟
        // 适用：领域事件、事件溯源、聚合管理等需要顺序保证的场景
        SubscribeEnvelope(ctx context.Context, topic string, handler EnvelopeHandler) error
}

// Publisher 发布器接口
type Publisher interface {
        // 发布消息
        Publish(ctx context.Context, topic string, message []byte) error
        // 关闭发布器
        Close() error
}

// Subscriber 订阅器接口
type Subscriber interface {
        // 订阅消息
        Subscribe(ctx context.Context, topic string, handler MessageHandler) error
        // 关闭订阅器
        Close() error
}

// TopicPersistenceMode 主题持久化模式
type TopicPersistenceMode string

const (
        // TopicPersistent 持久化存储（使用JetStream/Kafka等持久化机制）
        TopicPersistent TopicPersistenceMode = "persistent"
        // TopicEphemeral 非持久化存储（使用Core NATS/内存等非持久化机制）
        TopicEphemeral TopicPersistenceMode = "ephemeral"
        // TopicAuto 自动选择（根据EventBus全局配置决定）
        TopicAuto TopicPersistenceMode = "auto"
)

// TopicOptions 主题配置选项
type TopicOptions struct {
        // PersistenceMode 持久化模式
        PersistenceMode TopicPersistenceMode `json:"persistenceMode"`
        // RetentionTime 消息保留时间（仅持久化模式有效）
        RetentionTime time.Duration `json:"retentionTime,omitempty"`
        // MaxSize 主题最大存储大小（仅持久化模式有效）
        MaxSize int64 `json:"maxSize,omitempty"`
        // MaxMessages 主题最大消息数量（仅持久化模式有效）
        MaxMessages int64 `json:"maxMessages,omitempty"`
        // Replicas 副本数量（仅分布式存储有效，如Kafka）
        Replicas int `json:"replicas,omitempty"`
        // Description 主题描述（可选）
        Description string `json:"description,omitempty"`
}

// DefaultTopicOptions 返回默认的主题配置
func DefaultTopicOptions() TopicOptions <span class="cov10" title="115">{
        return TopicOptions{
                PersistenceMode: TopicAuto,
                RetentionTime:   24 * time.Hour,    // 默认保留24小时
                MaxSize:         100 * 1024 * 1024, // 默认100MB
                MaxMessages:     10000,             // 默认1万条消息
                Replicas:        1,                 // 默认单副本
        }
}</span>

// IsPersistent 判断是否为持久化模式
func (opts TopicOptions) IsPersistent(globalJetStreamEnabled bool) bool <span class="cov9" title="109">{
        switch opts.PersistenceMode </span>{
        case TopicPersistent:<span class="cov1" title="1">
                return true</span>
        case TopicEphemeral:<span class="cov1" title="1">
                return false</span>
        case TopicAuto:<span class="cov9" title="106">
                return globalJetStreamEnabled</span>
        default:<span class="cov1" title="1">
                return globalJetStreamEnabled</span>
        }
}

// EventBusConfig 事件总线配置
type EventBusConfig struct {
        Type       string           `mapstructure:"type"` // kafka, nats, memory
        Kafka      KafkaConfig      `mapstructure:"kafka"`
        NATS       NATSConfig       `mapstructure:"nats"`
        Metrics    MetricsConfig    `mapstructure:"metrics"`
        Tracing    TracingConfig    `mapstructure:"tracing"`
        Enterprise EnterpriseConfig `mapstructure:"enterprise"` // 企业特性配置
}

// EnterpriseConfig 企业特性配置
type EnterpriseConfig struct {
        // 发布端企业特性
        Publisher PublisherEnterpriseConfig `mapstructure:"publisher"`

        // 订阅端企业特性
        Subscriber SubscriberEnterpriseConfig `mapstructure:"subscriber"`

        // 统一企业特性
        HealthCheck HealthCheckConfig `mapstructure:"healthCheck"`
        Monitoring  MonitoringConfig  `mapstructure:"monitoring"`
}

// PublisherEnterpriseConfig 发布端企业特性配置
type PublisherEnterpriseConfig struct {
        // 发送端积压检测
        BacklogDetection config.PublisherBacklogDetectionConfig `mapstructure:"backlogDetection"`

        // 消息格式化
        MessageFormatter MessageFormatterConfig `mapstructure:"messageFormatter"`

        // 发布回调
        PublishCallback PublishCallbackConfig `mapstructure:"publishCallback"`

        // 重试策略
        RetryPolicy RetryPolicyConfig `mapstructure:"retryPolicy"`
}

// SubscriberEnterpriseConfig 订阅端企业特性配置
type SubscriberEnterpriseConfig struct {
        // 积压检测
        BacklogDetection config.SubscriberBacklogDetectionConfig `mapstructure:"backlogDetection"`

        // 流量控制
        RateLimit RateLimitConfig `mapstructure:"rateLimit"`

        // 死信队列
        DeadLetter DeadLetterConfig `mapstructure:"deadLetter"`

        // 消息路由
        MessageRouter MessageRouterConfig `mapstructure:"messageRouter"`

        // 错误处理
        ErrorHandler ErrorHandlerConfig `mapstructure:"errorHandler"`
}

// MessageFormatterConfig 消息格式化器配置
type MessageFormatterConfig struct {
        Enabled bool   `mapstructure:"enabled"`
        Type    string `mapstructure:"type"` // json, protobuf, avro
}

// PublishCallbackConfig 发布回调配置
type PublishCallbackConfig struct {
        Enabled bool `mapstructure:"enabled"`
}

// RetryPolicyConfig 重试策略配置
type RetryPolicyConfig struct {
        Enabled         bool          `mapstructure:"enabled"`
        MaxRetries      int           `mapstructure:"maxRetries"`
        InitialInterval time.Duration `mapstructure:"initialInterval"`
        MaxInterval     time.Duration `mapstructure:"maxInterval"`
        Multiplier      float64       `mapstructure:"multiplier"`
}

// BacklogDetectionConfig 积压检测配置（使用现有定义）
// 定义在 backlog_detector.go 中

// RateLimitConfig 流量控制配置（使用现有定义）
// 定义在 rate_limiter.go 中

// DeadLetterConfig 死信队列配置
type DeadLetterConfig struct {
        Enabled    bool   `mapstructure:"enabled"`
        Topic      string `mapstructure:"topic"`      // 死信队列主题
        MaxRetries int    `mapstructure:"maxRetries"` // 最大重试次数
}

// MessageRouterConfig 消息路由配置
type MessageRouterConfig struct {
        Enabled bool   `mapstructure:"enabled"`
        Type    string `mapstructure:"type"` // hash, round_robin, custom
}

// ErrorHandlerConfig 错误处理配置
type ErrorHandlerConfig struct {
        Enabled bool   `mapstructure:"enabled"`
        Type    string `mapstructure:"type"` // retry, deadletter, skip, fail
}

// HealthCheckConfig 健康检查配置
type HealthCheckConfig struct {
        Enabled          bool          `mapstructure:"enabled"`
        Topic            string        `mapstructure:"topic"`            // 健康检查主题（可选，默认使用统一主题）
        Interval         time.Duration `mapstructure:"interval"`         // 检查间隔
        Timeout          time.Duration `mapstructure:"timeout"`          // 检查超时
        FailureThreshold int           `mapstructure:"failureThreshold"` // 失败阈值
        MessageTTL       time.Duration `mapstructure:"messageTTL"`       // 消息存活时间
}

// MonitoringConfig 监控配置
type MonitoringConfig struct {
        Enabled         bool          `mapstructure:"enabled"`
        MetricsInterval time.Duration `mapstructure:"metricsInterval"`
        ExportEndpoint  string        `mapstructure:"exportEndpoint"`
}

// KafkaConfig Kafka配置
type KafkaConfig struct {
        Brokers             []string       `mapstructure:"brokers"`
        HealthCheckInterval time.Duration  `mapstructure:"healthCheckInterval"`
        Producer            ProducerConfig `mapstructure:"producer"`
        Consumer            ConsumerConfig `mapstructure:"consumer"`
        Security            SecurityConfig `mapstructure:"security"`
}

// ProducerConfig 生产者配置
type ProducerConfig struct {
        RequiredAcks   int           `mapstructure:"requiredAcks"`
        Compression    string        `mapstructure:"compression"`
        FlushFrequency time.Duration `mapstructure:"flushFrequency"`
        FlushMessages  int           `mapstructure:"flushMessages"`
        RetryMax       int           `mapstructure:"retryMax"`
        Timeout        time.Duration `mapstructure:"timeout"`
        BatchSize      int           `mapstructure:"batchSize"`
        BufferSize     int           `mapstructure:"bufferSize"`
}

// ConsumerConfig 消费者配置
type ConsumerConfig struct {
        GroupID           string        `mapstructure:"groupId"`
        AutoOffsetReset   string        `mapstructure:"autoOffsetReset"`
        SessionTimeout    time.Duration `mapstructure:"sessionTimeout"`
        HeartbeatInterval time.Duration `mapstructure:"heartbeatInterval"`
        MaxProcessingTime time.Duration `mapstructure:"maxProcessingTime"`
        FetchMinBytes     int           `mapstructure:"fetchMinBytes"`
        FetchMaxBytes     int           `mapstructure:"fetchMaxBytes"`
        FetchMaxWait      time.Duration `mapstructure:"fetchMaxWait"`
}

// SecurityConfig 安全配置
type SecurityConfig struct {
        Enabled  bool   `mapstructure:"enabled"`
        Protocol string `mapstructure:"protocol"`
        Username string `mapstructure:"username"`
        Password string `mapstructure:"password"`
        CertFile string `mapstructure:"certFile"`
        KeyFile  string `mapstructure:"keyFile"`
        CAFile   string `mapstructure:"caFile"`
}

// NATSConfig NATS JetStream配置
type NATSConfig struct {
        URLs                []string      `mapstructure:"urls"`
        ClientID            string        `mapstructure:"clientId"`
        MaxReconnects       int           `mapstructure:"maxReconnects"`
        ReconnectWait       time.Duration `mapstructure:"reconnectWait"`
        ConnectionTimeout   time.Duration `mapstructure:"connectionTimeout"`
        HealthCheckInterval time.Duration `mapstructure:"healthCheckInterval"`

        // JetStream配置
        JetStream JetStreamConfig `mapstructure:"jetstream"`

        // 安全配置
        Security NATSSecurityConfig `mapstructure:"security"`
}

// JetStreamConfig JetStream配置
type JetStreamConfig struct {
        Enabled        bool          `mapstructure:"enabled"`
        Domain         string        `mapstructure:"domain"`
        APIPrefix      string        `mapstructure:"apiPrefix"`
        PublishTimeout time.Duration `mapstructure:"publishTimeout"`
        AckWait        time.Duration `mapstructure:"ackWait"`
        MaxDeliver     int           `mapstructure:"maxDeliver"`

        // 流配置
        Stream StreamConfig `mapstructure:"stream"`

        // 消费者配置
        Consumer NATSConsumerConfig `mapstructure:"consumer"`
}

// StreamConfig 流配置
type StreamConfig struct {
        Name      string        `mapstructure:"name"`
        Subjects  []string      `mapstructure:"subjects"`
        Retention string        `mapstructure:"retention"` // limits, interest, workqueue
        Storage   string        `mapstructure:"storage"`   // file, memory
        Replicas  int           `mapstructure:"replicas"`
        MaxAge    time.Duration `mapstructure:"maxAge"`
        MaxBytes  int64         `mapstructure:"maxBytes"`
        MaxMsgs   int64         `mapstructure:"maxMsgs"`
        Discard   string        `mapstructure:"discard"` // old, new
}

// NATSConsumerConfig NATS消费者配置
type NATSConsumerConfig struct {
        DurableName   string          `mapstructure:"durableName"`
        DeliverPolicy string          `mapstructure:"deliverPolicy"` // all, last, new, by_start_sequence, by_start_time
        AckPolicy     string          `mapstructure:"ackPolicy"`     // none, all, explicit
        ReplayPolicy  string          `mapstructure:"replayPolicy"`  // instant, original
        MaxAckPending int             `mapstructure:"maxAckPending"`
        MaxWaiting    int             `mapstructure:"maxWaiting"`
        MaxDeliver    int             `mapstructure:"maxDeliver"`
        BackOff       []time.Duration `mapstructure:"backOff"`
}

// NATSSecurityConfig NATS安全配置
type NATSSecurityConfig struct {
        Enabled    bool   `mapstructure:"enabled"`
        Token      string `mapstructure:"token"`
        Username   string `mapstructure:"username"`
        Password   string `mapstructure:"password"`
        NKeyFile   string `mapstructure:"nkeyFile"`
        CredFile   string `mapstructure:"credFile"`
        CertFile   string `mapstructure:"certFile"`
        KeyFile    string `mapstructure:"keyFile"`
        CAFile     string `mapstructure:"caFile"`
        SkipVerify bool   `mapstructure:"skipVerify"`
}

// MetricsConfig 指标配置
type MetricsConfig struct {
        Enabled         bool          `mapstructure:"enabled"`
        CollectInterval time.Duration `mapstructure:"collectInterval"`
        ExportEndpoint  string        `mapstructure:"exportEndpoint"`
}

// TracingConfig 链路追踪配置
type TracingConfig struct {
        Enabled     bool    `mapstructure:"enabled"`
        ServiceName string  `mapstructure:"serviceName"`
        Endpoint    string  `mapstructure:"endpoint"`
        SampleRate  float64 `mapstructure:"sampleRate"`
}

// ========== 企业特性相关类型定义 ==========

// SubscribeOptions 订阅选项
type SubscribeOptions struct {
        ProcessingTimeout time.Duration `json:"processingTimeout"` // 处理超时时间
        RateLimit         float64       `json:"rateLimit"`         // 速率限制（每秒）
        RateBurst         int           `json:"rateBurst"`         // 突发大小
        MaxRetries        int           `json:"maxRetries"`        // 最大重试次数
        RetryBackoff      time.Duration `json:"retryBackoff"`      // 重试退避时间
        DeadLetterEnabled bool          `json:"deadLetterEnabled"` // 是否启用死信队列
        RetryPolicy       RetryPolicy   `json:"retryPolicy"`       // 重试策略
}

// PublishOptions 发布选项
type PublishOptions struct {
        MessageFormatter MessageFormatter  `json:"-"`           // 消息格式化器
        Metadata         map[string]string `json:"metadata"`    // 元数据
        RetryPolicy      RetryPolicy       `json:"retryPolicy"` // 重试策略
        Timeout          time.Duration     `json:"timeout"`     // 超时时间
        AggregateID      interface{}       `json:"aggregateId"` // 聚合ID
}

// RetryPolicy 重试策略
type RetryPolicy struct {
        MaxRetries      int           `json:"maxRetries"`      // 最大重试次数
        InitialInterval time.Duration `json:"initialInterval"` // 初始间隔
        MaxInterval     time.Duration `json:"maxInterval"`     // 最大间隔
        Multiplier      float64       `json:"multiplier"`      // 倍数
}

// ConnectionState 连接状态
type ConnectionState struct {
        IsConnected       bool      `json:"isConnected"`
        LastConnectedTime time.Time `json:"lastConnectedTime"`
        ReconnectCount    int       `json:"reconnectCount"`
        LastError         string    `json:"lastError,omitempty"`
}

// HealthCheckStatus 健康检查状态
type HealthCheckStatus struct {
        IsHealthy           bool      `json:"isHealthy"`
        ConsecutiveFailures int       `json:"consecutiveFailures"`
        LastSuccessTime     time.Time `json:"lastSuccessTime"`
        LastFailureTime     time.Time `json:"lastFailureTime"`
        IsRunning           bool      `json:"isRunning"`
        EventBusType        string    `json:"eventBusType"`
        Source              string    `json:"source"`
}

// PublisherBacklogState 发送端积压状态
type PublisherBacklogState struct {
        HasBacklog        bool          `json:"hasBacklog"`
        QueueDepth        int64         `json:"queueDepth"`
        PublishRate       float64       `json:"publishRate"`
        AvgPublishLatency time.Duration `json:"avgPublishLatency"`
        BacklogRatio      float64       `json:"backlogRatio"` // 积压比例 (0.0-1.0)
        Timestamp         time.Time     `json:"timestamp"`
        Severity          string        `json:"severity"` // LOW, MEDIUM, HIGH, CRITICAL
}

// 回调函数类型
type BacklogStateCallback func(ctx context.Context, state BacklogState) error
type PublisherBacklogCallback func(ctx context.Context, state PublisherBacklogState) error
type HealthCheckCallback func(ctx context.Context, result HealthCheckResult) error
type ReconnectCallback func(ctx context.Context) error
type PublishCallback func(ctx context.Context, topic string, message []byte, err error) error
type SubscriptionCallback func(ctx context.Context, event SubscriptionEvent) error

// BacklogState 积压状态
type BacklogState struct {
        HasBacklog    bool          `json:"hasBacklog"`
        LagCount      int64         `json:"lagCount"`
        LagTime       time.Duration `json:"lagTime"`
        Timestamp     time.Time     `json:"timestamp"`
        Topic         string        `json:"topic"`
        ConsumerGroup string        `json:"consumerGroup"`
}

// HealthCheckResult 健康检查结果
type HealthCheckResult struct {
        Success             bool          `json:"success"`
        Timestamp           time.Time     `json:"timestamp"`
        Duration            time.Duration `json:"duration"`
        Error               error         `json:"error,omitempty"`
        ConsecutiveFailures int           `json:"consecutiveFailures"`
        EventBusType        string        `json:"eventBusType"`
        Source              string        `json:"source"`
}

// SubscriptionEvent 订阅事件
type SubscriptionEvent struct {
        Type      SubscriptionEventType `json:"type"`
        Topic     string                `json:"topic"`
        Timestamp time.Time             `json:"timestamp"`
        Message   string                `json:"message"`
        Error     error                 `json:"error,omitempty"`
}

// SubscriptionEventType 订阅事件类型
type SubscriptionEventType string

const (
        SubscriptionStarted      SubscriptionEventType = "started"
        SubscriptionStopped      SubscriptionEventType = "stopped"
        SubscriptionError        SubscriptionEventType = "error"
        SubscriptionEventStarted SubscriptionEventType = "started"
        SubscriptionEventStopped SubscriptionEventType = "stopped"
        SubscriptionEventError   SubscriptionEventType = "error"
        SubscriptionEventMessage SubscriptionEventType = "message"
)

// MessageRouter 消息路由器接口
type MessageRouter interface {
        // Route 根据消息内容决定路由策略
        Route(ctx context.Context, topic string, message []byte) (RouteDecision, error)
}

// RouteDecision 路由决策
type RouteDecision struct {
        ShouldProcess bool              `json:"shouldProcess"` // 是否应该处理这个消息
        AggregateID   string            `json:"aggregateId"`   // 聚合ID（用于聚合处理器）
        ProcessorKey  string            `json:"processorKey"`  // 处理器键（用于负载均衡）
        Priority      int               `json:"priority"`      // 优先级
        Metadata      map[string]string `json:"metadata"`      // 额外的元数据
}

// ErrorHandler 错误处理器接口
type ErrorHandler interface {
        // HandleError 处理错误
        HandleError(ctx context.Context, err error, message []byte, topic string) ErrorAction
}

// ErrorAction 错误处理动作
type ErrorAction struct {
        Action      ErrorActionType   `json:"action"`      // 动作类型
        RetryAfter  time.Duration     `json:"retryAfter"`  // 重试延迟
        DeadLetter  bool              `json:"deadLetter"`  // 是否发送到死信队列
        SkipMessage bool              `json:"skipMessage"` // 是否跳过消息
        Metadata    map[string]string `json:"metadata"`    // 额外的元数据
}

// ErrorActionType 错误动作类型
type ErrorActionType string

const (
        ErrorActionRetry      ErrorActionType = "retry"      // 重试
        ErrorActionDeadLetter ErrorActionType = "deadletter" // 死信队列
        ErrorActionSkip       ErrorActionType = "skip"       // 跳过
        ErrorActionFail       ErrorActionType = "fail"       // 失败
)

// MessageFormatter 消息格式化器接口
type MessageFormatter interface {
        // FormatMessage 格式化消息
        FormatMessage(uuid string, aggregateID interface{}, payload []byte) (*Message, error)
        // ExtractAggregateID 提取聚合ID
        ExtractAggregateID(aggregateID interface{}) string
        // SetMetadata 设置元数据
        SetMetadata(msg *Message, metadata map[string]string) error
}

// Message 消息结构
type Message struct {
        UUID     string            `json:"uuid"`
        Payload  []byte            `json:"payload"`
        Metadata map[string]string `json:"metadata"`
}

// NewMessage 创建新消息
func NewMessage(uuid string, payload []byte) *Message <span class="cov6" title="14">{
        return &amp;Message{
                UUID:     uuid,
                Payload:  payload,
                Metadata: make(map[string]string),
        }
}</span>

// Metrics 监控指标
type Metrics struct {
        MessagesPublished int64     `json:"messagesPublished"`
        MessagesConsumed  int64     `json:"messagesConsumed"`
        PublishErrors     int64     `json:"publishErrors"`
        ConsumeErrors     int64     `json:"consumeErrors"`
        ConnectionErrors  int64     `json:"connectionErrors"`
        LastHealthCheck   time.Time `json:"lastHealthCheck"`
        HealthCheckStatus string    `json:"healthCheckStatus"`
        ActiveConnections int       `json:"activeConnections"`
        MessageBacklog    int64     `json:"messageBacklog"`
}

// HealthStatus 综合健康状态
type HealthStatus struct {
        Overall        string                 `json:"overall"` // healthy, unhealthy, degraded
        Infrastructure InfrastructureHealth   `json:"infrastructure"`
        Business       interface{}            `json:"business,omitempty"`
        Timestamp      time.Time              `json:"timestamp"`
        CheckDuration  time.Duration          `json:"checkDuration"`
        Details        map[string]interface{} `json:"details,omitempty"`
}

// InfrastructureHealth 基础设施健康状态
type InfrastructureHealth struct {
        EventBus EventBusHealthMetrics `json:"eventBus"`
        Database *DatabaseHealth       `json:"database,omitempty"`
        Cache    *CacheHealth          `json:"cache,omitempty"`
}

// EventBusHealthMetrics EventBus 健康指标
type EventBusHealthMetrics struct {
        ConnectionStatus    string        `json:"connectionStatus"`    // connected, disconnected, reconnecting
        PublishLatency      time.Duration `json:"publishLatency"`      // 发布延迟
        SubscribeLatency    time.Duration `json:"subscribeLatency"`    // 订阅延迟
        LastSuccessTime     time.Time     `json:"lastSuccessTime"`     // 最后成功时间
        LastFailureTime     time.Time     `json:"lastFailureTime"`     // 最后失败时间
        ConsecutiveFailures int           `json:"consecutiveFailures"` // 连续失败次数
        ThroughputPerSecond int64         `json:"throughputPerSecond"` // 每秒吞吐量
        MessageBacklog      int64         `json:"messageBacklog"`      // 消息积压
        ReconnectCount      int           `json:"reconnectCount"`      // 重连次数
        BrokerCount         int           `json:"brokerCount"`         // 可用 Broker 数量
        TopicCount          int           `json:"topicCount"`          // 可用 Topic 数量
}

// DatabaseHealth 数据库健康状态
type DatabaseHealth struct {
        Status          string        `json:"status"`
        ResponseTime    time.Duration `json:"responseTime"`
        ConnectionCount int           `json:"connectionCount"`
}

// CacheHealth 缓存健康状态
type CacheHealth struct {
        Status       string        `json:"status"`
        ResponseTime time.Duration `json:"responseTime"`
        HitRate      float64       `json:"hitRate"`
}

// BusinessHealthChecker 业务健康检查接口
type BusinessHealthChecker interface {
        // 检查业务健康状态
        CheckBusinessHealth(ctx context.Context) error
        // 获取业务指标
        GetBusinessMetrics() interface{}
        // 获取业务配置
        GetBusinessConfig() interface{}
}

// EventBusHealthChecker EventBus 健康检查器接口（仅周期性健康检查）
type EventBusHealthChecker interface {
        // 注册业务健康检查
        RegisterBusinessHealthCheck(checker BusinessHealthChecker)
        // 获取健康状态（聚合状态）
        GetHealthStatus() HealthCheckStatus
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
