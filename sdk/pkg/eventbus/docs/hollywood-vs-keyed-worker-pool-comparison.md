# Hollywood Actor Pool vs Keyed Worker Pool 详细对比

> **重要**: 本方案使用 **固定 Actor Pool**,适合千万级聚合ID场景。

## 📊 **架构对比**

### Keyed Worker Pool (当前架构)

```
┌─────────────────────────────────────────────────────────────┐
│                    Kafka/NATS Consumer                      │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│              ExtractAggregateID(message)                    │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│         Hash(aggregateID) % 256 → workerIndex               │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│  Worker[0]   Worker[1]   ...   Worker[255]                  │
│  ┌────────┐  ┌────────┐        ┌────────┐                  │
│  │Queue   │  │Queue   │        │Queue   │                  │
│  │[1000]  │  │[1000]  │  ...   │[1000]  │                  │
│  └────────┘  └────────┘        └────────┘                  │
│      ↓           ↓                  ↓                       │
│  Goroutine  Goroutine          Goroutine                    │
│  串行处理   串行处理            串行处理                     │
└─────────────────────────────────────────────────────────────┘

特点:
✅ 固定资源: 256个 goroutine + 256K 队列容量
✅ 简单实现: 一致性哈希路由
⚠️ 头部阻塞: order-123 慢 → 阻塞 order-456 (如果哈希到同一Worker)
❌ 无 Supervisor: Worker panic → 所有路由到该 Worker 的聚合都受影响
❌ 无事件流监控: 缺乏 DeadLetter, ActorRestarted 等事件
❌ 消息可能丢失: 队列满时消息被拒绝
```

### Hollywood Actor Pool (目标架构)

```
┌─────────────────────────────────────────────────────────────┐
│                    Kafka/NATS Consumer                      │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│              ExtractAggregateID(message)                    │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│         Hash(aggregateID) % 256 → actorIndex                │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│  Actor[0]    Actor[1]    ...   Actor[255]                   │
│  ┌──────────┐ ┌──────────┐    ┌──────────┐                 │
│  │Inbox     │ │Inbox     │    │Inbox     │                 │
│  │[1000]    │ │[1000]    │... │[1000]    │                 │
│  │          │ │          │    │          │                 │
│  │Supervisor│ │Supervisor│    │Supervisor│                 │
│  │自动重启  │ │自动重启  │    │自动重启  │                 │
│  └──────────┘ └──────────┘    └──────────┘                 │
│      ↓           ↓                  ↓                       │
│  串行处理   串行处理            串行处理                     │
└─────────────────────────────────────────────────────────────┘

特点:
✅ 固定资源: 256个 Actor,资源可控
✅ 一致性哈希路由: 同一聚合ID → 同一Actor
⚠️ 头部阻塞: order-123 慢 → 阻塞 order-456 (如果哈希到同一Actor)
✅ Supervisor 机制: Actor panic 自动重启,不影响其他 Actor
✅ 事件流监控: DeadLetter, ActorRestarted 事件
✅ 消息保证: Buffer 机制确保消息不丢失
✅ 更好的可观测性: 事件流 + 详细指标
```

---

## 🔍 **核心问题对比**

### 问题 1: 头部阻塞 (Head-of-Line Blocking)

#### Keyed Worker Pool

```go
// 场景: order-123 和 order-456 哈希到同一个 Worker[5]
Worker[5] 队列:
┌─────────────────────────────────────────────────────┐
│ order-123 (处理中,耗时10秒)                         │
│ order-456 (等待中) ← 被阻塞!                        │
│ order-789 (等待中) ← 被阻塞!                        │
│ order-123 (等待中) ← 同一聚合的后续消息也等待       │
└─────────────────────────────────────────────────────┘

问题:
❌ order-456 和 order-789 必须等待 order-123 处理完成
❌ 即使它们是完全不同的聚合,也无法并发处理
❌ 一个慢聚合影响整个 Worker 的吞吐量
```

#### Hollywood Actor Pool (固定 Pool)

```go
// 场景: order-123 和 order-456 哈希到同一个 Actor[5]
Actor[5] Inbox:
┌─────────────────────────────────────────────────────┐
│ order-123 (处理中,耗时10秒)                         │
│ order-456 (等待中) ← 仍然被阻塞! ⚠️                 │
│ order-789 (等待中) ← 仍然被阻塞! ⚠️                 │
│ order-123 (等待中) ← 同一聚合的后续消息也等待       │
└─────────────────────────────────────────────────────┘

问题:
⚠️ order-456 和 order-789 仍然必须等待 order-123 处理完成
⚠️ 头部阻塞问题与 Keyed Worker Pool 完全相同
⚠️ 这是固定 Pool 架构的固有局限

说明:
- 固定 Pool 使用 Hash(aggregateID) % 256 路由
- 不同聚合ID可能路由到同一个Actor
- Actor 内部串行处理消息,存在头部阻塞
- 这是千万级聚合ID场景下的必然权衡
```

---

### 问题 2: 资源利用效率

**说明**: 固定 Actor Pool 与 Keyed Worker Pool 在资源利用效率上**完全相同**。

#### Keyed Worker Pool

```go
// 固定资源分配
Worker 数量: 256 (固定)
Goroutine 数量: 256 (固定)
内存占用: 256 * 1000 * 200字节 ≈ 50MB (固定)

特点:
✅ 资源可控,内存占用可预测
⚠️ 资源固定,无法动态伸缩
```

#### Hollywood Actor Pool (固定 Pool)

```go
// 固定资源分配
Actor 数量: 256 (固定)
Goroutine 数量: 256 (固定)
内存占用: 256 * 1000 * 200字节 ≈ 50MB (固定)

特点:
✅ 资源可控,内存占用可预测
⚠️ 资源固定,无法动态伸缩
```

**结论**: 两者在资源利用效率上完全相同,都是固定资源分配。

---

### 问题 3: 故障隔离 (Hollywood Actor Pool 的核心优势)

#### Keyed Worker Pool

```go
// 场景: order-123 处理时 panic
Worker[5] 处理流程:
1. 处理 order-123 消息
2. 业务代码 panic
3. Worker goroutine 崩溃
4. 整个 Worker[5] 停止
5. 所有路由到 Worker[5] 的聚合都受影响:
   - order-123 ❌
   - order-456 ❌ (无辜受害)
   - order-789 ❌ (无辜受害)

影响范围:
❌ Worker 级别故障
❌ 影响多个聚合 (平均 1000/256 ≈ 4个聚合)
❌ 需要重启整个 Worker
❌ 队列中的消息可能丢失
```

#### Hollywood Actor Pool (固定 Pool)

```go
// 场景: Actor[5] 处理 order-123 时 panic
Actor[5] 处理流程:
1. 处理 order-123 消息
2. 业务代码 panic
3. Supervisor 捕获 panic ✅
4. 自动重启 Actor[5] ✅
5. Inbox 中的消息保留 (order-456, order-789) ✅
6. 继续处理后续消息

其他 Actor (Actor[0], Actor[1], ..., Actor[255]):
   - 完全不受影响 ✅

影响范围:
✅ Actor 级别故障 (而非 Worker 级别)
✅ 其他 255 个 Actor 完全不受影响
✅ Supervisor 自动重启 (最多 3 次)
✅ 消息保证不丢失 (Buffer 机制)
✅ 事件流监控: ActorRestarted 事件可观测
```

---

### 问题 4: 消息可靠性

#### Keyed Worker Pool

```go
// 场景: Worker 队列满
Worker[5] 队列状态:
┌─────────────────────────────────────────────────────┐
│ [1000/1000] 队列已满                                │
└─────────────────────────────────────────────────────┘

新消息到达:
1. 尝试入队
2. 队列满,等待 500ms (WaitTimeout)
3. 超时后返回 ErrWorkerQueueFull
4. 消息丢失 ❌

问题:
❌ 队列满时消息可能丢失
❌ 需要上层处理背压
❌ 无消息保证机制
```

#### Hollywood Actor

```go
// 场景: Actor Inbox 满
Actor[order-123] Inbox 状态:
┌─────────────────────────────────────────────────────┐
│ [1000/1000] Inbox 已满                              │
└─────────────────────────────────────────────────────┘

新消息到达:
1. 尝试发送到 Inbox
2. Inbox 满,消息进入 Buffer
3. Buffer 保证消息不丢失
4. Actor 处理完成后,从 Buffer 取消息
5. 消息最终被处理 ✅

优势:
✅ Buffer 机制保证消息不丢失
✅ 自动背压控制
✅ 消息可靠性保证
```

---

## 📈 **性能对比**

⚠️ **重要说明**:
- 以下性能数据为**理论分析和示例数据**，实际性能取决于：
  - 消息处理逻辑复杂度
  - Supervisor/Middleware/EventStream 开销
  - 系统负载和硬件环境
  - Inbox 大小和消息大小
- **强烈建议**: 在实际环境中进行压测验证后再做决策

---

### 吞吐量测试 (理论分析)

```go
// 测试场景: 1000个不同聚合,每个聚合100条消息

Keyed Worker Pool:
- 总消息数: 100,000
- 处理时间: 1000ms (示例)
- 吞吐量: 100,000 TPS (示例)
- 瓶颈: 固定256个 Worker,头部阻塞

Hollywood Actor Pool (固定 Pool):
- 总消息数: 100,000
- 处理时间: ≈ 与 Keyed Worker Pool 持平 (±5%)
- 吞吐量: ≈ 与 Keyed Worker Pool 持平 (±5%)
- 说明:
  - 固定 Pool 仍存在头部阻塞,架构路由相同
  - Supervisor/Middleware 可能引入轻微开销 (通常 < 5%)
  - 优势在于可靠性、可观测性,而非吞吐量提升
```

### 延迟测试 (理论分析)

```go
// 测试场景: 单条消息处理延迟

Keyed Worker Pool:
- P50: 10ms (示例)
- P99: 50ms (示例)
- P999: 200ms (示例)
- 原因: 队列等待 + 头部阻塞

Hollywood Actor Pool (固定 Pool):
- P50/P99/P999: ≈ 与 Keyed Worker Pool 持平 (±5%)
- 说明:
  - 架构路由相同,头部阻塞特性一致
  - Middleware 拦截可能增加微秒级开销 (通常可忽略)
  - 需实测验证实际延迟分布
```

### 资源占用 (理论分析)

```go
// 测试场景: 100个活跃聚合

Keyed Worker Pool:
- Goroutine: 256 (固定)
- 内存: 50MB (示例, 取决于队列大小和消息大小)
- CPU: 30% (示例, 取决于业务负载)

Hollywood Actor Pool (固定 Pool):
- Goroutine: 256 (固定) + 1 (Engine) + EventStream 订阅
- 内存: ~50MB (示例, 取决于 inboxSize 与消息大小)
  - 每个 Actor Inbox: inboxSize * 消息大小
  - EventStream: 轻微额外开销 (< 1MB)
- CPU: 与业务负载相关 (架构不引入动态伸缩)
  - Supervisor/Middleware 开销通常 < 5%
```

---

## 🎯 **迁移收益总结**

⚠️ **注意**: 以下对比基于理论分析和示例数据，实际收益需在生产环境验证。

| 维度 | Keyed Worker Pool | Hollywood Actor Pool | 改进 |
|------|------------------|---------------------|------|
| **吞吐量** | 基准 | ~持平 (±5%) | 架构相同,性能持平 |
| **延迟 P99** | 基准 | ~持平 (±5%) | 架构相同,延迟持平 |
| **头部阻塞** | ❌ 存在 | ❌ 存在 | 固定 Pool 特性,无改进 |
| **资源利用** | 固定,可控 | 固定,可控 | 资源占用相当 |
| **故障隔离** | Worker 级 | ✅ Actor 级 (更细粒度) | **一个 Actor panic 不影响其他** |
| **故障恢复** | ❌ 手动处理 | ✅ Supervisor 自动重启 | **自动恢复,减少人工介入** |
| **消息可靠性** | ⚠️ panic 可能丢失 | ✅ Buffer 保证送达 | **零丢失 (Inbox 未满时)** |
| **可观测性** | 基础指标 | ✅ 事件流 + 丰富指标 | **DeadLetter/Restart 事件** |
| **代码复杂度** | 简单 | 中等 | 学习成本可接受 |

### 核心价值主张

**Hollywood Actor Pool 的真正优势不在于性能提升，而在于**:

1. ✅ **Supervisor 机制**: Actor panic 自动重启，不影响其他 Actor
2. ✅ **事件流监控**: DeadLetter、ActorRestarted 事件，故障可观测
3. ✅ **消息保证**: Buffer 机制确保消息不丢失 (Inbox 未满时)
4. ✅ **更好的故障隔离**: Actor 级隔离 (虽非完美，但优于 Worker 级)
5. ✅ **丰富的可观测性**: 详细指标 + 事件流

⚠️ **需要明确的限制**:
- ❌ **不解决头部阻塞**: 固定 Pool 下，不同聚合ID可能共享同一个 Actor
- ❌ **不提升吞吐量**: 架构路由相同，性能持平
- ❌ **不是完美隔离**: 共享 Actor 的聚合仍会相互影响 (头部阻塞)

---

## 💡 **迁移建议**

### 适合迁移的场景

1. ✅ **高并发场景**: 大量不同聚合并发处理
2. ✅ **延迟敏感**: 要求 P99 延迟 < 50ms
3. ✅ **资源动态**: 流量波动大,需要动态伸缩
4. ✅ **可靠性要求高**: 不能接受消息丢失
5. ✅ **故障隔离**: 需要细粒度的故障隔离

### 不适合迁移的场景

1. ❌ **极简场景**: 只有少量聚合,固定流量
2. ❌ **资源受限**: 无法接受动态 goroutine 创建
3. ❌ **团队不熟悉**: 团队对 Actor 模型不熟悉,学习成本高

---

## 🚀 **迁移路径**

### 阶段 1: 准备 (1-2天)
- 安装 Hollywood 依赖
- 学习 Actor 模型
- 设计架构方案

### 阶段 2: 实现 (3-5天)
- 实现核心组件
- 编写单元测试
- 集成到 EventBus

### 阶段 3: 测试 (3-5天)
- 功能测试
- 性能测试
- 压力测试

### 阶段 4: 灰度 (2-3天)
- 10% 流量灰度
- 50% 流量灰度
- 监控对比

### 阶段 5: 上线 (1-2天)
- 100% 流量切换
- 清理旧代码
- 文档更新

**总工期: 10-15天**

---

## 📚 **参考文档**

1. **详细迁移指南**: `hollywood-actor-migration-guide.md`
2. **快速参考**: `hollywood-quick-reference.md`
3. **实现示例**: `hollywood-implementation-example.md`
4. **Hollywood 官方文档**: https://github.com/anthdm/hollywood

